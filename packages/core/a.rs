#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
type Result<T> = std::result::Result<T, error::CoreError>;
pub mod env {
    use lazy_static::lazy_static;
    use std::{collections::HashMap, sync::Mutex};
    use socketioxide::extract::SocketRef;
    use crate::graph::action::DefaultNodes;
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct REDIS_URL {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static REDIS_URL: REDIS_URL = REDIS_URL { __private_field: () };
    impl ::lazy_static::__Deref for REDIS_URL {
        type Target = Mutex<String>;
        fn deref(&self) -> &Mutex<String> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<String> {
                Mutex::new("redis://localhost:6379".to_string())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<String> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<String>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for REDIS_URL {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct REDIS_CLIENT {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static REDIS_CLIENT: REDIS_CLIENT = REDIS_CLIENT {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for REDIS_CLIENT {
        type Target = Mutex<redis::Client>;
        fn deref(&self) -> &Mutex<redis::Client> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<redis::Client> {
                Mutex::new(
                    redis::Client::open(REDIS_URL.lock().unwrap().clone())
                        .expect("Failed to create Redis client"),
                )
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<redis::Client> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<redis::Client>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for REDIS_CLIENT {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct PATH_VIS {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static PATH_VIS: PATH_VIS = PATH_VIS { __private_field: () };
    impl ::lazy_static::__Deref for PATH_VIS {
        type Target = Mutex<HashMap<i32, HashMap<i64, bool>>>;
        fn deref(&self) -> &Mutex<HashMap<i32, HashMap<i64, bool>>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<HashMap<i32, HashMap<i64, bool>>> {
                Mutex::new(HashMap::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<HashMap<i32, HashMap<i64, bool>>> {
                static LAZY: ::lazy_static::lazy::Lazy<
                    Mutex<HashMap<i32, HashMap<i64, bool>>>,
                > = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATH_VIS {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct SAVED_NODE_PATH {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static SAVED_NODE_PATH: SAVED_NODE_PATH = SAVED_NODE_PATH {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for SAVED_NODE_PATH {
        type Target = Mutex<HashMap<(i64, String), HashMap<i64, i64>>>;
        fn deref(&self) -> &Mutex<HashMap<(i64, String), HashMap<i64, i64>>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<
                HashMap<(i64, String), HashMap<i64, i64>>,
            > {
                Mutex::new(HashMap::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<
                HashMap<(i64, String), HashMap<i64, i64>>,
            > {
                static LAZY: ::lazy_static::lazy::Lazy<
                    Mutex<HashMap<(i64, String), HashMap<i64, i64>>>,
                > = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for SAVED_NODE_PATH {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct SAVED_NODE_PATH_REV {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static SAVED_NODE_PATH_REV: SAVED_NODE_PATH_REV = SAVED_NODE_PATH_REV {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for SAVED_NODE_PATH_REV {
        type Target = Mutex<HashMap<(i64, String), HashMap<i64, i64>>>;
        fn deref(&self) -> &Mutex<HashMap<(i64, String), HashMap<i64, i64>>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<
                HashMap<(i64, String), HashMap<i64, i64>>,
            > {
                Mutex::new(HashMap::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<
                HashMap<(i64, String), HashMap<i64, i64>>,
            > {
                static LAZY: ::lazy_static::lazy::Lazy<
                    Mutex<HashMap<(i64, String), HashMap<i64, i64>>>,
                > = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for SAVED_NODE_PATH_REV {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct SAVED_NODE_PATH_LIST {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static SAVED_NODE_PATH_LIST: SAVED_NODE_PATH_LIST = SAVED_NODE_PATH_LIST {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for SAVED_NODE_PATH_LIST {
        type Target = Mutex<HashMap<String, Vec<i64>>>;
        fn deref(&self) -> &Mutex<HashMap<String, Vec<i64>>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<HashMap<String, Vec<i64>>> {
                Mutex::new(HashMap::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<HashMap<String, Vec<i64>>> {
                static LAZY: ::lazy_static::lazy::Lazy<
                    Mutex<HashMap<String, Vec<i64>>>,
                > = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for SAVED_NODE_PATH_LIST {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct SAVED_NODE_CIRCLE_ID {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static SAVED_NODE_CIRCLE_ID: SAVED_NODE_CIRCLE_ID = SAVED_NODE_CIRCLE_ID {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for SAVED_NODE_CIRCLE_ID {
        type Target = Mutex<i32>;
        fn deref(&self) -> &Mutex<i32> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<i32> {
                Mutex::new(0)
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<i32> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<i32>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for SAVED_NODE_CIRCLE_ID {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct DEFAULT_NODES {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static DEFAULT_NODES: DEFAULT_NODES = DEFAULT_NODES {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for DEFAULT_NODES {
        type Target = Mutex<DefaultNodes>;
        fn deref(&self) -> &Mutex<DefaultNodes> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<DefaultNodes> {
                Mutex::new(DefaultNodes {
                    guest_user_node: -1,
                    default_strategy_node: -1,
                })
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<DefaultNodes> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<DefaultNodes>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for DEFAULT_NODES {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct EDGE_AUTH {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static EDGE_AUTH: EDGE_AUTH = EDGE_AUTH { __private_field: () };
    impl ::lazy_static::__Deref for EDGE_AUTH {
        type Target = Mutex<String>;
        fn deref(&self) -> &Mutex<String> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<String> {
                Mutex::new("".to_string())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<String> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<String>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for EDGE_AUTH {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct EDGE_AUTH_MAP {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static EDGE_AUTH_MAP: EDGE_AUTH_MAP = EDGE_AUTH_MAP {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for EDGE_AUTH_MAP {
        type Target = Mutex<HashMap<String, i32>>;
        fn deref(&self) -> &Mutex<HashMap<String, i32>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<HashMap<String, i32>> {
                Mutex::new(HashMap::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<HashMap<String, i32>> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<HashMap<String, i32>>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for EDGE_AUTH_MAP {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct EDGE_SOCKETS {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static EDGE_SOCKETS: EDGE_SOCKETS = EDGE_SOCKETS {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for EDGE_SOCKETS {
        type Target = Mutex<HashMap<String, SocketRef>>;
        fn deref(&self) -> &Mutex<HashMap<String, SocketRef>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<HashMap<String, SocketRef>> {
                Mutex::new(HashMap::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<HashMap<String, SocketRef>> {
                static LAZY: ::lazy_static::lazy::Lazy<
                    Mutex<HashMap<String, SocketRef>>,
                > = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for EDGE_SOCKETS {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct EDGE_VEC {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static EDGE_VEC: EDGE_VEC = EDGE_VEC { __private_field: () };
    impl ::lazy_static::__Deref for EDGE_VEC {
        type Target = Mutex<Vec<String>>;
        fn deref(&self) -> &Mutex<Vec<String>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<Vec<String>> {
                Mutex::new(::alloc::vec::Vec::new())
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<Vec<String>> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<Vec<String>>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for EDGE_VEC {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    pub struct EDGE_NUM {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static EDGE_NUM: EDGE_NUM = EDGE_NUM { __private_field: () };
    impl ::lazy_static::__Deref for EDGE_NUM {
        type Target = Mutex<i32>;
        fn deref(&self) -> &Mutex<i32> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<i32> {
                Mutex::new(0)
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<i32> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<i32>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for EDGE_NUM {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
}
pub mod error {
    use derive_more::Display;
    use enum_const::EnumConst;
    use redis::RedisError;
    pub enum QueryExists {
        #[display("User IDEN already exists")]
        RegisterIDENExist,
        #[display("User Email already exists")]
        RegisterEmailExist,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for QueryExists {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    QueryExists::RegisterIDENExist => "RegisterIDENExist",
                    QueryExists::RegisterEmailExist => "RegisterEmailExist",
                },
            )
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::fmt::Display for QueryExists {
        fn fmt(
            &self,
            __derive_more_f: &mut derive_more::core::fmt::Formatter<'_>,
        ) -> derive_more::core::fmt::Result {
            match self {
                Self::RegisterIDENExist => {
                    __derive_more_f.write_fmt(format_args!("User IDEN already exists"))
                }
                Self::RegisterEmailExist => {
                    __derive_more_f.write_fmt(format_args!("User Email already exists"))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::enum_const::EnumConst for QueryExists {
        fn get_const_isize(&self) -> Option<isize> {
            match self {
                _ => None,
            }
        }
        fn from_const_isize(i: isize) -> Option<Self> {
            match i {
                _ => None,
            }
        }
    }
    pub enum QueryNotFound {
        #[display("Problem IDEN not found")]
        ProblemIdenNotFound,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for QueryNotFound {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ProblemIdenNotFound")
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::fmt::Display for QueryNotFound {
        fn fmt(
            &self,
            __derive_more_f: &mut derive_more::core::fmt::Formatter<'_>,
        ) -> derive_more::core::fmt::Result {
            match self {
                Self::ProblemIdenNotFound => {
                    __derive_more_f.write_fmt(format_args!("Problem IDEN not found"))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::enum_const::EnumConst for QueryNotFound {
        fn get_const_isize(&self) -> Option<isize> {
            match self {
                _ => None,
            }
        }
        fn from_const_isize(i: isize) -> Option<Self> {
            match i {
                _ => None,
            }
        }
    }
    pub enum CoreError {
        #[display("Std Error")]
        StdError,
        #[display("Db Error(seaorm::error::DbErr): {}", _0)]
        DbError(sea_orm::error::DbErr),
        #[display("User not found")]
        UserNotFound,
        #[display("User IDEN already exists")]
        UserIdenExists,
        #[display("_{}", _0)]
        QueryExists(QueryExists),
        #[display("_{}", _0)]
        QueryNotFound(QueryNotFound),
        #[display("NotFound Error: {}", _0)]
        NotFound(String),
        #[display("Serde Error: {}", _0)]
        SerdeError(serde_json::Error),
        #[display("Redis Error: {}", _0)]
        RedisError(redis::RedisError),
        #[display("Error: {}", _0)]
        StringError(String),
        #[display("Invalid Function: {}", _0)]
        InvalidFunction(String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CoreError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                CoreError::StdError => ::core::fmt::Formatter::write_str(f, "StdError"),
                CoreError::DbError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DbError",
                        &__self_0,
                    )
                }
                CoreError::UserNotFound => {
                    ::core::fmt::Formatter::write_str(f, "UserNotFound")
                }
                CoreError::UserIdenExists => {
                    ::core::fmt::Formatter::write_str(f, "UserIdenExists")
                }
                CoreError::QueryExists(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "QueryExists",
                        &__self_0,
                    )
                }
                CoreError::QueryNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "QueryNotFound",
                        &__self_0,
                    )
                }
                CoreError::NotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NotFound",
                        &__self_0,
                    )
                }
                CoreError::SerdeError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SerdeError",
                        &__self_0,
                    )
                }
                CoreError::RedisError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RedisError",
                        &__self_0,
                    )
                }
                CoreError::StringError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StringError",
                        &__self_0,
                    )
                }
                CoreError::InvalidFunction(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "InvalidFunction",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::fmt::Display for CoreError {
        fn fmt(
            &self,
            __derive_more_f: &mut derive_more::core::fmt::Formatter<'_>,
        ) -> derive_more::core::fmt::Result {
            match self {
                Self::StdError => __derive_more_f.write_fmt(format_args!("Std Error")),
                Self::DbError(_0) => {
                    __derive_more_f
                        .write_fmt(
                            format_args!("Db Error(seaorm::error::DbErr): {0}", _0),
                        )
                }
                Self::UserNotFound => {
                    __derive_more_f.write_fmt(format_args!("User not found"))
                }
                Self::UserIdenExists => {
                    __derive_more_f.write_fmt(format_args!("User IDEN already exists"))
                }
                Self::QueryExists(_0) => {
                    __derive_more_f.write_fmt(format_args!("_{0}", _0))
                }
                Self::QueryNotFound(_0) => {
                    __derive_more_f.write_fmt(format_args!("_{0}", _0))
                }
                Self::NotFound(_0) => {
                    __derive_more_f.write_fmt(format_args!("NotFound Error: {0}", _0))
                }
                Self::SerdeError(_0) => {
                    __derive_more_f.write_fmt(format_args!("Serde Error: {0}", _0))
                }
                Self::RedisError(_0) => {
                    __derive_more_f.write_fmt(format_args!("Redis Error: {0}", _0))
                }
                Self::StringError(_0) => {
                    __derive_more_f.write_fmt(format_args!("Error: {0}", _0))
                }
                Self::InvalidFunction(_0) => {
                    __derive_more_f.write_fmt(format_args!("Invalid Function: {0}", _0))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::enum_const::EnumConst for CoreError {
        fn get_const_isize(&self) -> Option<isize> {
            match self {
                _ => None,
            }
        }
        fn from_const_isize(i: isize) -> Option<Self> {
            match i {
                _ => None,
            }
        }
    }
    impl From<&CoreError> for i64 {
        fn from(value: &CoreError) -> Self {
            match value {
                CoreError::StdError => 10000,
                CoreError::DbError(_) => 20000,
                CoreError::RedisError(_) => 21000,
                CoreError::UserNotFound => 60003,
                CoreError::UserIdenExists => 60004,
                CoreError::NotFound(_) => 50000,
                CoreError::QueryExists(data) => {
                    match data {
                        QueryExists::RegisterIDENExist => 60001,
                        QueryExists::RegisterEmailExist => 60002,
                    }
                }
                CoreError::QueryNotFound(data) => {
                    match data {
                        QueryNotFound::ProblemIdenNotFound => 61001,
                    }
                }
                CoreError::SerdeError(_) => 70000,
                CoreError::StringError(_) => 80000,
                CoreError::InvalidFunction(_) => 80001,
            }
        }
    }
    impl From<RedisError> for CoreError {
        fn from(err: RedisError) -> Self {
            CoreError::RedisError(err)
        }
    }
    impl From<serde_json::Error> for CoreError {
        fn from(err: serde_json::Error) -> Self {
            CoreError::SerdeError(err)
        }
    }
    impl From<sea_orm::error::DbErr> for CoreError {
        fn from(err: sea_orm::error::DbErr) -> Self {
            CoreError::DbError(err)
        }
    }
    impl AsRef<str> for CoreError {
        fn as_ref(&self) -> &str {
            "error"
        }
    }
}
#[macro_use]
pub mod macros {}
pub mod db {
    pub mod entity {
        pub mod edge {
            use crate::Result;
            use sea_orm::{
                ActiveModelBehavior, ActiveModelTrait, ColumnTrait, DatabaseConnection,
                EntityTrait, IntoActiveModel, QueryFilter,
            };
            use tap::Conv;
            #[allow(clippy::module_inception)]
            pub mod edge {
                use sea_orm::ActiveValue::{NotSet, Set};
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                use crate::error::CoreError;
                #[sea_orm(table_name = "edge")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub edge_id: i64,
                    pub edge_type: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            edge_type: ::core::clone::Clone::clone(&self.edge_type),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Model",
                            "edge_id",
                            &self.edge_id,
                            "edge_type",
                            &&self.edge_type,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.edge_id == other.edge_id
                            && self.edge_type == other.edge_type
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    EdgeId,
                    /// Generated by sea-orm-macros
                    EdgeType,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::EdgeId => "EdgeId",
                                Column::EdgeType => "EdgeType",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::EdgeId),
                            1usize => ::core::option::Option::Some(Column::EdgeType),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 2usize {
                            0
                        } else {
                            2usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 2usize {
                            self.idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 2usize {
                            self.back_idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 2usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                            Self::EdgeType => "edge_type",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "edge_id" | "edgeId" | "edge_id" => Ok(Column::EdgeId),
                            "edge_type" | "edgeType" | "edge_type" => {
                                Ok(Column::EdgeType)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::EdgeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::EdgeType => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::EdgeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::EdgeType => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "edge"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    EdgeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "EdgeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::EdgeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::EdgeId => Self::Column::EdgeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::EdgeId => Some(Self::EdgeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            edge_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId,
                                        )
                                        .into(),
                                )?,
                            edge_type: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeType,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeType => {
                                self.edge_type.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeType => {
                                self.edge_type = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub edge_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub edge_type: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            edge_type: ::core::clone::Clone::clone(&self.edge_type),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ActiveModel",
                            "edge_id",
                            &self.edge_id,
                            "edge_type",
                            &&self.edge_type,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.edge_id == other.edge_id
                            && self.edge_type == other.edge_type
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::Unchanged(m.edge_id),
                            edge_type: sea_orm::ActiveValue::Unchanged(m.edge_type),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeType => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_type);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeType => {
                                self.edge_type.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeType => {
                                self.edge_type = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeType => {
                                self.edge_type = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeType => {
                                self.edge_type.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::NotSet,
                            edge_type: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.edge_id = (&default.edge_id).default_value();
                        default.edge_type = (&default.edge_type).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeType => {
                                self.edge_type.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.edge_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("edge_id".to_owned()));
                        }
                        if match a.edge_type {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("edge_type".to_owned()),
                            );
                        }
                        Ok(Self {
                            edge_id: a.edge_id.into_value().unwrap().unwrap(),
                            edge_type: a.edge_type.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                pub async fn create_edge(
                    db: &DatabaseConnection,
                    edge_type: &str,
                ) -> Result<Model, CoreError> {
                    let edge = ActiveModel {
                        edge_id: NotSet,
                        edge_type: Set(edge_type.to_string()),
                    };
                    Ok(edge.insert(db).await?)
                }
            }
            pub mod perm_manage {
                use crate::db::entity::edge::{
                    DbEdgeActiveModel, DbEdgeEntityModel, DbEdgeInfo,
                };
                use crate::graph::edge::perm_manage::PermManageEdge;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "edge_perm_manage")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub edge_id: i64,
                    pub u_node_id: i64,
                    pub v_node_id: i64,
                    pub perm: i64,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            perm: ::core::clone::Clone::clone(&self.perm),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "Model",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "perm",
                            &&self.perm,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.perm == other.perm
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    EdgeId,
                    /// Generated by sea-orm-macros
                    UNodeId,
                    /// Generated by sea-orm-macros
                    VNodeId,
                    /// Generated by sea-orm-macros
                    Perm,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::EdgeId => "EdgeId",
                                Column::UNodeId => "UNodeId",
                                Column::VNodeId => "VNodeId",
                                Column::Perm => "Perm",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::EdgeId),
                            1usize => ::core::option::Option::Some(Column::UNodeId),
                            2usize => ::core::option::Option::Some(Column::VNodeId),
                            3usize => ::core::option::Option::Some(Column::Perm),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 4usize {
                            0
                        } else {
                            4usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 4usize {
                            self.idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 4usize {
                            self.back_idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 4usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                            Self::UNodeId => "u_node_id",
                            Self::VNodeId => "v_node_id",
                            Self::Perm => "perm",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "edge_id" | "edgeId" | "edge_id" => Ok(Column::EdgeId),
                            "u_node_id" | "uNodeId" | "u_node_id" => Ok(Column::UNodeId),
                            "v_node_id" | "vNodeId" | "v_node_id" => Ok(Column::VNodeId),
                            "perm" | "perm" | "perm" => Ok(Column::Perm),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::EdgeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::VNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Perm => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::EdgeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::VNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Perm => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "edge_perm_manage"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    EdgeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "EdgeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::EdgeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::EdgeId => Self::Column::EdgeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::EdgeId => Some(Self::EdgeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            edge_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId,
                                        )
                                        .into(),
                                )?,
                            u_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId,
                                        )
                                        .into(),
                                )?,
                            v_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId,
                                        )
                                        .into(),
                                )?,
                            perm: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Perm,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Perm => {
                                self.perm.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Perm => {
                                self.perm = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub edge_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub u_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub v_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub perm: sea_orm::ActiveValue<i64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            perm: ::core::clone::Clone::clone(&self.perm),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "ActiveModel",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "perm",
                            &&self.perm,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.perm == other.perm
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::Unchanged(m.edge_id),
                            u_node_id: sea_orm::ActiveValue::Unchanged(m.u_node_id),
                            v_node_id: sea_orm::ActiveValue::Unchanged(m.v_node_id),
                            perm: sea_orm::ActiveValue::Unchanged(m.perm),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.u_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.v_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.perm);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::NotSet,
                            u_node_id: sea_orm::ActiveValue::NotSet,
                            v_node_id: sea_orm::ActiveValue::NotSet,
                            perm: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.edge_id = (&default.edge_id).default_value();
                        default.u_node_id = (&default.u_node_id).default_value();
                        default.v_node_id = (&default.v_node_id).default_value();
                        default.perm = (&default.perm).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.edge_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("edge_id".to_owned()));
                        }
                        if match a.u_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("u_node_id".to_owned()),
                            );
                        }
                        if match a.v_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("v_node_id".to_owned()),
                            );
                        }
                        if match a.perm {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("perm".to_owned()));
                        }
                        Ok(Self {
                            edge_id: a.edge_id.into_value().unwrap().unwrap(),
                            u_node_id: a.u_node_id.into_value().unwrap().unwrap(),
                            v_node_id: a.v_node_id.into_value().unwrap().unwrap(),
                            perm: a.perm.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbEdgeActiveModel<Model, PermManageEdge> for ActiveModel {}
                impl DbEdgeInfo for ActiveModel {
                    fn get_edge_type(&self) -> &str {
                        "perm_manage"
                    }
                }
                impl DbEdgeEntityModel<Model> for Entity {
                    fn get_u_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::UNodeId
                    }
                    fn get_v_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::VNodeId
                    }
                }
            }
            pub mod perm_view {
                use crate::db::entity::edge::{
                    DbEdgeActiveModel, DbEdgeEntityModel, DbEdgeInfo,
                };
                use crate::graph::edge::perm_view::PermViewEdge;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "edge_perm_view")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub edge_id: i64,
                    pub u_node_id: i64,
                    pub v_node_id: i64,
                    pub perm: i64,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            perm: ::core::clone::Clone::clone(&self.perm),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "Model",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "perm",
                            &&self.perm,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.perm == other.perm
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    EdgeId,
                    /// Generated by sea-orm-macros
                    UNodeId,
                    /// Generated by sea-orm-macros
                    VNodeId,
                    /// Generated by sea-orm-macros
                    Perm,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::EdgeId => "EdgeId",
                                Column::UNodeId => "UNodeId",
                                Column::VNodeId => "VNodeId",
                                Column::Perm => "Perm",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::EdgeId),
                            1usize => ::core::option::Option::Some(Column::UNodeId),
                            2usize => ::core::option::Option::Some(Column::VNodeId),
                            3usize => ::core::option::Option::Some(Column::Perm),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 4usize {
                            0
                        } else {
                            4usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 4usize {
                            self.idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 4usize {
                            self.back_idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 4usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                            Self::UNodeId => "u_node_id",
                            Self::VNodeId => "v_node_id",
                            Self::Perm => "perm",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "edge_id" | "edgeId" | "edge_id" => Ok(Column::EdgeId),
                            "u_node_id" | "uNodeId" | "u_node_id" => Ok(Column::UNodeId),
                            "v_node_id" | "vNodeId" | "v_node_id" => Ok(Column::VNodeId),
                            "perm" | "perm" | "perm" => Ok(Column::Perm),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::EdgeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::VNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Perm => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::EdgeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::VNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Perm => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "edge_perm_view"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    EdgeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "EdgeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::EdgeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::EdgeId => Self::Column::EdgeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::EdgeId => Some(Self::EdgeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            edge_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId,
                                        )
                                        .into(),
                                )?,
                            u_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId,
                                        )
                                        .into(),
                                )?,
                            v_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId,
                                        )
                                        .into(),
                                )?,
                            perm: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Perm,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Perm => {
                                self.perm.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Perm => {
                                self.perm = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub edge_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub u_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub v_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub perm: sea_orm::ActiveValue<i64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            perm: ::core::clone::Clone::clone(&self.perm),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "ActiveModel",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "perm",
                            &&self.perm,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.perm == other.perm
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::Unchanged(m.edge_id),
                            u_node_id: sea_orm::ActiveValue::Unchanged(m.u_node_id),
                            v_node_id: sea_orm::ActiveValue::Unchanged(m.v_node_id),
                            perm: sea_orm::ActiveValue::Unchanged(m.perm),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.u_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.v_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.perm);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::NotSet,
                            u_node_id: sea_orm::ActiveValue::NotSet,
                            v_node_id: sea_orm::ActiveValue::NotSet,
                            perm: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.edge_id = (&default.edge_id).default_value();
                        default.u_node_id = (&default.u_node_id).default_value();
                        default.v_node_id = (&default.v_node_id).default_value();
                        default.perm = (&default.perm).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Perm => {
                                self.perm.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.edge_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("edge_id".to_owned()));
                        }
                        if match a.u_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("u_node_id".to_owned()),
                            );
                        }
                        if match a.v_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("v_node_id".to_owned()),
                            );
                        }
                        if match a.perm {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("perm".to_owned()));
                        }
                        Ok(Self {
                            edge_id: a.edge_id.into_value().unwrap().unwrap(),
                            u_node_id: a.u_node_id.into_value().unwrap().unwrap(),
                            v_node_id: a.v_node_id.into_value().unwrap().unwrap(),
                            perm: a.perm.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbEdgeActiveModel<Model, PermViewEdge> for ActiveModel {}
                impl DbEdgeInfo for ActiveModel {
                    fn get_edge_type(&self) -> &str {
                        "perm_view"
                    }
                }
                impl DbEdgeEntityModel<Model> for Entity {
                    fn get_u_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::UNodeId
                    }
                    fn get_v_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::VNodeId
                    }
                }
            }
            pub mod iden {
                use crate::db::entity::edge::{
                    DbEdgeActiveModel, DbEdgeEntityModel, DbEdgeInfo,
                };
                use crate::graph::edge::iden::IdenEdge;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "edge_iden")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub edge_id: i64,
                    pub u_node_id: i64,
                    pub v_node_id: i64,
                    pub iden: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "Model",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.iden == other.iden
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    EdgeId,
                    /// Generated by sea-orm-macros
                    UNodeId,
                    /// Generated by sea-orm-macros
                    VNodeId,
                    /// Generated by sea-orm-macros
                    Iden,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::EdgeId => "EdgeId",
                                Column::UNodeId => "UNodeId",
                                Column::VNodeId => "VNodeId",
                                Column::Iden => "Iden",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::EdgeId),
                            1usize => ::core::option::Option::Some(Column::UNodeId),
                            2usize => ::core::option::Option::Some(Column::VNodeId),
                            3usize => ::core::option::Option::Some(Column::Iden),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 4usize {
                            0
                        } else {
                            4usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 4usize {
                            self.idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 4usize {
                            self.back_idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 4usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                            Self::UNodeId => "u_node_id",
                            Self::VNodeId => "v_node_id",
                            Self::Iden => "iden",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "edge_id" | "edgeId" | "edge_id" => Ok(Column::EdgeId),
                            "u_node_id" | "uNodeId" | "u_node_id" => Ok(Column::UNodeId),
                            "v_node_id" | "vNodeId" | "v_node_id" => Ok(Column::VNodeId),
                            "iden" | "iden" | "iden" => Ok(Column::Iden),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::EdgeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::VNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Iden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::EdgeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::VNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Iden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "edge_iden"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    EdgeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "EdgeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::EdgeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::EdgeId => Self::Column::EdgeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::EdgeId => Some(Self::EdgeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            edge_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId,
                                        )
                                        .into(),
                                )?,
                            u_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId,
                                        )
                                        .into(),
                                )?,
                            v_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId,
                                        )
                                        .into(),
                                )?,
                            iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Iden,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub edge_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub u_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub v_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub iden: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "ActiveModel",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.iden == other.iden
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::Unchanged(m.edge_id),
                            u_node_id: sea_orm::ActiveValue::Unchanged(m.u_node_id),
                            v_node_id: sea_orm::ActiveValue::Unchanged(m.v_node_id),
                            iden: sea_orm::ActiveValue::Unchanged(m.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.u_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.v_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.iden);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::NotSet,
                            u_node_id: sea_orm::ActiveValue::NotSet,
                            v_node_id: sea_orm::ActiveValue::NotSet,
                            iden: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.edge_id = (&default.edge_id).default_value();
                        default.u_node_id = (&default.u_node_id).default_value();
                        default.v_node_id = (&default.v_node_id).default_value();
                        default.iden = (&default.iden).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.edge_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("edge_id".to_owned()));
                        }
                        if match a.u_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("u_node_id".to_owned()),
                            );
                        }
                        if match a.v_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("v_node_id".to_owned()),
                            );
                        }
                        if match a.iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("iden".to_owned()));
                        }
                        Ok(Self {
                            edge_id: a.edge_id.into_value().unwrap().unwrap(),
                            u_node_id: a.u_node_id.into_value().unwrap().unwrap(),
                            v_node_id: a.v_node_id.into_value().unwrap().unwrap(),
                            iden: a.iden.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbEdgeActiveModel<Model, IdenEdge> for ActiveModel {}
                impl DbEdgeInfo for ActiveModel {
                    fn get_edge_type(&self) -> &str {
                        "iden"
                    }
                }
                impl From<Model> for IdenEdge {
                    fn from(model: Model) -> Self {
                        IdenEdge {
                            id: model.edge_id,
                            u: model.u_node_id,
                            v: model.v_node_id,
                            iden: model.iden,
                        }
                    }
                }
                impl DbEdgeEntityModel<Model> for Entity {
                    fn get_u_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::UNodeId
                    }
                    fn get_v_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::VNodeId
                    }
                }
            }
            pub mod problem_limit {
                use crate::db::entity::edge::{
                    DbEdgeActiveModel, DbEdgeEntityModel, DbEdgeInfo,
                };
                use crate::graph::edge::problem_limit::ProblemLimitEdge;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "edge_problem_limit")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub edge_id: i64,
                    pub u_node_id: i64,
                    pub v_node_id: i64,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Model",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &&self.v_node_id,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    EdgeId,
                    /// Generated by sea-orm-macros
                    UNodeId,
                    /// Generated by sea-orm-macros
                    VNodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::EdgeId => "EdgeId",
                                Column::UNodeId => "UNodeId",
                                Column::VNodeId => "VNodeId",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::EdgeId),
                            1usize => ::core::option::Option::Some(Column::UNodeId),
                            2usize => ::core::option::Option::Some(Column::VNodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 3usize {
                            0
                        } else {
                            3usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 3usize {
                            self.idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 3usize {
                            self.back_idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 3usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                            Self::UNodeId => "u_node_id",
                            Self::VNodeId => "v_node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "edge_id" | "edgeId" | "edge_id" => Ok(Column::EdgeId),
                            "u_node_id" | "uNodeId" | "u_node_id" => Ok(Column::UNodeId),
                            "v_node_id" | "vNodeId" | "v_node_id" => Ok(Column::VNodeId),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::EdgeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::VNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::EdgeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::VNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "edge_problem_limit"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    EdgeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "EdgeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::EdgeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::EdgeId => Self::Column::EdgeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::EdgeId => Some(Self::EdgeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            edge_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId,
                                        )
                                        .into(),
                                )?,
                            u_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId,
                                        )
                                        .into(),
                                )?,
                            v_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub edge_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub u_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub v_node_id: sea_orm::ActiveValue<i64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ActiveModel",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &&self.v_node_id,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::Unchanged(m.edge_id),
                            u_node_id: sea_orm::ActiveValue::Unchanged(m.u_node_id),
                            v_node_id: sea_orm::ActiveValue::Unchanged(m.v_node_id),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.u_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.v_node_id);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::NotSet,
                            u_node_id: sea_orm::ActiveValue::NotSet,
                            v_node_id: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.edge_id = (&default.edge_id).default_value();
                        default.u_node_id = (&default.u_node_id).default_value();
                        default.v_node_id = (&default.v_node_id).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.edge_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("edge_id".to_owned()));
                        }
                        if match a.u_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("u_node_id".to_owned()),
                            );
                        }
                        if match a.v_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("v_node_id".to_owned()),
                            );
                        }
                        Ok(Self {
                            edge_id: a.edge_id.into_value().unwrap().unwrap(),
                            u_node_id: a.u_node_id.into_value().unwrap().unwrap(),
                            v_node_id: a.v_node_id.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbEdgeActiveModel<Model, ProblemLimitEdge> for ActiveModel {}
                impl DbEdgeInfo for ActiveModel {
                    fn get_edge_type(&self) -> &str {
                        "problem_limit"
                    }
                }
                impl DbEdgeEntityModel<Model> for Entity {
                    fn get_u_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::UNodeId
                    }
                    fn get_v_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::VNodeId
                    }
                }
            }
            pub mod problem_statement {
                use crate::db::entity::edge::{
                    DbEdgeActiveModel, DbEdgeEntityModel, DbEdgeInfo,
                };
                use crate::graph::edge::problem_statement::ProblemStatementEdge;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "edge_problem_statement")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub edge_id: i64,
                    pub u_node_id: i64,
                    pub v_node_id: i64,
                    pub copyright_risk: i64,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            copyright_risk: ::core::clone::Clone::clone(
                                &self.copyright_risk,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "Model",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "copyright_risk",
                            &&self.copyright_risk,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.copyright_risk == other.copyright_risk
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    EdgeId,
                    /// Generated by sea-orm-macros
                    UNodeId,
                    /// Generated by sea-orm-macros
                    VNodeId,
                    /// Generated by sea-orm-macros
                    CopyrightRisk,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::EdgeId => "EdgeId",
                                Column::UNodeId => "UNodeId",
                                Column::VNodeId => "VNodeId",
                                Column::CopyrightRisk => "CopyrightRisk",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::EdgeId),
                            1usize => ::core::option::Option::Some(Column::UNodeId),
                            2usize => ::core::option::Option::Some(Column::VNodeId),
                            3usize => ::core::option::Option::Some(Column::CopyrightRisk),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 4usize {
                            0
                        } else {
                            4usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 4usize {
                            self.idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 4usize {
                            self.back_idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 4usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                            Self::UNodeId => "u_node_id",
                            Self::VNodeId => "v_node_id",
                            Self::CopyrightRisk => "copyright_risk",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "edge_id" | "edgeId" | "edge_id" => Ok(Column::EdgeId),
                            "u_node_id" | "uNodeId" | "u_node_id" => Ok(Column::UNodeId),
                            "v_node_id" | "vNodeId" | "v_node_id" => Ok(Column::VNodeId),
                            "copyright_risk" | "copyrightRisk" | "copyright_risk" => {
                                Ok(Column::CopyrightRisk)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::EdgeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::VNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::CopyrightRisk => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::EdgeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::VNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::CopyrightRisk => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "edge_problem_statement"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    EdgeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "EdgeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::EdgeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::EdgeId => Self::Column::EdgeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::EdgeId => Some(Self::EdgeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            edge_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId,
                                        )
                                        .into(),
                                )?,
                            u_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId,
                                        )
                                        .into(),
                                )?,
                            v_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId,
                                        )
                                        .into(),
                                )?,
                            copyright_risk: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CopyrightRisk,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CopyrightRisk => {
                                self.copyright_risk.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CopyrightRisk => {
                                self.copyright_risk = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub edge_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub u_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub v_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub copyright_risk: sea_orm::ActiveValue<i64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                            copyright_risk: ::core::clone::Clone::clone(
                                &self.copyright_risk,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "ActiveModel",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &self.v_node_id,
                            "copyright_risk",
                            &&self.copyright_risk,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                            && self.copyright_risk == other.copyright_risk
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::Unchanged(m.edge_id),
                            u_node_id: sea_orm::ActiveValue::Unchanged(m.u_node_id),
                            v_node_id: sea_orm::ActiveValue::Unchanged(m.v_node_id),
                            copyright_risk: sea_orm::ActiveValue::Unchanged(
                                m.copyright_risk,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.u_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.v_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CopyrightRisk => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.copyright_risk);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CopyrightRisk => {
                                self.copyright_risk.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CopyrightRisk => {
                                self.copyright_risk = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CopyrightRisk => {
                                self.copyright_risk = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CopyrightRisk => {
                                self.copyright_risk.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::NotSet,
                            u_node_id: sea_orm::ActiveValue::NotSet,
                            v_node_id: sea_orm::ActiveValue::NotSet,
                            copyright_risk: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.edge_id = (&default.edge_id).default_value();
                        default.u_node_id = (&default.u_node_id).default_value();
                        default.v_node_id = (&default.v_node_id).default_value();
                        default.copyright_risk = (&default.copyright_risk)
                            .default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CopyrightRisk => {
                                self.copyright_risk.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.edge_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("edge_id".to_owned()));
                        }
                        if match a.u_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("u_node_id".to_owned()),
                            );
                        }
                        if match a.v_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("v_node_id".to_owned()),
                            );
                        }
                        if match a.copyright_risk {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("copyright_risk".to_owned()),
                            );
                        }
                        Ok(Self {
                            edge_id: a.edge_id.into_value().unwrap().unwrap(),
                            u_node_id: a.u_node_id.into_value().unwrap().unwrap(),
                            v_node_id: a.v_node_id.into_value().unwrap().unwrap(),
                            copyright_risk: a
                                .copyright_risk
                                .into_value()
                                .unwrap()
                                .unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbEdgeActiveModel<Model, ProblemStatementEdge> for ActiveModel {}
                impl DbEdgeInfo for ActiveModel {
                    fn get_edge_type(&self) -> &str {
                        "problem_statement"
                    }
                }
                impl DbEdgeEntityModel<Model> for Entity {
                    fn get_u_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::UNodeId
                    }
                    fn get_v_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::VNodeId
                    }
                }
            }
            pub mod problem_tag {
                use crate::db::entity::edge::{
                    DbEdgeActiveModel, DbEdgeEntityModel, DbEdgeInfo,
                };
                use crate::graph::edge::problem_tag::ProblemTagEdge;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "edge_problem_tag")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub edge_id: i64,
                    pub u_node_id: i64,
                    pub v_node_id: i64,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Model",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &&self.v_node_id,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    EdgeId,
                    /// Generated by sea-orm-macros
                    UNodeId,
                    /// Generated by sea-orm-macros
                    VNodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::EdgeId => "EdgeId",
                                Column::UNodeId => "UNodeId",
                                Column::VNodeId => "VNodeId",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::EdgeId),
                            1usize => ::core::option::Option::Some(Column::UNodeId),
                            2usize => ::core::option::Option::Some(Column::VNodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 3usize {
                            0
                        } else {
                            3usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 3usize {
                            self.idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 3usize {
                            self.back_idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 3usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                            Self::UNodeId => "u_node_id",
                            Self::VNodeId => "v_node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "edge_id" | "edgeId" | "edge_id" => Ok(Column::EdgeId),
                            "u_node_id" | "uNodeId" | "u_node_id" => Ok(Column::UNodeId),
                            "v_node_id" | "vNodeId" | "v_node_id" => Ok(Column::VNodeId),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::EdgeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::VNodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::EdgeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::VNodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "edge_problem_tag"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    EdgeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "EdgeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::EdgeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::EdgeId => "edge_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::EdgeId => Self::Column::EdgeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::EdgeId => Some(Self::EdgeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            edge_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId,
                                        )
                                        .into(),
                                )?,
                            u_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId,
                                        )
                                        .into(),
                                )?,
                            v_node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EdgeId => {
                                self.edge_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub edge_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub u_node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub v_node_id: sea_orm::ActiveValue<i64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            edge_id: ::core::clone::Clone::clone(&self.edge_id),
                            u_node_id: ::core::clone::Clone::clone(&self.u_node_id),
                            v_node_id: ::core::clone::Clone::clone(&self.v_node_id),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ActiveModel",
                            "edge_id",
                            &self.edge_id,
                            "u_node_id",
                            &self.u_node_id,
                            "v_node_id",
                            &&self.v_node_id,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.edge_id == other.edge_id
                            && self.u_node_id == other.u_node_id
                            && self.v_node_id == other.v_node_id
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::Unchanged(m.edge_id),
                            u_node_id: sea_orm::ActiveValue::Unchanged(m.u_node_id),
                            v_node_id: sea_orm::ActiveValue::Unchanged(m.v_node_id),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.edge_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.u_node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.v_node_id);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            edge_id: sea_orm::ActiveValue::NotSet,
                            u_node_id: sea_orm::ActiveValue::NotSet,
                            v_node_id: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.edge_id = (&default.edge_id).default_value();
                        default.u_node_id = (&default.u_node_id).default_value();
                        default.v_node_id = (&default.v_node_id).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::EdgeId => {
                                self.edge_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UNodeId => {
                                self.u_node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::VNodeId => {
                                self.v_node_id.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.edge_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("edge_id".to_owned()));
                        }
                        if match a.u_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("u_node_id".to_owned()),
                            );
                        }
                        if match a.v_node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("v_node_id".to_owned()),
                            );
                        }
                        Ok(Self {
                            edge_id: a.edge_id.into_value().unwrap().unwrap(),
                            u_node_id: a.u_node_id.into_value().unwrap().unwrap(),
                            v_node_id: a.v_node_id.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbEdgeActiveModel<Model, ProblemTagEdge> for ActiveModel {}
                impl DbEdgeInfo for ActiveModel {
                    fn get_edge_type(&self) -> &str {
                        "problem_tag"
                    }
                }
                impl From<Model> for ProblemTagEdge {
                    fn from(model: Model) -> Self {
                        ProblemTagEdge {
                            id: model.edge_id,
                            u: model.u_node_id,
                            v: model.v_node_id,
                        }
                    }
                }
                impl DbEdgeEntityModel<Model> for Entity {
                    fn get_u_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::UNodeId
                    }
                    fn get_v_edge_id_column(&self) -> <Self as EntityTrait>::Column {
                        Column::VNodeId
                    }
                }
            }
            pub trait DbEdgeInfo {
                fn get_edge_type(&self) -> &str;
            }
            pub trait DbEdgeActiveModel<MODEL, EDGE>
            where
                MODEL: Into<EDGE>
                    + From<
                        <<Self as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                    >,
                Self: Sized + Send + Sync + ActiveModelTrait + ActiveModelBehavior,
            {
                fn save_into_db(
                    &self,
                    db: &DatabaseConnection,
                ) -> impl std::future::Future<Output = Result<MODEL>> + Send
                where
                    <Self::Entity as EntityTrait>::Model: IntoActiveModel<Self>,
                {
                    async { Ok(self.clone().insert(db).await?.conv::<MODEL>()) }
                }
            }
            pub trait DbEdgeEntityModel<Model>
            where
                Self: Sized + EntityTrait,
                Model: From<<Self as EntityTrait>::Model>,
            {
                fn get_u_edge_id_column(&self) -> <Self as EntityTrait>::Column;
                fn get_v_edge_id_column(&self) -> <Self as EntityTrait>::Column;
                fn query_u_perm_view_edges(
                    &self,
                    db: &DatabaseConnection,
                    u_node_id: i64,
                ) -> impl std::future::Future<Output = Result<Vec<Model>>> + Send {
                    async move {
                        let id_column = self.get_u_edge_id_column();
                        let edges = Self::find()
                            .filter(id_column.eq(u_node_id))
                            .all(db)
                            .await?;
                        Ok(edges.into_iter().map(|e| e.into()).collect())
                    }
                }
                fn query_v_perm_view_edges(
                    &self,
                    db: &DatabaseConnection,
                    v_node_id: i64,
                ) -> impl std::future::Future<Output = Result<Vec<Model>>> {
                    async move {
                        let id_column = self.get_v_edge_id_column();
                        let edges = Self::find()
                            .filter(id_column.eq(v_node_id))
                            .all(db)
                            .await?;
                        Ok(edges.into_iter().map(|e| e.into()).collect())
                    }
                }
            }
        }
        pub mod node {
            use sea_orm::{
                ActiveModelBehavior, ActiveModelTrait, DatabaseConnection, EntityTrait,
                IntoActiveModel,
            };
            use tap::Conv;
            pub mod iden {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::iden::IdenNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{
                    DeriveEntityModel, DeriveRelation, EnumIter, FromJsonQueryResult,
                };
                use serde::{Deserialize, Serialize};
                #[sea_orm(table_name = "node_iden")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub iden: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Model",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Iden,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Iden => "Iden",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Iden),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 2usize {
                            0
                        } else {
                            2usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 2usize {
                            self.idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 2usize {
                            self.back_idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 2usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Iden => "iden",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "iden" | "iden" | "iden" => Ok(Column::Iden),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Iden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Iden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_iden"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Iden,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub iden: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ActiveModel",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            iden: sea_orm::ActiveValue::Unchanged(m.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.iden);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            iden: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.iden = (&default.iden).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("iden".to_owned()));
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            iden: a.iden.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for Model {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "iden" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"iden" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<Model>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = Model;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct Model",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct Model with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct Model with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(Model {
                                        node_id: __field0,
                                        iden: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("iden")?
                                        }
                                    };
                                    _serde::__private::Ok(Model {
                                        node_id: __field0,
                                        iden: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &["node_id", "iden"];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "Model",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<Model>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for Model {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "Model",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "iden",
                                &self.iden,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl sea_orm::TryGetableFromJson for Model {}
                #[automatically_derived]
                impl std::convert::From<Model> for sea_orm::Value {
                    fn from(source: Model) -> Self {
                        sea_orm::Value::Json(
                            serde_json::to_value(&source)
                                .ok()
                                .map(|s| std::boxed::Box::new(s)),
                        )
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::ValueType for Model {
                    fn try_from(
                        v: sea_orm::Value,
                    ) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {
                        match v {
                            sea_orm::Value::Json(Some(json)) => {
                                Ok(
                                    serde_json::from_value(*json)
                                        .map_err(|_| sea_orm::sea_query::ValueTypeErr)?,
                                )
                            }
                            _ => Err(sea_orm::sea_query::ValueTypeErr),
                        }
                    }
                    fn type_name() -> String {
                        "Model".to_owned()
                    }
                    fn array_type() -> sea_orm::sea_query::ArrayType {
                        sea_orm::sea_query::ArrayType::Json
                    }
                    fn column_type() -> sea_orm::sea_query::ColumnType {
                        sea_orm::sea_query::ColumnType::Json
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::Nullable for Model {
                    fn null() -> sea_orm::Value {
                        sea_orm::Value::Json(None)
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::value::with_array::NotU8 for Model {}
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "iden"
                    }
                }
                impl DbNodeActiveModel<Model, IdenNode> for ActiveModel {}
            }
            #[allow(clippy::module_inception)]
            pub mod node {
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                use crate::error::CoreError;
                #[sea_orm(table_name = "node")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub node_type: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            node_type: ::core::clone::Clone::clone(&self.node_type),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Model",
                            "node_id",
                            &self.node_id,
                            "node_type",
                            &&self.node_type,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id
                            && self.node_type == other.node_type
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for Model {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<i64>;
                        let _: ::core::cmp::AssertParamIsEq<String>;
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    NodeType,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::NodeType => "NodeType",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::NodeType),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 2usize {
                            0
                        } else {
                            2usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 2usize {
                            self.idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 2usize {
                            self.back_idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 2usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::NodeType => "node_type",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "node_type" | "nodeType" | "node_type" => {
                                Ok(Column::NodeType)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::NodeType => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::NodeType => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            node_type: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeType,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeType => {
                                self.node_type.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeType => {
                                self.node_type = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub node_type: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            node_type: ::core::clone::Clone::clone(&self.node_type),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ActiveModel",
                            "node_id",
                            &self.node_id,
                            "node_type",
                            &&self.node_type,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id
                            && self.node_type == other.node_type
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            node_type: sea_orm::ActiveValue::Unchanged(m.node_type),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeType => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_type);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeType => {
                                self.node_type.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeType => {
                                self.node_type = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeType => {
                                self.node_type = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeType => {
                                self.node_type.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            node_type: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.node_type = (&default.node_type).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeType => {
                                self.node_type.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.node_type {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("node_type".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            node_type: a.node_type.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                pub async fn create_node(
                    db: &DatabaseConnection,
                    node_type: &str,
                ) -> Result<Model, CoreError> {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    let new_node = ActiveModel {
                        node_id: NotSet,
                        node_type: Set(node_type.to_string()),
                    };
                    Ok(new_node.insert(db).await?)
                }
            }
            pub mod pages {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::pages::{
                    PagesNode, PagesNodePrivate, PagesNodePublic,
                };
                use sea_orm::entity::prelude::*;
                use sea_orm::{
                    DeriveEntityModel, DeriveRelation, EnumIter, FromJsonQueryResult,
                };
                use serde::{Deserialize, Serialize};
                pub struct ContentType {
                    pub iden: String,
                    pub content: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ContentType {
                    #[inline]
                    fn clone(&self) -> ContentType {
                        ContentType {
                            iden: ::core::clone::Clone::clone(&self.iden),
                            content: ::core::clone::Clone::clone(&self.content),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ContentType {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ContentType",
                            "iden",
                            &self.iden,
                            "content",
                            &&self.content,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ContentType {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ContentType {
                    #[inline]
                    fn eq(&self, other: &ContentType) -> bool {
                        self.iden == other.iden && self.content == other.content
                    }
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ContentType {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ContentType",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "iden",
                                &self.iden,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "content",
                                &self.content,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ContentType {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "iden" => _serde::__private::Ok(__Field::__field0),
                                        "content" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"iden" => _serde::__private::Ok(__Field::__field0),
                                        b"content" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<ContentType>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ContentType;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ContentType",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ContentType with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ContentType with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ContentType {
                                        iden: __field0,
                                        content: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "content",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("iden")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("content")?
                                        }
                                    };
                                    _serde::__private::Ok(ContentType {
                                        iden: __field0,
                                        content: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &["iden", "content"];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ContentType",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<ContentType>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[automatically_derived]
                impl sea_orm::TryGetableFromJson for ContentType {}
                #[automatically_derived]
                impl std::convert::From<ContentType> for sea_orm::Value {
                    fn from(source: ContentType) -> Self {
                        sea_orm::Value::Json(
                            serde_json::to_value(&source)
                                .ok()
                                .map(|s| std::boxed::Box::new(s)),
                        )
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::ValueType for ContentType {
                    fn try_from(
                        v: sea_orm::Value,
                    ) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {
                        match v {
                            sea_orm::Value::Json(Some(json)) => {
                                Ok(
                                    serde_json::from_value(*json)
                                        .map_err(|_| sea_orm::sea_query::ValueTypeErr)?,
                                )
                            }
                            _ => Err(sea_orm::sea_query::ValueTypeErr),
                        }
                    }
                    fn type_name() -> String {
                        "ContentType".to_owned()
                    }
                    fn array_type() -> sea_orm::sea_query::ArrayType {
                        sea_orm::sea_query::ArrayType::Json
                    }
                    fn column_type() -> sea_orm::sea_query::ColumnType {
                        sea_orm::sea_query::ColumnType::Json
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::Nullable for ContentType {
                    fn null() -> sea_orm::Value {
                        sea_orm::Value::Json(None)
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::value::with_array::NotU8 for ContentType {}
                #[sea_orm(table_name = "node_pages")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub iden: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Model",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Iden,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Iden => "Iden",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Iden),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 2usize {
                            0
                        } else {
                            2usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 2usize {
                            self.idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 2usize {
                            self.back_idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 2usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Iden => "iden",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "iden" | "iden" | "iden" => Ok(Column::Iden),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Iden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Iden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_pages"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Iden,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub iden: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ActiveModel",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            iden: sea_orm::ActiveValue::Unchanged(m.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.iden);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            iden: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.iden = (&default.iden).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("iden".to_owned()));
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            iden: a.iden.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "pages"
                    }
                }
                impl DbNodeActiveModel<Model, PagesNode> for ActiveModel {}
                impl From<Model> for PagesNode {
                    fn from(model: Model) -> Self {
                        PagesNode {
                            node_id: model.node_id,
                            public: PagesNodePublic {},
                            private: PagesNodePrivate {
                                name: model.iden.clone(),
                            },
                        }
                    }
                }
            }
            pub mod perm_group {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::error::CoreError;
                use crate::graph::node::perm_group::{
                    PermGroupNode, PermGroupNodePrivate, PermGroupNodePublic,
                };
                use sea_orm::entity::prelude::*;
                use sea_orm::{
                    DeriveEntityModel, DeriveRelation, EnumIter, FromJsonQueryResult,
                };
                use serde::{Deserialize, Serialize};
                pub struct ContentType {
                    pub iden: String,
                    pub content: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ContentType {
                    #[inline]
                    fn clone(&self) -> ContentType {
                        ContentType {
                            iden: ::core::clone::Clone::clone(&self.iden),
                            content: ::core::clone::Clone::clone(&self.content),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ContentType {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ContentType",
                            "iden",
                            &self.iden,
                            "content",
                            &&self.content,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ContentType {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ContentType {
                    #[inline]
                    fn eq(&self, other: &ContentType) -> bool {
                        self.iden == other.iden && self.content == other.content
                    }
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ContentType {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ContentType",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "iden",
                                &self.iden,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "content",
                                &self.content,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ContentType {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "iden" => _serde::__private::Ok(__Field::__field0),
                                        "content" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"iden" => _serde::__private::Ok(__Field::__field0),
                                        b"content" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<ContentType>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ContentType;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ContentType",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ContentType with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ContentType with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ContentType {
                                        iden: __field0,
                                        content: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "content",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("iden")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("content")?
                                        }
                                    };
                                    _serde::__private::Ok(ContentType {
                                        iden: __field0,
                                        content: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &["iden", "content"];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ContentType",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<ContentType>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[automatically_derived]
                impl sea_orm::TryGetableFromJson for ContentType {}
                #[automatically_derived]
                impl std::convert::From<ContentType> for sea_orm::Value {
                    fn from(source: ContentType) -> Self {
                        sea_orm::Value::Json(
                            serde_json::to_value(&source)
                                .ok()
                                .map(|s| std::boxed::Box::new(s)),
                        )
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::ValueType for ContentType {
                    fn try_from(
                        v: sea_orm::Value,
                    ) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {
                        match v {
                            sea_orm::Value::Json(Some(json)) => {
                                Ok(
                                    serde_json::from_value(*json)
                                        .map_err(|_| sea_orm::sea_query::ValueTypeErr)?,
                                )
                            }
                            _ => Err(sea_orm::sea_query::ValueTypeErr),
                        }
                    }
                    fn type_name() -> String {
                        "ContentType".to_owned()
                    }
                    fn array_type() -> sea_orm::sea_query::ArrayType {
                        sea_orm::sea_query::ArrayType::Json
                    }
                    fn column_type() -> sea_orm::sea_query::ColumnType {
                        sea_orm::sea_query::ColumnType::Json
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::Nullable for ContentType {
                    fn null() -> sea_orm::Value {
                        sea_orm::Value::Json(None)
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::value::with_array::NotU8 for ContentType {}
                #[sea_orm(table_name = "node_perm_group")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub iden: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Model",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Iden,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Iden => "Iden",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Iden),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 2usize {
                            0
                        } else {
                            2usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 2usize {
                            self.idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 2usize {
                            self.back_idx = 2usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 2usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Iden => "iden",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "iden" | "iden" | "iden" => Ok(Column::Iden),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Iden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Iden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_perm_group"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Iden,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub iden: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ActiveModel",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &&self.iden,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            iden: sea_orm::ActiveValue::Unchanged(m.iden),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.iden);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            iden: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.iden = (&default.iden).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("iden".to_owned()));
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            iden: a.iden.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "perm_group"
                    }
                }
                impl DbNodeActiveModel<Model, PermGroupNode> for ActiveModel {}
                impl From<Model> for PermGroupNode {
                    fn from(model: Model) -> Self {
                        PermGroupNode {
                            node_id: model.node_id,
                            public: PermGroupNodePublic {},
                            private: PermGroupNodePrivate {
                                name: model.iden.clone(),
                            },
                        }
                    }
                }
                pub async fn get_default_strategy_node(
                    db: &DatabaseConnection,
                ) -> Result<i64, CoreError> {
                    use sea_orm::EntityTrait;
                    let node = Entity::find()
                        .filter(Column::Iden.eq("default"))
                        .one(db)
                        .await?
                        .ok_or(
                            CoreError::NotFound(
                                "Default strategy node not found".to_string(),
                            ),
                        )?;
                    Ok(node.node_id)
                }
            }
            pub mod problem {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::problem::ProblemNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{
                    DeriveEntityModel, DeriveRelation, EnumIter, FromJsonQueryResult,
                };
                use serde::{Deserialize, Serialize};
                #[sea_orm(table_name = "node_problem")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub name: String,
                    pub content_public: String,
                    pub content_private: String,
                    pub creation_time: DateTime,
                    pub creation_order: i64,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            name: ::core::clone::Clone::clone(&self.name),
                            content_public: ::core::clone::Clone::clone(
                                &self.content_public,
                            ),
                            content_private: ::core::clone::Clone::clone(
                                &self.content_private,
                            ),
                            creation_time: ::core::clone::Clone::clone(
                                &self.creation_time,
                            ),
                            creation_order: ::core::clone::Clone::clone(
                                &self.creation_order,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "name",
                            "content_public",
                            "content_private",
                            "creation_time",
                            "creation_order",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.name,
                            &self.content_public,
                            &self.content_private,
                            &self.creation_time,
                            &&self.creation_order,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id
                            && self.creation_order == other.creation_order
                            && self.name == other.name
                            && self.content_public == other.content_public
                            && self.content_private == other.content_private
                            && self.creation_time == other.creation_time
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Name,
                    /// Generated by sea-orm-macros
                    ContentPublic,
                    /// Generated by sea-orm-macros
                    ContentPrivate,
                    /// Generated by sea-orm-macros
                    CreationTime,
                    /// Generated by sea-orm-macros
                    CreationOrder,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Name => "Name",
                                Column::ContentPublic => "ContentPublic",
                                Column::ContentPrivate => "ContentPrivate",
                                Column::CreationTime => "CreationTime",
                                Column::CreationOrder => "CreationOrder",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Name),
                            2usize => ::core::option::Option::Some(Column::ContentPublic),
                            3usize => {
                                ::core::option::Option::Some(Column::ContentPrivate)
                            }
                            4usize => ::core::option::Option::Some(Column::CreationTime),
                            5usize => ::core::option::Option::Some(Column::CreationOrder),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 6usize {
                            0
                        } else {
                            6usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 6usize {
                            self.idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 6usize {
                            self.back_idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 6usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Name => "name",
                            Self::ContentPublic => "content_public",
                            Self::ContentPrivate => "content_private",
                            Self::CreationTime => "creation_time",
                            Self::CreationOrder => "creation_order",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "name" | "name" | "name" => Ok(Column::Name),
                            "content_public" | "contentPublic" | "content_public" => {
                                Ok(Column::ContentPublic)
                            }
                            "content_private" | "contentPrivate" | "content_private" => {
                                Ok(Column::ContentPrivate)
                            }
                            "creation_time" | "creationTime" | "creation_time" => {
                                Ok(Column::CreationTime)
                            }
                            "creation_order" | "creationOrder" | "creation_order" => {
                                Ok(Column::CreationOrder)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Name => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::ContentPublic => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::ContentPrivate => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::CreationTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::CreationOrder => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Name => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::ContentPublic => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::ContentPrivate => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::CreationTime => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::CreationOrder => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_problem"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            name: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Name,
                                        )
                                        .into(),
                                )?,
                            content_public: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::ContentPublic,
                                        )
                                        .into(),
                                )?,
                            content_private: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::ContentPrivate,
                                        )
                                        .into(),
                                )?,
                            creation_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CreationTime,
                                        )
                                        .into(),
                                )?,
                            creation_order: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CreationOrder,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                                self.name.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::ContentPublic => {
                                self.content_public.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::ContentPrivate => {
                                self.content_private.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreationTime => {
                                self.creation_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreationOrder => {
                                self.creation_order.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                                self.name = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::ContentPublic => {
                                self.content_public = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::ContentPrivate => {
                                self.content_private = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreationTime => {
                                self.creation_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreationOrder => {
                                self.creation_order = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub name: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub content_public: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub content_private: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub creation_time: sea_orm::ActiveValue<DateTime>,
                    /// Generated by sea-orm-macros
                    pub creation_order: sea_orm::ActiveValue<i64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            name: ::core::clone::Clone::clone(&self.name),
                            content_public: ::core::clone::Clone::clone(
                                &self.content_public,
                            ),
                            content_private: ::core::clone::Clone::clone(
                                &self.content_private,
                            ),
                            creation_time: ::core::clone::Clone::clone(
                                &self.creation_time,
                            ),
                            creation_order: ::core::clone::Clone::clone(
                                &self.creation_order,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "name",
                            "content_public",
                            "content_private",
                            "creation_time",
                            "creation_order",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.name,
                            &self.content_public,
                            &self.content_private,
                            &self.creation_time,
                            &&self.creation_order,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.name == other.name
                            && self.content_public == other.content_public
                            && self.content_private == other.content_private
                            && self.creation_time == other.creation_time
                            && self.creation_order == other.creation_order
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            name: sea_orm::ActiveValue::Unchanged(m.name),
                            content_public: sea_orm::ActiveValue::Unchanged(
                                m.content_public,
                            ),
                            content_private: sea_orm::ActiveValue::Unchanged(
                                m.content_private,
                            ),
                            creation_time: sea_orm::ActiveValue::Unchanged(
                                m.creation_time,
                            ),
                            creation_order: sea_orm::ActiveValue::Unchanged(
                                m.creation_order,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.name);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPublic => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.content_public);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPrivate => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.content_private);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.creation_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationOrder => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.creation_order);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPublic => {
                                self.content_public.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPrivate => {
                                self.content_private.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationOrder => {
                                self.creation_order.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPublic => {
                                self.content_public = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPrivate => {
                                self.content_private = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationOrder => {
                                self.creation_order = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPublic => {
                                self.content_public = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPrivate => {
                                self.content_private = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationOrder => {
                                self.creation_order = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPublic => {
                                self.content_public.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPrivate => {
                                self.content_private.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationOrder => {
                                self.creation_order.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            name: sea_orm::ActiveValue::NotSet,
                            content_public: sea_orm::ActiveValue::NotSet,
                            content_private: sea_orm::ActiveValue::NotSet,
                            creation_time: sea_orm::ActiveValue::NotSet,
                            creation_order: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.name = (&default.name).default_value();
                        default.content_public = (&default.content_public)
                            .default_value();
                        default.content_private = (&default.content_private)
                            .default_value();
                        default.creation_time = (&default.creation_time).default_value();
                        default.creation_order = (&default.creation_order)
                            .default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPublic => {
                                self.content_public.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::ContentPrivate => {
                                self.content_private.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationOrder => {
                                self.creation_order.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.name {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("name".to_owned()));
                        }
                        if match a.content_public {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("content_public".to_owned()),
                            );
                        }
                        if match a.content_private {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("content_private".to_owned()),
                            );
                        }
                        if match a.creation_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("creation_time".to_owned()),
                            );
                        }
                        if match a.creation_order {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("creation_order".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            name: a.name.into_value().unwrap().unwrap(),
                            content_public: a
                                .content_public
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            content_private: a
                                .content_private
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            creation_time: a
                                .creation_time
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            creation_order: a
                                .creation_order
                                .into_value()
                                .unwrap()
                                .unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for Model {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __field4,
                                __field5,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        4u64 => _serde::__private::Ok(__Field::__field4),
                                        5u64 => _serde::__private::Ok(__Field::__field5),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "name" => _serde::__private::Ok(__Field::__field1),
                                        "content_public" => _serde::__private::Ok(__Field::__field2),
                                        "content_private" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        "creation_time" => _serde::__private::Ok(__Field::__field4),
                                        "creation_order" => _serde::__private::Ok(__Field::__field5),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"name" => _serde::__private::Ok(__Field::__field1),
                                        b"content_public" => {
                                            _serde::__private::Ok(__Field::__field2)
                                        }
                                        b"content_private" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        b"creation_time" => _serde::__private::Ok(__Field::__field4),
                                        b"creation_order" => {
                                            _serde::__private::Ok(__Field::__field5)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<Model>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = Model;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct Model",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct Model with 6 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct Model with 6 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct Model with 6 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct Model with 6 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field4 = match _serde::de::SeqAccess::next_element::<
                                        DateTime,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    4usize,
                                                    &"struct Model with 6 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field5 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    5usize,
                                                    &"struct Model with 6 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(Model {
                                        node_id: __field0,
                                        name: __field1,
                                        content_public: __field2,
                                        content_private: __field3,
                                        creation_time: __field4,
                                        creation_order: __field5,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field4: _serde::__private::Option<DateTime> = _serde::__private::None;
                                    let mut __field5: _serde::__private::Option<i64> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "content_public",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "content_private",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field4 => {
                                                if _serde::__private::Option::is_some(&__field4) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "creation_time",
                                                        ),
                                                    );
                                                }
                                                __field4 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<DateTime>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field5 => {
                                                if _serde::__private::Option::is_some(&__field5) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "creation_order",
                                                        ),
                                                    );
                                                }
                                                __field5 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("name")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("content_public")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("content_private")?
                                        }
                                    };
                                    let __field4 = match __field4 {
                                        _serde::__private::Some(__field4) => __field4,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("creation_time")?
                                        }
                                    };
                                    let __field5 = match __field5 {
                                        _serde::__private::Some(__field5) => __field5,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("creation_order")?
                                        }
                                    };
                                    _serde::__private::Ok(Model {
                                        node_id: __field0,
                                        name: __field1,
                                        content_public: __field2,
                                        content_private: __field3,
                                        creation_time: __field4,
                                        creation_order: __field5,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "node_id",
                                "name",
                                "content_public",
                                "content_private",
                                "creation_time",
                                "creation_order",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "Model",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<Model>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for Model {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "Model",
                                false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "name",
                                &self.name,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "content_public",
                                &self.content_public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "content_private",
                                &self.content_private,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "creation_time",
                                &self.creation_time,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "creation_order",
                                &self.creation_order,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl sea_orm::TryGetableFromJson for Model {}
                #[automatically_derived]
                impl std::convert::From<Model> for sea_orm::Value {
                    fn from(source: Model) -> Self {
                        sea_orm::Value::Json(
                            serde_json::to_value(&source)
                                .ok()
                                .map(|s| std::boxed::Box::new(s)),
                        )
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::ValueType for Model {
                    fn try_from(
                        v: sea_orm::Value,
                    ) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {
                        match v {
                            sea_orm::Value::Json(Some(json)) => {
                                Ok(
                                    serde_json::from_value(*json)
                                        .map_err(|_| sea_orm::sea_query::ValueTypeErr)?,
                                )
                            }
                            _ => Err(sea_orm::sea_query::ValueTypeErr),
                        }
                    }
                    fn type_name() -> String {
                        "Model".to_owned()
                    }
                    fn array_type() -> sea_orm::sea_query::ArrayType {
                        sea_orm::sea_query::ArrayType::Json
                    }
                    fn column_type() -> sea_orm::sea_query::ColumnType {
                        sea_orm::sea_query::ColumnType::Json
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::Nullable for Model {
                    fn null() -> sea_orm::Value {
                        sea_orm::Value::Json(None)
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::value::with_array::NotU8 for Model {}
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "problem"
                    }
                }
                impl DbNodeActiveModel<Model, ProblemNode> for ActiveModel {}
            }
            pub mod problem_limit {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::problem::limit::ProblemLimitNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "node_problem_limit")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub time_limit: i64,
                    pub memory_limit: i64,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(&self.memory_limit),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Model",
                            "node_id",
                            &self.node_id,
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &&self.memory_limit,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id
                            && self.time_limit == other.time_limit
                            && self.memory_limit == other.memory_limit
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    TimeLimit,
                    /// Generated by sea-orm-macros
                    MemoryLimit,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::TimeLimit => "TimeLimit",
                                Column::MemoryLimit => "MemoryLimit",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::TimeLimit),
                            2usize => ::core::option::Option::Some(Column::MemoryLimit),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 3usize {
                            0
                        } else {
                            3usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 3usize {
                            self.idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 3usize {
                            self.back_idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 3usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::TimeLimit => "time_limit",
                            Self::MemoryLimit => "memory_limit",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "time_limit" | "timeLimit" | "time_limit" => {
                                Ok(Column::TimeLimit)
                            }
                            "memory_limit" | "memoryLimit" | "memory_limit" => {
                                Ok(Column::MemoryLimit)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::TimeLimit => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::MemoryLimit => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TimeLimit => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::MemoryLimit => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_problem_limit"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            time_limit: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit,
                                        )
                                        .into(),
                                )?,
                            memory_limit: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub time_limit: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub memory_limit: sea_orm::ActiveValue<i64>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(&self.memory_limit),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ActiveModel",
                            "node_id",
                            &self.node_id,
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &&self.memory_limit,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id
                            && self.time_limit == other.time_limit
                            && self.memory_limit == other.memory_limit
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            time_limit: sea_orm::ActiveValue::Unchanged(m.time_limit),
                            memory_limit: sea_orm::ActiveValue::Unchanged(m.memory_limit),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.time_limit);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.memory_limit);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            time_limit: sea_orm::ActiveValue::NotSet,
                            memory_limit: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.time_limit = (&default.time_limit).default_value();
                        default.memory_limit = (&default.memory_limit).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.time_limit {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("time_limit".to_owned()),
                            );
                        }
                        if match a.memory_limit {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("memory_limit".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            time_limit: a.time_limit.into_value().unwrap().unwrap(),
                            memory_limit: a.memory_limit.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "problem_limit"
                    }
                }
                impl DbNodeActiveModel<Model, ProblemLimitNode> for ActiveModel {}
            }
            pub mod problem_source {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::problem_source::ProblemSourceNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "node_problem_source")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub iden: String,
                    pub name: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                            name: ::core::clone::Clone::clone(&self.name),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Model",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &self.iden,
                            "name",
                            &&self.name,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                            && self.name == other.name
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Iden,
                    /// Generated by sea-orm-macros
                    Name,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Iden => "Iden",
                                Column::Name => "Name",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Iden),
                            2usize => ::core::option::Option::Some(Column::Name),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 3usize {
                            0
                        } else {
                            3usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 3usize {
                            self.idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 3usize {
                            self.back_idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 3usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Iden => "iden",
                            Self::Name => "name",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "iden" | "iden" | "iden" => Ok(Column::Iden),
                            "name" | "name" | "name" => Ok(Column::Name),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Iden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::Name => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Iden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Name => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_problem_source"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Iden,
                                        )
                                        .into(),
                                )?,
                            name: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Name,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                                self.name.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                                self.name = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub iden: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub name: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                            name: ::core::clone::Clone::clone(&self.name),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ActiveModel",
                            "node_id",
                            &self.node_id,
                            "iden",
                            &self.iden,
                            "name",
                            &&self.name,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                            && self.name == other.name
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            iden: sea_orm::ActiveValue::Unchanged(m.iden),
                            name: sea_orm::ActiveValue::Unchanged(m.name),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.iden);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.name);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            iden: sea_orm::ActiveValue::NotSet,
                            name: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.iden = (&default.iden).default_value();
                        default.name = (&default.name).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("iden".to_owned()));
                        }
                        if match a.name {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("name".to_owned()));
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            iden: a.iden.into_value().unwrap().unwrap(),
                            name: a.name.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "problem_source"
                    }
                }
                impl DbNodeActiveModel<Model, ProblemSourceNode> for ActiveModel {}
            }
            pub mod problem_statement {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::problem::statement::ProblemStatementNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{
                    DeriveEntityModel, DeriveRelation, EnumIter, FromJsonQueryResult,
                };
                use serde::{Deserialize, Serialize};
                pub struct ContentType {
                    pub iden: String,
                    pub content: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ContentType {
                    #[inline]
                    fn clone(&self) -> ContentType {
                        ContentType {
                            iden: ::core::clone::Clone::clone(&self.iden),
                            content: ::core::clone::Clone::clone(&self.content),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ContentType {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ContentType",
                            "iden",
                            &self.iden,
                            "content",
                            &&self.content,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ContentType {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ContentType {
                    #[inline]
                    fn eq(&self, other: &ContentType) -> bool {
                        self.iden == other.iden && self.content == other.content
                    }
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ContentType {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ContentType",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "iden",
                                &self.iden,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "content",
                                &self.content,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ContentType {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "iden" => _serde::__private::Ok(__Field::__field0),
                                        "content" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"iden" => _serde::__private::Ok(__Field::__field0),
                                        b"content" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<ContentType>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ContentType;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ContentType",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ContentType with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ContentType with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ContentType {
                                        iden: __field0,
                                        content: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "content",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("iden")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("content")?
                                        }
                                    };
                                    _serde::__private::Ok(ContentType {
                                        iden: __field0,
                                        content: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &["iden", "content"];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ContentType",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<ContentType>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[automatically_derived]
                impl sea_orm::TryGetableFromJson for ContentType {}
                #[automatically_derived]
                impl std::convert::From<ContentType> for sea_orm::Value {
                    fn from(source: ContentType) -> Self {
                        sea_orm::Value::Json(
                            serde_json::to_value(&source)
                                .ok()
                                .map(|s| std::boxed::Box::new(s)),
                        )
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::ValueType for ContentType {
                    fn try_from(
                        v: sea_orm::Value,
                    ) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {
                        match v {
                            sea_orm::Value::Json(Some(json)) => {
                                Ok(
                                    serde_json::from_value(*json)
                                        .map_err(|_| sea_orm::sea_query::ValueTypeErr)?,
                                )
                            }
                            _ => Err(sea_orm::sea_query::ValueTypeErr),
                        }
                    }
                    fn type_name() -> String {
                        "ContentType".to_owned()
                    }
                    fn array_type() -> sea_orm::sea_query::ArrayType {
                        sea_orm::sea_query::ArrayType::Json
                    }
                    fn column_type() -> sea_orm::sea_query::ColumnType {
                        sea_orm::sea_query::ColumnType::Json
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::Nullable for ContentType {
                    fn null() -> sea_orm::Value {
                        sea_orm::Value::Json(None)
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::value::with_array::NotU8 for ContentType {}
                #[sea_orm(table_name = "node_problem_statement")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub iden: String,
                    pub source: String,
                    #[sea_orm(column_type = "Json")]
                    pub content: Vec<ContentType>,
                    pub creation_time: DateTime,
                    pub update_time: DateTime,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                            source: ::core::clone::Clone::clone(&self.source),
                            content: ::core::clone::Clone::clone(&self.content),
                            creation_time: ::core::clone::Clone::clone(
                                &self.creation_time,
                            ),
                            update_time: ::core::clone::Clone::clone(&self.update_time),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "iden",
                            "source",
                            "content",
                            "creation_time",
                            "update_time",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.iden,
                            &self.source,
                            &self.content,
                            &self.creation_time,
                            &&self.update_time,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                            && self.source == other.source
                            && self.content == other.content
                            && self.creation_time == other.creation_time
                            && self.update_time == other.update_time
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Iden,
                    /// Generated by sea-orm-macros
                    Source,
                    /// Generated by sea-orm-macros
                    Content,
                    /// Generated by sea-orm-macros
                    CreationTime,
                    /// Generated by sea-orm-macros
                    UpdateTime,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Iden => "Iden",
                                Column::Source => "Source",
                                Column::Content => "Content",
                                Column::CreationTime => "CreationTime",
                                Column::UpdateTime => "UpdateTime",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Iden),
                            2usize => ::core::option::Option::Some(Column::Source),
                            3usize => ::core::option::Option::Some(Column::Content),
                            4usize => ::core::option::Option::Some(Column::CreationTime),
                            5usize => ::core::option::Option::Some(Column::UpdateTime),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 6usize {
                            0
                        } else {
                            6usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 6usize {
                            self.idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 6usize {
                            self.back_idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 6usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Iden => "iden",
                            Self::Source => "source",
                            Self::Content => "content",
                            Self::CreationTime => "creation_time",
                            Self::UpdateTime => "update_time",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "iden" | "iden" | "iden" => Ok(Column::Iden),
                            "source" | "source" | "source" => Ok(Column::Source),
                            "content" | "content" | "content" => Ok(Column::Content),
                            "creation_time" | "creationTime" | "creation_time" => {
                                Ok(Column::CreationTime)
                            }
                            "update_time" | "updateTime" | "update_time" => {
                                Ok(Column::UpdateTime)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Iden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::Source => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::Content => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::Json,
                                )
                            }
                            Self::CreationTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::UpdateTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Iden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Source => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Content => {
                                <Vec<
                                    ContentType,
                                > as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::CreationTime => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UpdateTime => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_problem_statement"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Iden,
                                        )
                                        .into(),
                                )?,
                            source: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Source,
                                        )
                                        .into(),
                                )?,
                            content: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Content,
                                        )
                                        .into(),
                                )?,
                            creation_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CreationTime,
                                        )
                                        .into(),
                                )?,
                            update_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UpdateTime,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Source => {
                                self.source.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Content => {
                                self.content.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreationTime => {
                                self.creation_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdateTime => {
                                self.update_time.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Source => {
                                self.source = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Content => {
                                self.content = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreationTime => {
                                self.creation_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdateTime => {
                                self.update_time = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub iden: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub source: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub content: sea_orm::ActiveValue<Vec<ContentType>>,
                    /// Generated by sea-orm-macros
                    pub creation_time: sea_orm::ActiveValue<DateTime>,
                    /// Generated by sea-orm-macros
                    pub update_time: sea_orm::ActiveValue<DateTime>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            iden: ::core::clone::Clone::clone(&self.iden),
                            source: ::core::clone::Clone::clone(&self.source),
                            content: ::core::clone::Clone::clone(&self.content),
                            creation_time: ::core::clone::Clone::clone(
                                &self.creation_time,
                            ),
                            update_time: ::core::clone::Clone::clone(&self.update_time),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "iden",
                            "source",
                            "content",
                            "creation_time",
                            "update_time",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.iden,
                            &self.source,
                            &self.content,
                            &self.creation_time,
                            &&self.update_time,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.iden == other.iden
                            && self.source == other.source
                            && self.content == other.content
                            && self.creation_time == other.creation_time
                            && self.update_time == other.update_time
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            iden: sea_orm::ActiveValue::Unchanged(m.iden),
                            source: sea_orm::ActiveValue::Unchanged(m.source),
                            content: sea_orm::ActiveValue::Unchanged(m.content),
                            creation_time: sea_orm::ActiveValue::Unchanged(
                                m.creation_time,
                            ),
                            update_time: sea_orm::ActiveValue::Unchanged(m.update_time),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.iden);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Source => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.source);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Content => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.content);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.creation_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UpdateTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.update_time);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Source => {
                                self.source.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Content => {
                                self.content.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UpdateTime => {
                                self.update_time.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Source => {
                                self.source = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Content => {
                                self.content = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UpdateTime => {
                                self.update_time = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Source => {
                                self.source = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Content => {
                                self.content = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UpdateTime => {
                                self.update_time = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Source => {
                                self.source.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Content => {
                                self.content.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UpdateTime => {
                                self.update_time.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            iden: sea_orm::ActiveValue::NotSet,
                            source: sea_orm::ActiveValue::NotSet,
                            content: sea_orm::ActiveValue::NotSet,
                            creation_time: sea_orm::ActiveValue::NotSet,
                            update_time: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.iden = (&default.iden).default_value();
                        default.source = (&default.source).default_value();
                        default.content = (&default.content).default_value();
                        default.creation_time = (&default.creation_time).default_value();
                        default.update_time = (&default.update_time).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Source => {
                                self.source.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Content => {
                                self.content.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CreationTime => {
                                self.creation_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UpdateTime => {
                                self.update_time.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("iden".to_owned()));
                        }
                        if match a.source {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("source".to_owned()));
                        }
                        if match a.content {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("content".to_owned()));
                        }
                        if match a.creation_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("creation_time".to_owned()),
                            );
                        }
                        if match a.update_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("update_time".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            iden: a.iden.into_value().unwrap().unwrap(),
                            source: a.source.into_value().unwrap().unwrap(),
                            content: a.content.into_value().unwrap().unwrap(),
                            creation_time: a
                                .creation_time
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            update_time: a.update_time.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "problem_statement"
                    }
                }
                impl DbNodeActiveModel<Model, ProblemStatementNode> for ActiveModel {}
            }
            pub mod problem_tag {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::problem::tag::ProblemTagNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "node_problem_tag")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub tag_name: String,
                    pub tag_description: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            tag_name: ::core::clone::Clone::clone(&self.tag_name),
                            tag_description: ::core::clone::Clone::clone(
                                &self.tag_description,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "Model",
                            "node_id",
                            &self.node_id,
                            "tag_name",
                            &self.tag_name,
                            "tag_description",
                            &&self.tag_description,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.tag_name == other.tag_name
                            && self.tag_description == other.tag_description
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    TagName,
                    /// Generated by sea-orm-macros
                    TagDescription,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::TagName => "TagName",
                                Column::TagDescription => "TagDescription",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::TagName),
                            2usize => {
                                ::core::option::Option::Some(Column::TagDescription)
                            }
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 3usize {
                            0
                        } else {
                            3usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 3usize {
                            self.idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 3usize {
                            self.back_idx = 3usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 3usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::TagName => "tag_name",
                            Self::TagDescription => "tag_description",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "tag_name" | "tagName" | "tag_name" => Ok(Column::TagName),
                            "tag_description" | "tagDescription" | "tag_description" => {
                                Ok(Column::TagDescription)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::TagName => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::TagDescription => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TagName => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TagDescription => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_problem_tag"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            tag_name: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TagName,
                                        )
                                        .into(),
                                )?,
                            tag_description: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TagDescription,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TagName => {
                                self.tag_name.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TagDescription => {
                                self.tag_description.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TagName => {
                                self.tag_name = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TagDescription => {
                                self.tag_description = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub tag_name: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub tag_description: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            tag_name: ::core::clone::Clone::clone(&self.tag_name),
                            tag_description: ::core::clone::Clone::clone(
                                &self.tag_description,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ActiveModel",
                            "node_id",
                            &self.node_id,
                            "tag_name",
                            &self.tag_name,
                            "tag_description",
                            &&self.tag_description,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.tag_name == other.tag_name
                            && self.tag_description == other.tag_description
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            tag_name: sea_orm::ActiveValue::Unchanged(m.tag_name),
                            tag_description: sea_orm::ActiveValue::Unchanged(
                                m.tag_description,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagName => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.tag_name);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagDescription => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.tag_description);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagName => {
                                self.tag_name.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagDescription => {
                                self.tag_description.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagName => {
                                self.tag_name = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagDescription => {
                                self.tag_description = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagName => {
                                self.tag_name = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagDescription => {
                                self.tag_description = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagName => {
                                self.tag_name.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagDescription => {
                                self.tag_description.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            tag_name: sea_orm::ActiveValue::NotSet,
                            tag_description: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.tag_name = (&default.tag_name).default_value();
                        default.tag_description = (&default.tag_description)
                            .default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagName => {
                                self.tag_name.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TagDescription => {
                                self.tag_description.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.tag_name {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("tag_name".to_owned()),
                            );
                        }
                        if match a.tag_description {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("tag_description".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            tag_name: a.tag_name.into_value().unwrap().unwrap(),
                            tag_description: a
                                .tag_description
                                .into_value()
                                .unwrap()
                                .unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "problem_tag"
                    }
                }
                impl DbNodeActiveModel<Model, ProblemTagNode> for ActiveModel {}
            }
            pub mod record {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::record::RecordNode;
                use chrono::{NaiveDate, NaiveDateTime};
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "node_record")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub record_time: NaiveDateTime,
                    pub record_update_time: NaiveDateTime,
                    pub record_order: i64,
                    pub record_status: i64,
                    pub record_score: i64,
                    pub record_platform: String,
                    pub record_url: Option<String>,
                    pub statement_id: i64,
                    pub record_message: Option<String>,
                    pub code: String,
                    pub code_language: String,
                    pub public_status: bool,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            record_time: ::core::clone::Clone::clone(&self.record_time),
                            record_update_time: ::core::clone::Clone::clone(
                                &self.record_update_time,
                            ),
                            record_order: ::core::clone::Clone::clone(
                                &self.record_order,
                            ),
                            record_status: ::core::clone::Clone::clone(
                                &self.record_status,
                            ),
                            record_score: ::core::clone::Clone::clone(
                                &self.record_score,
                            ),
                            record_platform: ::core::clone::Clone::clone(
                                &self.record_platform,
                            ),
                            record_url: ::core::clone::Clone::clone(&self.record_url),
                            statement_id: ::core::clone::Clone::clone(
                                &self.statement_id,
                            ),
                            record_message: ::core::clone::Clone::clone(
                                &self.record_message,
                            ),
                            code: ::core::clone::Clone::clone(&self.code),
                            code_language: ::core::clone::Clone::clone(
                                &self.code_language,
                            ),
                            public_status: ::core::clone::Clone::clone(
                                &self.public_status,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "record_time",
                            "record_update_time",
                            "record_order",
                            "record_status",
                            "record_score",
                            "record_platform",
                            "record_url",
                            "statement_id",
                            "record_message",
                            "code",
                            "code_language",
                            "public_status",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.record_time,
                            &self.record_update_time,
                            &self.record_order,
                            &self.record_status,
                            &self.record_score,
                            &self.record_platform,
                            &self.record_url,
                            &self.statement_id,
                            &self.record_message,
                            &self.code,
                            &self.code_language,
                            &&self.public_status,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id
                            && self.record_order == other.record_order
                            && self.record_status == other.record_status
                            && self.record_score == other.record_score
                            && self.statement_id == other.statement_id
                            && self.public_status == other.public_status
                            && self.record_time == other.record_time
                            && self.record_update_time == other.record_update_time
                            && self.record_platform == other.record_platform
                            && self.record_url == other.record_url
                            && self.record_message == other.record_message
                            && self.code == other.code
                            && self.code_language == other.code_language
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    RecordTime,
                    /// Generated by sea-orm-macros
                    RecordUpdateTime,
                    /// Generated by sea-orm-macros
                    RecordOrder,
                    /// Generated by sea-orm-macros
                    RecordStatus,
                    /// Generated by sea-orm-macros
                    RecordScore,
                    /// Generated by sea-orm-macros
                    RecordPlatform,
                    /// Generated by sea-orm-macros
                    RecordUrl,
                    /// Generated by sea-orm-macros
                    StatementId,
                    /// Generated by sea-orm-macros
                    RecordMessage,
                    /// Generated by sea-orm-macros
                    Code,
                    /// Generated by sea-orm-macros
                    CodeLanguage,
                    /// Generated by sea-orm-macros
                    PublicStatus,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::RecordTime => "RecordTime",
                                Column::RecordUpdateTime => "RecordUpdateTime",
                                Column::RecordOrder => "RecordOrder",
                                Column::RecordStatus => "RecordStatus",
                                Column::RecordScore => "RecordScore",
                                Column::RecordPlatform => "RecordPlatform",
                                Column::RecordUrl => "RecordUrl",
                                Column::StatementId => "StatementId",
                                Column::RecordMessage => "RecordMessage",
                                Column::Code => "Code",
                                Column::CodeLanguage => "CodeLanguage",
                                Column::PublicStatus => "PublicStatus",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::RecordTime),
                            2usize => {
                                ::core::option::Option::Some(Column::RecordUpdateTime)
                            }
                            3usize => ::core::option::Option::Some(Column::RecordOrder),
                            4usize => ::core::option::Option::Some(Column::RecordStatus),
                            5usize => ::core::option::Option::Some(Column::RecordScore),
                            6usize => {
                                ::core::option::Option::Some(Column::RecordPlatform)
                            }
                            7usize => ::core::option::Option::Some(Column::RecordUrl),
                            8usize => ::core::option::Option::Some(Column::StatementId),
                            9usize => ::core::option::Option::Some(Column::RecordMessage),
                            10usize => ::core::option::Option::Some(Column::Code),
                            11usize => ::core::option::Option::Some(Column::CodeLanguage),
                            12usize => ::core::option::Option::Some(Column::PublicStatus),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 13usize {
                            0
                        } else {
                            13usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 13usize {
                            self.idx = 13usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 13usize {
                            self.back_idx = 13usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 13usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::RecordTime => "record_time",
                            Self::RecordUpdateTime => "record_update_time",
                            Self::RecordOrder => "record_order",
                            Self::RecordStatus => "record_status",
                            Self::RecordScore => "record_score",
                            Self::RecordPlatform => "record_platform",
                            Self::RecordUrl => "record_url",
                            Self::StatementId => "statement_id",
                            Self::RecordMessage => "record_message",
                            Self::Code => "code",
                            Self::CodeLanguage => "code_language",
                            Self::PublicStatus => "public_status",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "record_time" | "recordTime" | "record_time" => {
                                Ok(Column::RecordTime)
                            }
                            "record_update_time" | "recordUpdateTime"
                            | "record_update_time" => Ok(Column::RecordUpdateTime),
                            "record_order" | "recordOrder" | "record_order" => {
                                Ok(Column::RecordOrder)
                            }
                            "record_status" | "recordStatus" | "record_status" => {
                                Ok(Column::RecordStatus)
                            }
                            "record_score" | "recordScore" | "record_score" => {
                                Ok(Column::RecordScore)
                            }
                            "record_platform" | "recordPlatform" | "record_platform" => {
                                Ok(Column::RecordPlatform)
                            }
                            "record_url" | "recordUrl" | "record_url" => {
                                Ok(Column::RecordUrl)
                            }
                            "statement_id" | "statementId" | "statement_id" => {
                                Ok(Column::StatementId)
                            }
                            "record_message" | "recordMessage" | "record_message" => {
                                Ok(Column::RecordMessage)
                            }
                            "code" | "code" | "code" => Ok(Column::Code),
                            "code_language" | "codeLanguage" | "code_language" => {
                                Ok(Column::CodeLanguage)
                            }
                            "public_status" | "publicStatus" | "public_status" => {
                                Ok(Column::PublicStatus)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::RecordTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::RecordUpdateTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::RecordOrder => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::RecordStatus => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::RecordScore => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::RecordPlatform => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::RecordUrl => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                        sea_orm::prelude::ColumnType::string(None),
                                    )
                                    .nullable()
                            }
                            Self::StatementId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::RecordMessage => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                        sea_orm::prelude::ColumnType::string(None),
                                    )
                                    .nullable()
                            }
                            Self::Code => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::CodeLanguage => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::PublicStatus => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::Boolean,
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordTime => {
                                <NaiveDateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordUpdateTime => {
                                <NaiveDateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordOrder => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordStatus => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordScore => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordPlatform => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordUrl => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::StatementId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::RecordMessage => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Code => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::CodeLanguage => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::PublicStatus => {
                                <bool as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_record"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            record_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordTime,
                                        )
                                        .into(),
                                )?,
                            record_update_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordUpdateTime,
                                        )
                                        .into(),
                                )?,
                            record_order: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordOrder,
                                        )
                                        .into(),
                                )?,
                            record_status: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordStatus,
                                        )
                                        .into(),
                                )?,
                            record_score: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordScore,
                                        )
                                        .into(),
                                )?,
                            record_platform: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordPlatform,
                                        )
                                        .into(),
                                )?,
                            record_url: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordUrl,
                                        )
                                        .into(),
                                )?,
                            statement_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::StatementId,
                                        )
                                        .into(),
                                )?,
                            record_message: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::RecordMessage,
                                        )
                                        .into(),
                                )?,
                            code: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Code,
                                        )
                                        .into(),
                                )?,
                            code_language: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CodeLanguage,
                                        )
                                        .into(),
                                )?,
                            public_status: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::PublicStatus,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordTime => {
                                self.record_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordUpdateTime => {
                                self.record_update_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordOrder => {
                                self.record_order.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordStatus => {
                                self.record_status.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordScore => {
                                self.record_score.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordPlatform => {
                                self.record_platform.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordUrl => {
                                self.record_url.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::StatementId => {
                                self.statement_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordMessage => {
                                self.record_message.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Code => {
                                self.code.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CodeLanguage => {
                                self.code_language.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::PublicStatus => {
                                self.public_status.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordTime => {
                                self.record_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordUpdateTime => {
                                self.record_update_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordOrder => {
                                self.record_order = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordStatus => {
                                self.record_status = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordScore => {
                                self.record_score = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordPlatform => {
                                self.record_platform = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordUrl => {
                                self.record_url = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::StatementId => {
                                self.statement_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::RecordMessage => {
                                self.record_message = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Code => {
                                self.code = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::CodeLanguage => {
                                self.code_language = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::PublicStatus => {
                                self.public_status = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub record_time: sea_orm::ActiveValue<NaiveDateTime>,
                    /// Generated by sea-orm-macros
                    pub record_update_time: sea_orm::ActiveValue<NaiveDateTime>,
                    /// Generated by sea-orm-macros
                    pub record_order: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub record_status: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub record_score: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub record_platform: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub record_url: sea_orm::ActiveValue<Option<String>>,
                    /// Generated by sea-orm-macros
                    pub statement_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub record_message: sea_orm::ActiveValue<Option<String>>,
                    /// Generated by sea-orm-macros
                    pub code: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub code_language: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub public_status: sea_orm::ActiveValue<bool>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            record_time: ::core::clone::Clone::clone(&self.record_time),
                            record_update_time: ::core::clone::Clone::clone(
                                &self.record_update_time,
                            ),
                            record_order: ::core::clone::Clone::clone(
                                &self.record_order,
                            ),
                            record_status: ::core::clone::Clone::clone(
                                &self.record_status,
                            ),
                            record_score: ::core::clone::Clone::clone(
                                &self.record_score,
                            ),
                            record_platform: ::core::clone::Clone::clone(
                                &self.record_platform,
                            ),
                            record_url: ::core::clone::Clone::clone(&self.record_url),
                            statement_id: ::core::clone::Clone::clone(
                                &self.statement_id,
                            ),
                            record_message: ::core::clone::Clone::clone(
                                &self.record_message,
                            ),
                            code: ::core::clone::Clone::clone(&self.code),
                            code_language: ::core::clone::Clone::clone(
                                &self.code_language,
                            ),
                            public_status: ::core::clone::Clone::clone(
                                &self.public_status,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "record_time",
                            "record_update_time",
                            "record_order",
                            "record_status",
                            "record_score",
                            "record_platform",
                            "record_url",
                            "statement_id",
                            "record_message",
                            "code",
                            "code_language",
                            "public_status",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.record_time,
                            &self.record_update_time,
                            &self.record_order,
                            &self.record_status,
                            &self.record_score,
                            &self.record_platform,
                            &self.record_url,
                            &self.statement_id,
                            &self.record_message,
                            &self.code,
                            &self.code_language,
                            &&self.public_status,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id
                            && self.record_time == other.record_time
                            && self.record_update_time == other.record_update_time
                            && self.record_order == other.record_order
                            && self.record_status == other.record_status
                            && self.record_score == other.record_score
                            && self.record_platform == other.record_platform
                            && self.record_url == other.record_url
                            && self.statement_id == other.statement_id
                            && self.record_message == other.record_message
                            && self.code == other.code
                            && self.code_language == other.code_language
                            && self.public_status == other.public_status
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            record_time: sea_orm::ActiveValue::Unchanged(m.record_time),
                            record_update_time: sea_orm::ActiveValue::Unchanged(
                                m.record_update_time,
                            ),
                            record_order: sea_orm::ActiveValue::Unchanged(
                                m.record_order,
                            ),
                            record_status: sea_orm::ActiveValue::Unchanged(
                                m.record_status,
                            ),
                            record_score: sea_orm::ActiveValue::Unchanged(
                                m.record_score,
                            ),
                            record_platform: sea_orm::ActiveValue::Unchanged(
                                m.record_platform,
                            ),
                            record_url: sea_orm::ActiveValue::Unchanged(m.record_url),
                            statement_id: sea_orm::ActiveValue::Unchanged(
                                m.statement_id,
                            ),
                            record_message: sea_orm::ActiveValue::Unchanged(
                                m.record_message,
                            ),
                            code: sea_orm::ActiveValue::Unchanged(m.code),
                            code_language: sea_orm::ActiveValue::Unchanged(
                                m.code_language,
                            ),
                            public_status: sea_orm::ActiveValue::Unchanged(
                                m.public_status,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUpdateTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_update_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordOrder => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_order);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordStatus => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_status);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordScore => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_score);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordPlatform => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_platform);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUrl => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_url);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StatementId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.statement_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordMessage => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.record_message);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Code => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.code);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CodeLanguage => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.code_language);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::PublicStatus => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.public_status);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordTime => {
                                self.record_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUpdateTime => {
                                self.record_update_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordOrder => {
                                self.record_order.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordStatus => {
                                self.record_status.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordScore => {
                                self.record_score.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordPlatform => {
                                self.record_platform.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUrl => {
                                self.record_url.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StatementId => {
                                self.statement_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordMessage => {
                                self.record_message.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Code => {
                                self.code.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CodeLanguage => {
                                self.code_language.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::PublicStatus => {
                                self.public_status.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordTime => {
                                self.record_time = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUpdateTime => {
                                self.record_update_time = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordOrder => {
                                self.record_order = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordStatus => {
                                self.record_status = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordScore => {
                                self.record_score = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordPlatform => {
                                self.record_platform = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUrl => {
                                self.record_url = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StatementId => {
                                self.statement_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordMessage => {
                                self.record_message = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Code => {
                                self.code = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CodeLanguage => {
                                self.code_language = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::PublicStatus => {
                                self.public_status = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordTime => {
                                self.record_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUpdateTime => {
                                self.record_update_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordOrder => {
                                self.record_order = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordStatus => {
                                self.record_status = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordScore => {
                                self.record_score = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordPlatform => {
                                self.record_platform = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUrl => {
                                self.record_url = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StatementId => {
                                self.statement_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordMessage => {
                                self.record_message = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Code => {
                                self.code = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CodeLanguage => {
                                self.code_language = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::PublicStatus => {
                                self.public_status = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordTime => {
                                self.record_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUpdateTime => {
                                self.record_update_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordOrder => {
                                self.record_order.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordStatus => {
                                self.record_status.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordScore => {
                                self.record_score.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordPlatform => {
                                self.record_platform.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUrl => {
                                self.record_url.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StatementId => {
                                self.statement_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordMessage => {
                                self.record_message.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Code => {
                                self.code.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CodeLanguage => {
                                self.code_language.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::PublicStatus => {
                                self.public_status.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            record_time: sea_orm::ActiveValue::NotSet,
                            record_update_time: sea_orm::ActiveValue::NotSet,
                            record_order: sea_orm::ActiveValue::NotSet,
                            record_status: sea_orm::ActiveValue::NotSet,
                            record_score: sea_orm::ActiveValue::NotSet,
                            record_platform: sea_orm::ActiveValue::NotSet,
                            record_url: sea_orm::ActiveValue::NotSet,
                            statement_id: sea_orm::ActiveValue::NotSet,
                            record_message: sea_orm::ActiveValue::NotSet,
                            code: sea_orm::ActiveValue::NotSet,
                            code_language: sea_orm::ActiveValue::NotSet,
                            public_status: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.record_time = (&default.record_time).default_value();
                        default.record_update_time = (&default.record_update_time)
                            .default_value();
                        default.record_order = (&default.record_order).default_value();
                        default.record_status = (&default.record_status).default_value();
                        default.record_score = (&default.record_score).default_value();
                        default.record_platform = (&default.record_platform)
                            .default_value();
                        default.record_url = (&default.record_url).default_value();
                        default.statement_id = (&default.statement_id).default_value();
                        default.record_message = (&default.record_message)
                            .default_value();
                        default.code = (&default.code).default_value();
                        default.code_language = (&default.code_language).default_value();
                        default.public_status = (&default.public_status).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordTime => {
                                self.record_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUpdateTime => {
                                self.record_update_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordOrder => {
                                self.record_order.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordStatus => {
                                self.record_status.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordScore => {
                                self.record_score.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordPlatform => {
                                self.record_platform.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordUrl => {
                                self.record_url.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StatementId => {
                                self.statement_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::RecordMessage => {
                                self.record_message.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Code => {
                                self.code.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::CodeLanguage => {
                                self.code_language.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::PublicStatus => {
                                self.public_status.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.record_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_time".to_owned()),
                            );
                        }
                        if match a.record_update_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_update_time".to_owned()),
                            );
                        }
                        if match a.record_order {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_order".to_owned()),
                            );
                        }
                        if match a.record_status {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_status".to_owned()),
                            );
                        }
                        if match a.record_score {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_score".to_owned()),
                            );
                        }
                        if match a.record_platform {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_platform".to_owned()),
                            );
                        }
                        if match a.record_url {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_url".to_owned()),
                            );
                        }
                        if match a.statement_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("statement_id".to_owned()),
                            );
                        }
                        if match a.record_message {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("record_message".to_owned()),
                            );
                        }
                        if match a.code {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("code".to_owned()));
                        }
                        if match a.code_language {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("code_language".to_owned()),
                            );
                        }
                        if match a.public_status {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("public_status".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            record_time: a.record_time.into_value().unwrap().unwrap(),
                            record_update_time: a
                                .record_update_time
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            record_order: a.record_order.into_value().unwrap().unwrap(),
                            record_status: a
                                .record_status
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            record_score: a.record_score.into_value().unwrap().unwrap(),
                            record_platform: a
                                .record_platform
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            record_url: a.record_url.into_value().unwrap().unwrap(),
                            statement_id: a.statement_id.into_value().unwrap().unwrap(),
                            record_message: a
                                .record_message
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            code: a.code.into_value().unwrap().unwrap(),
                            code_language: a
                                .code_language
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            public_status: a.public_status.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "record"
                    }
                }
                impl DbNodeActiveModel<Model, RecordNode> for ActiveModel {}
            }
            pub mod testcase_subtask {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::record::RecordNode;
                use crate::graph::node::record::subtask::SubtaskNode;
                use chrono::{NaiveDate, NaiveDateTime};
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "node_testcase_subtask")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub subtask_id: i32,
                    pub time_limit: i64,
                    pub memory_limit: i64,
                    pub subtask_calc_method: i32,
                    pub subtask_calc_function: Option<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            subtask_id: ::core::clone::Clone::clone(&self.subtask_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            subtask_calc_method: ::core::clone::Clone::clone(
                                &self.subtask_calc_method,
                            ),
                            subtask_calc_function: ::core::clone::Clone::clone(
                                &self.subtask_calc_function,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "subtask_id",
                            "time_limit",
                            "memory_limit",
                            "subtask_calc_method",
                            "subtask_calc_function",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.subtask_id,
                            &self.time_limit,
                            &self.memory_limit,
                            &self.subtask_calc_method,
                            &&self.subtask_calc_function,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id
                            && self.subtask_id == other.subtask_id
                            && self.time_limit == other.time_limit
                            && self.memory_limit == other.memory_limit
                            && self.subtask_calc_method == other.subtask_calc_method
                            && self.subtask_calc_function == other.subtask_calc_function
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    SubtaskId,
                    /// Generated by sea-orm-macros
                    TimeLimit,
                    /// Generated by sea-orm-macros
                    MemoryLimit,
                    /// Generated by sea-orm-macros
                    SubtaskCalcMethod,
                    /// Generated by sea-orm-macros
                    SubtaskCalcFunction,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::SubtaskId => "SubtaskId",
                                Column::TimeLimit => "TimeLimit",
                                Column::MemoryLimit => "MemoryLimit",
                                Column::SubtaskCalcMethod => "SubtaskCalcMethod",
                                Column::SubtaskCalcFunction => "SubtaskCalcFunction",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::SubtaskId),
                            2usize => ::core::option::Option::Some(Column::TimeLimit),
                            3usize => ::core::option::Option::Some(Column::MemoryLimit),
                            4usize => {
                                ::core::option::Option::Some(Column::SubtaskCalcMethod)
                            }
                            5usize => {
                                ::core::option::Option::Some(Column::SubtaskCalcFunction)
                            }
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 6usize {
                            0
                        } else {
                            6usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 6usize {
                            self.idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 6usize {
                            self.back_idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 6usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::SubtaskId => "subtask_id",
                            Self::TimeLimit => "time_limit",
                            Self::MemoryLimit => "memory_limit",
                            Self::SubtaskCalcMethod => "subtask_calc_method",
                            Self::SubtaskCalcFunction => "subtask_calc_function",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "subtask_id" | "subtaskId" | "subtask_id" => {
                                Ok(Column::SubtaskId)
                            }
                            "time_limit" | "timeLimit" | "time_limit" => {
                                Ok(Column::TimeLimit)
                            }
                            "memory_limit" | "memoryLimit" | "memory_limit" => {
                                Ok(Column::MemoryLimit)
                            }
                            "subtask_calc_method" | "subtaskCalcMethod"
                            | "subtask_calc_method" => Ok(Column::SubtaskCalcMethod),
                            "subtask_calc_function" | "subtaskCalcFunction"
                            | "subtask_calc_function" => Ok(Column::SubtaskCalcFunction),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::SubtaskId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::Integer,
                                )
                            }
                            Self::TimeLimit => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::MemoryLimit => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::SubtaskCalcMethod => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::Integer,
                                )
                            }
                            Self::SubtaskCalcFunction => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                        sea_orm::prelude::ColumnType::string(None),
                                    )
                                    .nullable()
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::SubtaskId => {
                                <i32 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TimeLimit => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::MemoryLimit => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::SubtaskCalcMethod => {
                                <i32 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::SubtaskCalcFunction => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_testcase_subtask"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            subtask_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskId,
                                        )
                                        .into(),
                                )?,
                            time_limit: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit,
                                        )
                                        .into(),
                                )?,
                            memory_limit: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit,
                                        )
                                        .into(),
                                )?,
                            subtask_calc_method: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskCalcMethod,
                                        )
                                        .into(),
                                )?,
                            subtask_calc_function: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskCalcFunction,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskId => {
                                self.subtask_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskCalcMethod => {
                                self.subtask_calc_method.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskCalcFunction => {
                                self.subtask_calc_function.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskId => {
                                self.subtask_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskCalcMethod => {
                                self.subtask_calc_method = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::SubtaskCalcFunction => {
                                self.subtask_calc_function = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub subtask_id: sea_orm::ActiveValue<i32>,
                    /// Generated by sea-orm-macros
                    pub time_limit: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub memory_limit: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub subtask_calc_method: sea_orm::ActiveValue<i32>,
                    /// Generated by sea-orm-macros
                    pub subtask_calc_function: sea_orm::ActiveValue<Option<String>>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            subtask_id: ::core::clone::Clone::clone(&self.subtask_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            subtask_calc_method: ::core::clone::Clone::clone(
                                &self.subtask_calc_method,
                            ),
                            subtask_calc_function: ::core::clone::Clone::clone(
                                &self.subtask_calc_function,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "subtask_id",
                            "time_limit",
                            "memory_limit",
                            "subtask_calc_method",
                            "subtask_calc_function",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.subtask_id,
                            &self.time_limit,
                            &self.memory_limit,
                            &self.subtask_calc_method,
                            &&self.subtask_calc_function,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id
                            && self.subtask_id == other.subtask_id
                            && self.time_limit == other.time_limit
                            && self.memory_limit == other.memory_limit
                            && self.subtask_calc_method == other.subtask_calc_method
                            && self.subtask_calc_function == other.subtask_calc_function
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            subtask_id: sea_orm::ActiveValue::Unchanged(m.subtask_id),
                            time_limit: sea_orm::ActiveValue::Unchanged(m.time_limit),
                            memory_limit: sea_orm::ActiveValue::Unchanged(
                                m.memory_limit,
                            ),
                            subtask_calc_method: sea_orm::ActiveValue::Unchanged(
                                m.subtask_calc_method,
                            ),
                            subtask_calc_function: sea_orm::ActiveValue::Unchanged(
                                m.subtask_calc_function,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.subtask_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.time_limit);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.memory_limit);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcMethod => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.subtask_calc_method);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcFunction => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.subtask_calc_function);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskId => {
                                self.subtask_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcMethod => {
                                self.subtask_calc_method.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcFunction => {
                                self.subtask_calc_function.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskId => {
                                self.subtask_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcMethod => {
                                self.subtask_calc_method = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcFunction => {
                                self.subtask_calc_function = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskId => {
                                self.subtask_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcMethod => {
                                self.subtask_calc_method = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcFunction => {
                                self.subtask_calc_function = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskId => {
                                self.subtask_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcMethod => {
                                self.subtask_calc_method.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcFunction => {
                                self.subtask_calc_function.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            subtask_id: sea_orm::ActiveValue::NotSet,
                            time_limit: sea_orm::ActiveValue::NotSet,
                            memory_limit: sea_orm::ActiveValue::NotSet,
                            subtask_calc_method: sea_orm::ActiveValue::NotSet,
                            subtask_calc_function: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.subtask_id = (&default.subtask_id).default_value();
                        default.time_limit = (&default.time_limit).default_value();
                        default.memory_limit = (&default.memory_limit).default_value();
                        default.subtask_calc_method = (&default.subtask_calc_method)
                            .default_value();
                        default.subtask_calc_function = (&default.subtask_calc_function)
                            .default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskId => {
                                self.subtask_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcMethod => {
                                self.subtask_calc_method.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::SubtaskCalcFunction => {
                                self.subtask_calc_function.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.subtask_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("subtask_id".to_owned()),
                            );
                        }
                        if match a.time_limit {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("time_limit".to_owned()),
                            );
                        }
                        if match a.memory_limit {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("memory_limit".to_owned()),
                            );
                        }
                        if match a.subtask_calc_method {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("subtask_calc_method".to_owned()),
                            );
                        }
                        if match a.subtask_calc_function {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet(
                                    "subtask_calc_function".to_owned(),
                                ),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            subtask_id: a.subtask_id.into_value().unwrap().unwrap(),
                            time_limit: a.time_limit.into_value().unwrap().unwrap(),
                            memory_limit: a.memory_limit.into_value().unwrap().unwrap(),
                            subtask_calc_method: a
                                .subtask_calc_method
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            subtask_calc_function: a
                                .subtask_calc_function
                                .into_value()
                                .unwrap()
                                .unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "testcase_subtask"
                    }
                }
                impl DbNodeActiveModel<Model, SubtaskNode> for ActiveModel {}
            }
            pub mod token {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::token::TokenNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "node_token")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub token: String,
                    pub token_type: String,
                    pub token_expiration: DateTime,
                    pub service: String,
                    pub token_iden: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            token: ::core::clone::Clone::clone(&self.token),
                            token_type: ::core::clone::Clone::clone(&self.token_type),
                            token_expiration: ::core::clone::Clone::clone(
                                &self.token_expiration,
                            ),
                            service: ::core::clone::Clone::clone(&self.service),
                            token_iden: ::core::clone::Clone::clone(&self.token_iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "token",
                            "token_type",
                            "token_expiration",
                            "service",
                            "token_iden",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.token,
                            &self.token_type,
                            &self.token_expiration,
                            &self.service,
                            &&self.token_iden,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.token == other.token
                            && self.token_type == other.token_type
                            && self.token_expiration == other.token_expiration
                            && self.service == other.service
                            && self.token_iden == other.token_iden
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for Model {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<i64>;
                        let _: ::core::cmp::AssertParamIsEq<String>;
                        let _: ::core::cmp::AssertParamIsEq<DateTime>;
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Token,
                    /// Generated by sea-orm-macros
                    TokenType,
                    /// Generated by sea-orm-macros
                    TokenExpiration,
                    /// Generated by sea-orm-macros
                    Service,
                    /// Generated by sea-orm-macros
                    TokenIden,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Token => "Token",
                                Column::TokenType => "TokenType",
                                Column::TokenExpiration => "TokenExpiration",
                                Column::Service => "Service",
                                Column::TokenIden => "TokenIden",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Token),
                            2usize => ::core::option::Option::Some(Column::TokenType),
                            3usize => {
                                ::core::option::Option::Some(Column::TokenExpiration)
                            }
                            4usize => ::core::option::Option::Some(Column::Service),
                            5usize => ::core::option::Option::Some(Column::TokenIden),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 6usize {
                            0
                        } else {
                            6usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 6usize {
                            self.idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 6usize {
                            self.back_idx = 6usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 6usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Token => "token",
                            Self::TokenType => "token_type",
                            Self::TokenExpiration => "token_expiration",
                            Self::Service => "service",
                            Self::TokenIden => "token_iden",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "token" | "token" | "token" => Ok(Column::Token),
                            "token_type" | "tokenType" | "token_type" => {
                                Ok(Column::TokenType)
                            }
                            "token_expiration" | "tokenExpiration"
                            | "token_expiration" => Ok(Column::TokenExpiration),
                            "service" | "service" | "service" => Ok(Column::Service),
                            "token_iden" | "tokenIden" | "token_iden" => {
                                Ok(Column::TokenIden)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Token => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::TokenType => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::TokenExpiration => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::Service => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::TokenIden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Token => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TokenType => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TokenExpiration => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Service => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TokenIden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_token"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            token: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Token,
                                        )
                                        .into(),
                                )?,
                            token_type: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TokenType,
                                        )
                                        .into(),
                                )?,
                            token_expiration: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TokenExpiration,
                                        )
                                        .into(),
                                )?,
                            service: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Service,
                                        )
                                        .into(),
                                )?,
                            token_iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TokenIden,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Token => {
                                self.token.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TokenType => {
                                self.token_type.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TokenExpiration => {
                                self.token_expiration.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Service => {
                                self.service.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TokenIden => {
                                self.token_iden.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Token => {
                                self.token = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TokenType => {
                                self.token_type = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TokenExpiration => {
                                self.token_expiration = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Service => {
                                self.service = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TokenIden => {
                                self.token_iden = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub token: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub token_type: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub token_expiration: sea_orm::ActiveValue<DateTime>,
                    /// Generated by sea-orm-macros
                    pub service: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub token_iden: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            token: ::core::clone::Clone::clone(&self.token),
                            token_type: ::core::clone::Clone::clone(&self.token_type),
                            token_expiration: ::core::clone::Clone::clone(
                                &self.token_expiration,
                            ),
                            service: ::core::clone::Clone::clone(&self.service),
                            token_iden: ::core::clone::Clone::clone(&self.token_iden),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "token",
                            "token_type",
                            "token_expiration",
                            "service",
                            "token_iden",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.token,
                            &self.token_type,
                            &self.token_expiration,
                            &self.service,
                            &&self.token_iden,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.token == other.token
                            && self.token_type == other.token_type
                            && self.token_expiration == other.token_expiration
                            && self.service == other.service
                            && self.token_iden == other.token_iden
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            token: sea_orm::ActiveValue::Unchanged(m.token),
                            token_type: sea_orm::ActiveValue::Unchanged(m.token_type),
                            token_expiration: sea_orm::ActiveValue::Unchanged(
                                m.token_expiration,
                            ),
                            service: sea_orm::ActiveValue::Unchanged(m.service),
                            token_iden: sea_orm::ActiveValue::Unchanged(m.token_iden),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.token);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenType => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.token_type);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenExpiration => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.token_expiration);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Service => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.service);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenIden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.token_iden);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                                self.token.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenType => {
                                self.token_type.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenExpiration => {
                                self.token_expiration.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Service => {
                                self.service.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenIden => {
                                self.token_iden.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                                self.token = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenType => {
                                self.token_type = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenExpiration => {
                                self.token_expiration = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Service => {
                                self.service = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenIden => {
                                self.token_iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                                self.token = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenType => {
                                self.token_type = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenExpiration => {
                                self.token_expiration = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Service => {
                                self.service = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenIden => {
                                self.token_iden = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                                self.token.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenType => {
                                self.token_type.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenExpiration => {
                                self.token_expiration.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Service => {
                                self.service.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenIden => {
                                self.token_iden.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            token: sea_orm::ActiveValue::NotSet,
                            token_type: sea_orm::ActiveValue::NotSet,
                            token_expiration: sea_orm::ActiveValue::NotSet,
                            service: sea_orm::ActiveValue::NotSet,
                            token_iden: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.token = (&default.token).default_value();
                        default.token_type = (&default.token_type).default_value();
                        default.token_expiration = (&default.token_expiration)
                            .default_value();
                        default.service = (&default.service).default_value();
                        default.token_iden = (&default.token_iden).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Token => {
                                self.token.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenType => {
                                self.token_type.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenExpiration => {
                                self.token_expiration.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Service => {
                                self.service.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TokenIden => {
                                self.token_iden.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.token {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("token".to_owned()));
                        }
                        if match a.token_type {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("token_type".to_owned()),
                            );
                        }
                        if match a.token_expiration {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("token_expiration".to_owned()),
                            );
                        }
                        if match a.service {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("service".to_owned()));
                        }
                        if match a.token_iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("token_iden".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            token: a.token.into_value().unwrap().unwrap(),
                            token_type: a.token_type.into_value().unwrap().unwrap(),
                            token_expiration: a
                                .token_expiration
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            service: a.service.into_value().unwrap().unwrap(),
                            token_iden: a.token_iden.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                pub fn gen_token() -> String {
                    use uuid::Uuid;
                    let uuid = Uuid::new_v4();
                    uuid.to_string()
                }
                impl DbNodeActiveModel<Model, TokenNode> for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "token"
                    }
                }
            }
            pub mod user {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::error::CoreError;
                use crate::graph::node::user::UserNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                #[sea_orm(table_name = "node_user")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub user_name: String,
                    pub user_email: String,
                    pub user_password: String,
                    pub user_avatar: String,
                    pub user_creation_time: DateTime,
                    pub user_creation_order: i64,
                    pub user_last_login_time: DateTime,
                    pub user_description: Option<String>,
                    pub user_iden: String,
                    pub user_bio: Option<String>,
                    pub user_profile_show: Option<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            user_name: ::core::clone::Clone::clone(&self.user_name),
                            user_email: ::core::clone::Clone::clone(&self.user_email),
                            user_password: ::core::clone::Clone::clone(
                                &self.user_password,
                            ),
                            user_avatar: ::core::clone::Clone::clone(&self.user_avatar),
                            user_creation_time: ::core::clone::Clone::clone(
                                &self.user_creation_time,
                            ),
                            user_creation_order: ::core::clone::Clone::clone(
                                &self.user_creation_order,
                            ),
                            user_last_login_time: ::core::clone::Clone::clone(
                                &self.user_last_login_time,
                            ),
                            user_description: ::core::clone::Clone::clone(
                                &self.user_description,
                            ),
                            user_iden: ::core::clone::Clone::clone(&self.user_iden),
                            user_bio: ::core::clone::Clone::clone(&self.user_bio),
                            user_profile_show: ::core::clone::Clone::clone(
                                &self.user_profile_show,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "user_name",
                            "user_email",
                            "user_password",
                            "user_avatar",
                            "user_creation_time",
                            "user_creation_order",
                            "user_last_login_time",
                            "user_description",
                            "user_iden",
                            "user_bio",
                            "user_profile_show",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.user_name,
                            &self.user_email,
                            &self.user_password,
                            &self.user_avatar,
                            &self.user_creation_time,
                            &self.user_creation_order,
                            &self.user_last_login_time,
                            &self.user_description,
                            &self.user_iden,
                            &self.user_bio,
                            &&self.user_profile_show,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id
                            && self.user_creation_order == other.user_creation_order
                            && self.user_name == other.user_name
                            && self.user_email == other.user_email
                            && self.user_password == other.user_password
                            && self.user_avatar == other.user_avatar
                            && self.user_creation_time == other.user_creation_time
                            && self.user_last_login_time == other.user_last_login_time
                            && self.user_description == other.user_description
                            && self.user_iden == other.user_iden
                            && self.user_bio == other.user_bio
                            && self.user_profile_show == other.user_profile_show
                    }
                }
                #[automatically_derived]
                impl ::core::cmp::Eq for Model {
                    #[inline]
                    #[doc(hidden)]
                    #[coverage(off)]
                    fn assert_receiver_is_total_eq(&self) -> () {
                        let _: ::core::cmp::AssertParamIsEq<i64>;
                        let _: ::core::cmp::AssertParamIsEq<String>;
                        let _: ::core::cmp::AssertParamIsEq<DateTime>;
                        let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                        let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                        let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    UserName,
                    /// Generated by sea-orm-macros
                    UserEmail,
                    /// Generated by sea-orm-macros
                    UserPassword,
                    /// Generated by sea-orm-macros
                    UserAvatar,
                    /// Generated by sea-orm-macros
                    UserCreationTime,
                    /// Generated by sea-orm-macros
                    UserCreationOrder,
                    /// Generated by sea-orm-macros
                    UserLastLoginTime,
                    /// Generated by sea-orm-macros
                    UserDescription,
                    /// Generated by sea-orm-macros
                    UserIden,
                    /// Generated by sea-orm-macros
                    UserBio,
                    /// Generated by sea-orm-macros
                    UserProfileShow,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::UserName => "UserName",
                                Column::UserEmail => "UserEmail",
                                Column::UserPassword => "UserPassword",
                                Column::UserAvatar => "UserAvatar",
                                Column::UserCreationTime => "UserCreationTime",
                                Column::UserCreationOrder => "UserCreationOrder",
                                Column::UserLastLoginTime => "UserLastLoginTime",
                                Column::UserDescription => "UserDescription",
                                Column::UserIden => "UserIden",
                                Column::UserBio => "UserBio",
                                Column::UserProfileShow => "UserProfileShow",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::UserName),
                            2usize => ::core::option::Option::Some(Column::UserEmail),
                            3usize => ::core::option::Option::Some(Column::UserPassword),
                            4usize => ::core::option::Option::Some(Column::UserAvatar),
                            5usize => {
                                ::core::option::Option::Some(Column::UserCreationTime)
                            }
                            6usize => {
                                ::core::option::Option::Some(Column::UserCreationOrder)
                            }
                            7usize => {
                                ::core::option::Option::Some(Column::UserLastLoginTime)
                            }
                            8usize => {
                                ::core::option::Option::Some(Column::UserDescription)
                            }
                            9usize => ::core::option::Option::Some(Column::UserIden),
                            10usize => ::core::option::Option::Some(Column::UserBio),
                            11usize => {
                                ::core::option::Option::Some(Column::UserProfileShow)
                            }
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 12usize {
                            0
                        } else {
                            12usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 12usize {
                            self.idx = 12usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 12usize {
                            self.back_idx = 12usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 12usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::UserName => "user_name",
                            Self::UserEmail => "user_email",
                            Self::UserPassword => "user_password",
                            Self::UserAvatar => "user_avatar",
                            Self::UserCreationTime => "user_creation_time",
                            Self::UserCreationOrder => "user_creation_order",
                            Self::UserLastLoginTime => "user_last_login_time",
                            Self::UserDescription => "user_description",
                            Self::UserIden => "user_iden",
                            Self::UserBio => "user_bio",
                            Self::UserProfileShow => "user_profile_show",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "user_name" | "userName" | "user_name" => {
                                Ok(Column::UserName)
                            }
                            "user_email" | "userEmail" | "user_email" => {
                                Ok(Column::UserEmail)
                            }
                            "user_password" | "userPassword" | "user_password" => {
                                Ok(Column::UserPassword)
                            }
                            "user_avatar" | "userAvatar" | "user_avatar" => {
                                Ok(Column::UserAvatar)
                            }
                            "user_creation_time" | "userCreationTime"
                            | "user_creation_time" => Ok(Column::UserCreationTime),
                            "user_creation_order" | "userCreationOrder"
                            | "user_creation_order" => Ok(Column::UserCreationOrder),
                            "user_last_login_time" | "userLastLoginTime"
                            | "user_last_login_time" => Ok(Column::UserLastLoginTime),
                            "user_description" | "userDescription"
                            | "user_description" => Ok(Column::UserDescription),
                            "user_iden" | "userIden" | "user_iden" => {
                                Ok(Column::UserIden)
                            }
                            "user_bio" | "userBio" | "user_bio" => Ok(Column::UserBio),
                            "user_profile_show" | "userProfileShow"
                            | "user_profile_show" => Ok(Column::UserProfileShow),
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UserName => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::UserEmail => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::UserPassword => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::UserAvatar => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::UserCreationTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::UserCreationOrder => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::UserLastLoginTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::UserDescription => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                        sea_orm::prelude::ColumnType::string(None),
                                    )
                                    .nullable()
                            }
                            Self::UserIden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::UserBio => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                        sea_orm::prelude::ColumnType::string(None),
                                    )
                                    .nullable()
                            }
                            Self::UserProfileShow => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                        sea_orm::prelude::ColumnType::string(None),
                                    )
                                    .nullable()
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserName => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserEmail => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserPassword => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserAvatar => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserCreationTime => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserCreationOrder => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserLastLoginTime => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserDescription => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserIden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserBio => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::UserProfileShow => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_user"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            user_name: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserName,
                                        )
                                        .into(),
                                )?,
                            user_email: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserEmail,
                                        )
                                        .into(),
                                )?,
                            user_password: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserPassword,
                                        )
                                        .into(),
                                )?,
                            user_avatar: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserAvatar,
                                        )
                                        .into(),
                                )?,
                            user_creation_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserCreationTime,
                                        )
                                        .into(),
                                )?,
                            user_creation_order: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserCreationOrder,
                                        )
                                        .into(),
                                )?,
                            user_last_login_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserLastLoginTime,
                                        )
                                        .into(),
                                )?,
                            user_description: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserDescription,
                                        )
                                        .into(),
                                )?,
                            user_iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserIden,
                                        )
                                        .into(),
                                )?,
                            user_bio: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserBio,
                                        )
                                        .into(),
                                )?,
                            user_profile_show: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UserProfileShow,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserName => {
                                self.user_name.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserEmail => {
                                self.user_email.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserPassword => {
                                self.user_password.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserAvatar => {
                                self.user_avatar.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserCreationTime => {
                                self.user_creation_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserCreationOrder => {
                                self.user_creation_order.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserLastLoginTime => {
                                self.user_last_login_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserDescription => {
                                self.user_description.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserIden => {
                                self.user_iden.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserBio => {
                                self.user_bio.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserProfileShow => {
                                self.user_profile_show.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserName => {
                                self.user_name = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserEmail => {
                                self.user_email = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserPassword => {
                                self.user_password = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserAvatar => {
                                self.user_avatar = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserCreationTime => {
                                self.user_creation_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserCreationOrder => {
                                self.user_creation_order = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserLastLoginTime => {
                                self.user_last_login_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserDescription => {
                                self.user_description = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserIden => {
                                self.user_iden = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserBio => {
                                self.user_bio = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::UserProfileShow => {
                                self.user_profile_show = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub user_name: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub user_email: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub user_password: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub user_avatar: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub user_creation_time: sea_orm::ActiveValue<DateTime>,
                    /// Generated by sea-orm-macros
                    pub user_creation_order: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub user_last_login_time: sea_orm::ActiveValue<DateTime>,
                    /// Generated by sea-orm-macros
                    pub user_description: sea_orm::ActiveValue<Option<String>>,
                    /// Generated by sea-orm-macros
                    pub user_iden: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub user_bio: sea_orm::ActiveValue<Option<String>>,
                    /// Generated by sea-orm-macros
                    pub user_profile_show: sea_orm::ActiveValue<Option<String>>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            user_name: ::core::clone::Clone::clone(&self.user_name),
                            user_email: ::core::clone::Clone::clone(&self.user_email),
                            user_password: ::core::clone::Clone::clone(
                                &self.user_password,
                            ),
                            user_avatar: ::core::clone::Clone::clone(&self.user_avatar),
                            user_creation_time: ::core::clone::Clone::clone(
                                &self.user_creation_time,
                            ),
                            user_creation_order: ::core::clone::Clone::clone(
                                &self.user_creation_order,
                            ),
                            user_last_login_time: ::core::clone::Clone::clone(
                                &self.user_last_login_time,
                            ),
                            user_description: ::core::clone::Clone::clone(
                                &self.user_description,
                            ),
                            user_iden: ::core::clone::Clone::clone(&self.user_iden),
                            user_bio: ::core::clone::Clone::clone(&self.user_bio),
                            user_profile_show: ::core::clone::Clone::clone(
                                &self.user_profile_show,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "user_name",
                            "user_email",
                            "user_password",
                            "user_avatar",
                            "user_creation_time",
                            "user_creation_order",
                            "user_last_login_time",
                            "user_description",
                            "user_iden",
                            "user_bio",
                            "user_profile_show",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.user_name,
                            &self.user_email,
                            &self.user_password,
                            &self.user_avatar,
                            &self.user_creation_time,
                            &self.user_creation_order,
                            &self.user_last_login_time,
                            &self.user_description,
                            &self.user_iden,
                            &self.user_bio,
                            &&self.user_profile_show,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id
                            && self.user_name == other.user_name
                            && self.user_email == other.user_email
                            && self.user_password == other.user_password
                            && self.user_avatar == other.user_avatar
                            && self.user_creation_time == other.user_creation_time
                            && self.user_creation_order == other.user_creation_order
                            && self.user_last_login_time == other.user_last_login_time
                            && self.user_description == other.user_description
                            && self.user_iden == other.user_iden
                            && self.user_bio == other.user_bio
                            && self.user_profile_show == other.user_profile_show
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            user_name: sea_orm::ActiveValue::Unchanged(m.user_name),
                            user_email: sea_orm::ActiveValue::Unchanged(m.user_email),
                            user_password: sea_orm::ActiveValue::Unchanged(
                                m.user_password,
                            ),
                            user_avatar: sea_orm::ActiveValue::Unchanged(m.user_avatar),
                            user_creation_time: sea_orm::ActiveValue::Unchanged(
                                m.user_creation_time,
                            ),
                            user_creation_order: sea_orm::ActiveValue::Unchanged(
                                m.user_creation_order,
                            ),
                            user_last_login_time: sea_orm::ActiveValue::Unchanged(
                                m.user_last_login_time,
                            ),
                            user_description: sea_orm::ActiveValue::Unchanged(
                                m.user_description,
                            ),
                            user_iden: sea_orm::ActiveValue::Unchanged(m.user_iden),
                            user_bio: sea_orm::ActiveValue::Unchanged(m.user_bio),
                            user_profile_show: sea_orm::ActiveValue::Unchanged(
                                m.user_profile_show,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserName => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_name);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserEmail => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_email);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserPassword => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_password);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserAvatar => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_avatar);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_creation_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationOrder => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_creation_order);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserLastLoginTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_last_login_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserDescription => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_description);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserIden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_iden);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserBio => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_bio);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserProfileShow => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.user_profile_show);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserName => {
                                self.user_name.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserEmail => {
                                self.user_email.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserPassword => {
                                self.user_password.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserAvatar => {
                                self.user_avatar.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationTime => {
                                self.user_creation_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationOrder => {
                                self.user_creation_order.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserLastLoginTime => {
                                self.user_last_login_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserDescription => {
                                self.user_description.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserIden => {
                                self.user_iden.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserBio => {
                                self.user_bio.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserProfileShow => {
                                self.user_profile_show.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserName => {
                                self.user_name = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserEmail => {
                                self.user_email = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserPassword => {
                                self.user_password = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserAvatar => {
                                self.user_avatar = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationTime => {
                                self.user_creation_time = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationOrder => {
                                self.user_creation_order = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserLastLoginTime => {
                                self.user_last_login_time = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserDescription => {
                                self.user_description = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserIden => {
                                self.user_iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserBio => {
                                self.user_bio = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserProfileShow => {
                                self.user_profile_show = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserName => {
                                self.user_name = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserEmail => {
                                self.user_email = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserPassword => {
                                self.user_password = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserAvatar => {
                                self.user_avatar = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationTime => {
                                self.user_creation_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationOrder => {
                                self.user_creation_order = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserLastLoginTime => {
                                self.user_last_login_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserDescription => {
                                self.user_description = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserIden => {
                                self.user_iden = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserBio => {
                                self.user_bio = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserProfileShow => {
                                self.user_profile_show = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserName => {
                                self.user_name.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserEmail => {
                                self.user_email.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserPassword => {
                                self.user_password.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserAvatar => {
                                self.user_avatar.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationTime => {
                                self.user_creation_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationOrder => {
                                self.user_creation_order.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserLastLoginTime => {
                                self.user_last_login_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserDescription => {
                                self.user_description.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserIden => {
                                self.user_iden.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserBio => {
                                self.user_bio.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserProfileShow => {
                                self.user_profile_show.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            user_name: sea_orm::ActiveValue::NotSet,
                            user_email: sea_orm::ActiveValue::NotSet,
                            user_password: sea_orm::ActiveValue::NotSet,
                            user_avatar: sea_orm::ActiveValue::NotSet,
                            user_creation_time: sea_orm::ActiveValue::NotSet,
                            user_creation_order: sea_orm::ActiveValue::NotSet,
                            user_last_login_time: sea_orm::ActiveValue::NotSet,
                            user_description: sea_orm::ActiveValue::NotSet,
                            user_iden: sea_orm::ActiveValue::NotSet,
                            user_bio: sea_orm::ActiveValue::NotSet,
                            user_profile_show: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.user_name = (&default.user_name).default_value();
                        default.user_email = (&default.user_email).default_value();
                        default.user_password = (&default.user_password).default_value();
                        default.user_avatar = (&default.user_avatar).default_value();
                        default.user_creation_time = (&default.user_creation_time)
                            .default_value();
                        default.user_creation_order = (&default.user_creation_order)
                            .default_value();
                        default.user_last_login_time = (&default.user_last_login_time)
                            .default_value();
                        default.user_description = (&default.user_description)
                            .default_value();
                        default.user_iden = (&default.user_iden).default_value();
                        default.user_bio = (&default.user_bio).default_value();
                        default.user_profile_show = (&default.user_profile_show)
                            .default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserName => {
                                self.user_name.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserEmail => {
                                self.user_email.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserPassword => {
                                self.user_password.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserAvatar => {
                                self.user_avatar.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationTime => {
                                self.user_creation_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserCreationOrder => {
                                self.user_creation_order.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserLastLoginTime => {
                                self.user_last_login_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserDescription => {
                                self.user_description.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserIden => {
                                self.user_iden.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserBio => {
                                self.user_bio.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::UserProfileShow => {
                                self.user_profile_show.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.user_name {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_name".to_owned()),
                            );
                        }
                        if match a.user_email {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_email".to_owned()),
                            );
                        }
                        if match a.user_password {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_password".to_owned()),
                            );
                        }
                        if match a.user_avatar {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_avatar".to_owned()),
                            );
                        }
                        if match a.user_creation_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_creation_time".to_owned()),
                            );
                        }
                        if match a.user_creation_order {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_creation_order".to_owned()),
                            );
                        }
                        if match a.user_last_login_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet(
                                    "user_last_login_time".to_owned(),
                                ),
                            );
                        }
                        if match a.user_description {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_description".to_owned()),
                            );
                        }
                        if match a.user_iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_iden".to_owned()),
                            );
                        }
                        if match a.user_bio {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_bio".to_owned()),
                            );
                        }
                        if match a.user_profile_show {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("user_profile_show".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            user_name: a.user_name.into_value().unwrap().unwrap(),
                            user_email: a.user_email.into_value().unwrap().unwrap(),
                            user_password: a
                                .user_password
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            user_avatar: a.user_avatar.into_value().unwrap().unwrap(),
                            user_creation_time: a
                                .user_creation_time
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            user_creation_order: a
                                .user_creation_order
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            user_last_login_time: a
                                .user_last_login_time
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            user_description: a
                                .user_description
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            user_iden: a.user_iden.into_value().unwrap().unwrap(),
                            user_bio: a.user_bio.into_value().unwrap().unwrap(),
                            user_profile_show: a
                                .user_profile_show
                                .into_value()
                                .unwrap()
                                .unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "user"
                    }
                }
                impl DbNodeActiveModel<Model, UserNode> for ActiveModel {}
                pub async fn check_iden_exists(
                    db: &DatabaseConnection,
                    iden: &str,
                ) -> Result<bool, CoreError> {
                    use sea_orm::EntityTrait;
                    let exists = Entity::find()
                        .filter(Column::UserIden.eq(iden))
                        .one(db)
                        .await?
                        .is_some();
                    Ok(exists)
                }
                pub async fn check_email_exists(
                    db: &DatabaseConnection,
                    email: &str,
                ) -> Result<bool, CoreError> {
                    use sea_orm::EntityTrait;
                    let exists = Entity::find()
                        .filter(Column::UserEmail.eq(email))
                        .one(db)
                        .await?
                        .is_some();
                    Ok(exists)
                }
                pub async fn get_user_by_iden(
                    db: &DatabaseConnection,
                    iden: &str,
                ) -> Result<Model, CoreError> {
                    use sea_orm::EntityTrait;
                    let user = Entity::find()
                        .filter(Column::UserIden.eq(iden))
                        .one(db)
                        .await?;
                    if user.is_none() {
                        return Err(CoreError::UserNotFound);
                    }
                    Ok(user.unwrap())
                }
                pub async fn get_user_by_email(
                    db: &DatabaseConnection,
                    email: &str,
                ) -> Result<Model, CoreError> {
                    use sea_orm::EntityTrait;
                    let user = Entity::find()
                        .filter(Column::UserEmail.eq(email))
                        .one(db)
                        .await?;
                    if user.is_none() {
                        return Err(CoreError::UserNotFound);
                    }
                    Ok(user.unwrap())
                }
                pub async fn get_user_by_nodeid(
                    db: &DatabaseConnection,
                    node_id: i64,
                ) -> Result<Model, CoreError> {
                    use sea_orm::EntityTrait;
                    let user = Entity::find()
                        .filter(Column::NodeId.eq(node_id))
                        .one(db)
                        .await?;
                    if user.is_none() {
                        return Err(CoreError::UserNotFound);
                    }
                    Ok(user.unwrap())
                }
                pub async fn get_guest_user_node(
                    db: &DatabaseConnection,
                ) -> Result<i64, CoreError> {
                    use sea_orm::EntityTrait;
                    let guest_user = Entity::find()
                        .filter(Column::UserIden.eq("guest"))
                        .one(db)
                        .await?;
                    if let Some(user) = guest_user {
                        Ok(user.node_id)
                    } else {
                        Err(CoreError::UserNotFound)
                    }
                }
            }
            pub mod testcase {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use chrono::{NaiveDate, NaiveDateTime};
                use sea_orm::entity::prelude::*;
                use sea_orm::{DeriveEntityModel, DeriveRelation, EnumIter};
                use crate::graph::node::record::testcase::TestcaseNode;
                #[sea_orm(table_name = "node_testcase")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub time_limit: i64,
                    pub memory_limit: i64,
                    pub in_file: i64,
                    pub out_file: i64,
                    pub io_method: String,
                    pub diff_method: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            in_file: ::core::clone::Clone::clone(&self.in_file),
                            out_file: ::core::clone::Clone::clone(&self.out_file),
                            io_method: ::core::clone::Clone::clone(&self.io_method),
                            diff_method: ::core::clone::Clone::clone(&self.diff_method),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "time_limit",
                            "memory_limit",
                            "in_file",
                            "out_file",
                            "io_method",
                            "diff_method",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.time_limit,
                            &self.memory_limit,
                            &self.in_file,
                            &self.out_file,
                            &self.io_method,
                            &&self.diff_method,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id
                            && self.time_limit == other.time_limit
                            && self.memory_limit == other.memory_limit
                            && self.in_file == other.in_file
                            && self.out_file == other.out_file
                            && self.io_method == other.io_method
                            && self.diff_method == other.diff_method
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    TimeLimit,
                    /// Generated by sea-orm-macros
                    MemoryLimit,
                    /// Generated by sea-orm-macros
                    InFile,
                    /// Generated by sea-orm-macros
                    OutFile,
                    /// Generated by sea-orm-macros
                    IoMethod,
                    /// Generated by sea-orm-macros
                    DiffMethod,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::TimeLimit => "TimeLimit",
                                Column::MemoryLimit => "MemoryLimit",
                                Column::InFile => "InFile",
                                Column::OutFile => "OutFile",
                                Column::IoMethod => "IoMethod",
                                Column::DiffMethod => "DiffMethod",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::TimeLimit),
                            2usize => ::core::option::Option::Some(Column::MemoryLimit),
                            3usize => ::core::option::Option::Some(Column::InFile),
                            4usize => ::core::option::Option::Some(Column::OutFile),
                            5usize => ::core::option::Option::Some(Column::IoMethod),
                            6usize => ::core::option::Option::Some(Column::DiffMethod),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 7usize {
                            0
                        } else {
                            7usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 7usize {
                            self.idx = 7usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 7usize {
                            self.back_idx = 7usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 7usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::TimeLimit => "time_limit",
                            Self::MemoryLimit => "memory_limit",
                            Self::InFile => "in_file",
                            Self::OutFile => "out_file",
                            Self::IoMethod => "io_method",
                            Self::DiffMethod => "diff_method",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "time_limit" | "timeLimit" | "time_limit" => {
                                Ok(Column::TimeLimit)
                            }
                            "memory_limit" | "memoryLimit" | "memory_limit" => {
                                Ok(Column::MemoryLimit)
                            }
                            "in_file" | "inFile" | "in_file" => Ok(Column::InFile),
                            "out_file" | "outFile" | "out_file" => Ok(Column::OutFile),
                            "io_method" | "ioMethod" | "io_method" => {
                                Ok(Column::IoMethod)
                            }
                            "diff_method" | "diffMethod" | "diff_method" => {
                                Ok(Column::DiffMethod)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::TimeLimit => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::MemoryLimit => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::InFile => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::OutFile => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::IoMethod => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::DiffMethod => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TimeLimit => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::MemoryLimit => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::InFile => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::OutFile => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::IoMethod => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::DiffMethod => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_testcase"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            time_limit: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit,
                                        )
                                        .into(),
                                )?,
                            memory_limit: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit,
                                        )
                                        .into(),
                                )?,
                            in_file: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::InFile,
                                        )
                                        .into(),
                                )?,
                            out_file: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::OutFile,
                                        )
                                        .into(),
                                )?,
                            io_method: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::IoMethod,
                                        )
                                        .into(),
                                )?,
                            diff_method: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::DiffMethod,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::InFile => {
                                self.in_file.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::OutFile => {
                                self.out_file.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::IoMethod => {
                                self.io_method.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::DiffMethod => {
                                self.diff_method.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::InFile => {
                                self.in_file = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::OutFile => {
                                self.out_file = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::IoMethod => {
                                self.io_method = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::DiffMethod => {
                                self.diff_method = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub time_limit: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub memory_limit: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub in_file: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub out_file: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub io_method: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub diff_method: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            in_file: ::core::clone::Clone::clone(&self.in_file),
                            out_file: ::core::clone::Clone::clone(&self.out_file),
                            io_method: ::core::clone::Clone::clone(&self.io_method),
                            diff_method: ::core::clone::Clone::clone(&self.diff_method),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "time_limit",
                            "memory_limit",
                            "in_file",
                            "out_file",
                            "io_method",
                            "diff_method",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.time_limit,
                            &self.memory_limit,
                            &self.in_file,
                            &self.out_file,
                            &self.io_method,
                            &&self.diff_method,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id
                            && self.time_limit == other.time_limit
                            && self.memory_limit == other.memory_limit
                            && self.in_file == other.in_file
                            && self.out_file == other.out_file
                            && self.io_method == other.io_method
                            && self.diff_method == other.diff_method
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            time_limit: sea_orm::ActiveValue::Unchanged(m.time_limit),
                            memory_limit: sea_orm::ActiveValue::Unchanged(
                                m.memory_limit,
                            ),
                            in_file: sea_orm::ActiveValue::Unchanged(m.in_file),
                            out_file: sea_orm::ActiveValue::Unchanged(m.out_file),
                            io_method: sea_orm::ActiveValue::Unchanged(m.io_method),
                            diff_method: sea_orm::ActiveValue::Unchanged(m.diff_method),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.time_limit);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.memory_limit);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::InFile => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.in_file);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::OutFile => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.out_file);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::IoMethod => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.io_method);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DiffMethod => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.diff_method);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::InFile => {
                                self.in_file.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::OutFile => {
                                self.out_file.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::IoMethod => {
                                self.io_method.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DiffMethod => {
                                self.diff_method.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::InFile => {
                                self.in_file = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::OutFile => {
                                self.out_file = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::IoMethod => {
                                self.io_method = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DiffMethod => {
                                self.diff_method = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::InFile => {
                                self.in_file = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::OutFile => {
                                self.out_file = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::IoMethod => {
                                self.io_method = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DiffMethod => {
                                self.diff_method = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::InFile => {
                                self.in_file.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::OutFile => {
                                self.out_file.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::IoMethod => {
                                self.io_method.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DiffMethod => {
                                self.diff_method.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            time_limit: sea_orm::ActiveValue::NotSet,
                            memory_limit: sea_orm::ActiveValue::NotSet,
                            in_file: sea_orm::ActiveValue::NotSet,
                            out_file: sea_orm::ActiveValue::NotSet,
                            io_method: sea_orm::ActiveValue::NotSet,
                            diff_method: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.time_limit = (&default.time_limit).default_value();
                        default.memory_limit = (&default.memory_limit).default_value();
                        default.in_file = (&default.in_file).default_value();
                        default.out_file = (&default.out_file).default_value();
                        default.io_method = (&default.io_method).default_value();
                        default.diff_method = (&default.diff_method).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TimeLimit => {
                                self.time_limit.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::MemoryLimit => {
                                self.memory_limit.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::InFile => {
                                self.in_file.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::OutFile => {
                                self.out_file.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::IoMethod => {
                                self.io_method.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DiffMethod => {
                                self.diff_method.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.time_limit {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("time_limit".to_owned()),
                            );
                        }
                        if match a.memory_limit {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("memory_limit".to_owned()),
                            );
                        }
                        if match a.in_file {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("in_file".to_owned()));
                        }
                        if match a.out_file {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("out_file".to_owned()),
                            );
                        }
                        if match a.io_method {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("io_method".to_owned()),
                            );
                        }
                        if match a.diff_method {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("diff_method".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            time_limit: a.time_limit.into_value().unwrap().unwrap(),
                            memory_limit: a.memory_limit.into_value().unwrap().unwrap(),
                            in_file: a.in_file.into_value().unwrap().unwrap(),
                            out_file: a.out_file.into_value().unwrap().unwrap(),
                            io_method: a.io_method.into_value().unwrap().unwrap(),
                            diff_method: a.diff_method.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "record"
                    }
                }
                impl DbNodeActiveModel<Model, TestcaseNode> for ActiveModel {}
            }
            pub mod training {
                use crate::db::entity::node::{DbNodeActiveModel, DbNodeInfo};
                use crate::graph::node::training::TrainingNode;
                use sea_orm::entity::prelude::*;
                use sea_orm::{
                    DeriveEntityModel, DeriveRelation, EnumIter, FromJsonQueryResult,
                };
                use serde::{Deserialize, Serialize};
                #[sea_orm(table_name = "node_training")]
                pub struct Model {
                    #[sea_orm(primary_key)]
                    pub node_id: i64,
                    pub name: String,
                    pub iden: String,
                    pub description_public: String,
                    pub description_private: String,
                    pub start_time: DateTime,
                    pub end_time: DateTime,
                    pub training_type: String,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Model {
                    #[inline]
                    fn clone(&self) -> Model {
                        Model {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            name: ::core::clone::Clone::clone(&self.name),
                            iden: ::core::clone::Clone::clone(&self.iden),
                            description_public: ::core::clone::Clone::clone(
                                &self.description_public,
                            ),
                            description_private: ::core::clone::Clone::clone(
                                &self.description_private,
                            ),
                            start_time: ::core::clone::Clone::clone(&self.start_time),
                            end_time: ::core::clone::Clone::clone(&self.end_time),
                            training_type: ::core::clone::Clone::clone(
                                &self.training_type,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Model {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "name",
                            "iden",
                            "description_public",
                            "description_private",
                            "start_time",
                            "end_time",
                            "training_type",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.name,
                            &self.iden,
                            &self.description_public,
                            &self.description_private,
                            &self.start_time,
                            &self.end_time,
                            &&self.training_type,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "Model",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Model {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for Model {
                    #[inline]
                    fn eq(&self, other: &Model) -> bool {
                        self.node_id == other.node_id && self.name == other.name
                            && self.iden == other.iden
                            && self.description_public == other.description_public
                            && self.description_private == other.description_private
                            && self.start_time == other.start_time
                            && self.end_time == other.end_time
                            && self.training_type == other.training_type
                    }
                }
                /// Generated by sea-orm-macros
                pub enum Column {
                    /// Generated by sea-orm-macros
                    NodeId,
                    /// Generated by sea-orm-macros
                    Name,
                    /// Generated by sea-orm-macros
                    Iden,
                    /// Generated by sea-orm-macros
                    DescriptionPublic,
                    /// Generated by sea-orm-macros
                    DescriptionPrivate,
                    /// Generated by sea-orm-macros
                    StartTime,
                    /// Generated by sea-orm-macros
                    EndTime,
                    /// Generated by sea-orm-macros
                    TrainingType,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Column {}
                #[automatically_derived]
                impl ::core::clone::Clone for Column {
                    #[inline]
                    fn clone(&self) -> Column {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Column {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                Column::NodeId => "NodeId",
                                Column::Name => "Name",
                                Column::Iden => "Iden",
                                Column::DescriptionPublic => "DescriptionPublic",
                                Column::DescriptionPrivate => "DescriptionPrivate",
                                Column::StartTime => "StartTime",
                                Column::EndTime => "EndTime",
                                Column::TrainingType => "TrainingType",
                            },
                        )
                    }
                }
                ///An iterator over the variants of [Column]
                #[allow(missing_copy_implementations)]
                pub struct ColumnIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for ColumnIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ColumnIter").field("len", &self.len()).finish()
                    }
                }
                impl ColumnIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Column> {
                        match idx {
                            0usize => ::core::option::Option::Some(Column::NodeId),
                            1usize => ::core::option::Option::Some(Column::Name),
                            2usize => ::core::option::Option::Some(Column::Iden),
                            3usize => {
                                ::core::option::Option::Some(Column::DescriptionPublic)
                            }
                            4usize => {
                                ::core::option::Option::Some(Column::DescriptionPrivate)
                            }
                            5usize => ::core::option::Option::Some(Column::StartTime),
                            6usize => ::core::option::Option::Some(Column::EndTime),
                            7usize => ::core::option::Option::Some(Column::TrainingType),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Column {
                    type Iterator = ColumnIter;
                    fn iter() -> ColumnIter {
                        ColumnIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for ColumnIter {
                    type Item = Column;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 8usize {
                            0
                        } else {
                            8usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 8usize {
                            self.idx = 8usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            ColumnIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for ColumnIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for ColumnIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 8usize {
                            self.back_idx = 8usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            ColumnIter::get(self, 8usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for ColumnIter {}
                impl Clone for ColumnIter {
                    fn clone(&self) -> ColumnIter {
                        ColumnIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl Column {
                    fn default_as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                            Self::Name => "name",
                            Self::Iden => "iden",
                            Self::DescriptionPublic => "description_public",
                            Self::DescriptionPrivate => "description_private",
                            Self::StartTime => "start_time",
                            Self::EndTime => "end_time",
                            Self::TrainingType => "training_type",
                        }
                    }
                }
                #[automatically_derived]
                impl std::str::FromStr for Column {
                    type Err = sea_orm::ColumnFromStrErr;
                    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                        match s {
                            "node_id" | "nodeId" | "node_id" => Ok(Column::NodeId),
                            "name" | "name" | "name" => Ok(Column::Name),
                            "iden" | "iden" | "iden" => Ok(Column::Iden),
                            "description_public" | "descriptionPublic"
                            | "description_public" => Ok(Column::DescriptionPublic),
                            "description_private" | "descriptionPrivate"
                            | "description_private" => Ok(Column::DescriptionPrivate),
                            "start_time" | "startTime" | "start_time" => {
                                Ok(Column::StartTime)
                            }
                            "end_time" | "endTime" | "end_time" => Ok(Column::EndTime),
                            "training_type" | "trainingType" | "training_type" => {
                                Ok(Column::TrainingType)
                            }
                            _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for Column {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Column {
                    fn as_str(&self) -> &str {
                        self.default_as_str()
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::ColumnTrait for Column {
                    type EntityName = Entity;
                    fn def(&self) -> sea_orm::prelude::ColumnDef {
                        match self {
                            Self::NodeId => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::BigInteger,
                                )
                            }
                            Self::Name => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::Iden => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::DescriptionPublic => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::DescriptionPrivate => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                            Self::StartTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::EndTime => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::DateTime,
                                )
                            }
                            Self::TrainingType => {
                                sea_orm::prelude::ColumnTypeTrait::def(
                                    sea_orm::prelude::ColumnType::string(None),
                                )
                            }
                        }
                    }
                    fn enum_type_name(&self) -> Option<&'static str> {
                        match self {
                            Self::NodeId => {
                                <i64 as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Name => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::Iden => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::DescriptionPublic => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::DescriptionPrivate => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::StartTime => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::EndTime => {
                                <DateTime as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                            Self::TrainingType => {
                                <String as sea_orm::sea_query::ValueType>::enum_type_name()
                            }
                        }
                    }
                    fn select_as(
                        &self,
                        expr: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => {
                                sea_orm::prelude::ColumnTrait::select_enum_as(self, expr)
                            }
                        }
                    }
                    fn save_as(
                        &self,
                        val: sea_orm::sea_query::Expr,
                    ) -> sea_orm::sea_query::SimpleExpr {
                        match self {
                            _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct Entity;
                #[automatically_derived]
                impl ::core::marker::Copy for Entity {}
                #[automatically_derived]
                impl ::core::clone::Clone for Entity {
                    #[inline]
                    fn clone(&self) -> Entity {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::default::Default for Entity {
                    #[inline]
                    fn default() -> Entity {
                        Entity {}
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Entity {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "Entity")
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::EntityTrait for Entity {
                    type Model = Model;
                    type ActiveModel = ActiveModel;
                    type Column = Column;
                    type PrimaryKey = PrimaryKey;
                    type Relation = Relation;
                }
                #[automatically_derived]
                impl sea_orm::Iden for Entity {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for Entity {
                    fn as_str(&self) -> &str {
                        <Self as sea_orm::EntityName>::table_name(self)
                    }
                }
                #[automatically_derived]
                impl sea_orm::prelude::EntityName for Entity {
                    fn schema_name(&self) -> Option<&str> {
                        None
                    }
                    fn table_name(&self) -> &str {
                        "node_training"
                    }
                    fn comment(&self) -> Option<&str> {
                        None
                    }
                }
                /// Generated by sea-orm-macros
                pub enum PrimaryKey {
                    /// Generated by sea-orm-macros
                    NodeId,
                }
                #[automatically_derived]
                impl ::core::marker::Copy for PrimaryKey {}
                #[automatically_derived]
                impl ::core::clone::Clone for PrimaryKey {
                    #[inline]
                    fn clone(&self) -> PrimaryKey {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for PrimaryKey {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "NodeId")
                    }
                }
                ///An iterator over the variants of [PrimaryKey]
                #[allow(missing_copy_implementations)]
                pub struct PrimaryKeyIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for PrimaryKeyIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PrimaryKeyIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl PrimaryKeyIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
                        match idx {
                            0usize => ::core::option::Option::Some(PrimaryKey::NodeId),
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
                    type Iterator = PrimaryKeyIter;
                    fn iter() -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for PrimaryKeyIter {
                    type Item = PrimaryKey;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 1usize {
                            0
                        } else {
                            1usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 1usize {
                            self.idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            PrimaryKeyIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for PrimaryKeyIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for PrimaryKeyIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 1usize {
                            self.back_idx = 1usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            PrimaryKeyIter::get(self, 1usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for PrimaryKeyIter {}
                impl Clone for PrimaryKeyIter {
                    fn clone(&self) -> PrimaryKeyIter {
                        PrimaryKeyIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::Iden for PrimaryKey {
                    fn unquoted(&self, s: &mut dyn std::fmt::Write) {
                        s.write_fmt(
                                format_args!("{0}", sea_orm::IdenStatic::as_str(self)),
                            )
                            .unwrap();
                    }
                }
                #[automatically_derived]
                impl sea_orm::IdenStatic for PrimaryKey {
                    fn as_str(&self) -> &str {
                        match self {
                            Self::NodeId => "node_id",
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
                    type Column = Column;
                    fn into_column(self) -> Self::Column {
                        match self {
                            Self::NodeId => Self::Column::NodeId,
                        }
                    }
                    fn from_column(col: Self::Column) -> Option<Self> {
                        match col {
                            Self::Column::NodeId => Some(Self::NodeId),
                            _ => None,
                        }
                    }
                }
                #[automatically_derived]
                impl PrimaryKeyTrait for PrimaryKey {
                    type ValueType = i64;
                    fn auto_increment() -> bool {
                        true
                    }
                }
                #[automatically_derived]
                impl sea_orm::FromQueryResult for Model {
                    fn from_query_result(
                        row: &sea_orm::QueryResult,
                        pre: &str,
                    ) -> std::result::Result<Self, sea_orm::DbErr> {
                        Ok(Self {
                            node_id: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::NodeId,
                                        )
                                        .into(),
                                )?,
                            name: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Name,
                                        )
                                        .into(),
                                )?,
                            iden: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Iden,
                                        )
                                        .into(),
                                )?,
                            description_public: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::DescriptionPublic,
                                        )
                                        .into(),
                                )?,
                            description_private: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::DescriptionPrivate,
                                        )
                                        .into(),
                                )?,
                            start_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::StartTime,
                                        )
                                        .into(),
                                )?,
                            end_time: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::EndTime,
                                        )
                                        .into(),
                                )?,
                            training_type: row
                                .try_get(
                                    pre,
                                    sea_orm::IdenStatic::as_str(
                                            &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::TrainingType,
                                        )
                                        .into(),
                                )?,
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::ModelTrait for Model {
                    type Entity = Entity;
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                    ) -> sea_orm::Value {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                                self.name.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::DescriptionPublic => {
                                self.description_public.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::DescriptionPrivate => {
                                self.description_private.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::StartTime => {
                                self.start_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EndTime => {
                                self.end_time.clone().into()
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TrainingType => {
                                self.training_type.clone().into()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::NodeId => {
                                self.node_id = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                                self.name = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::Iden => {
                                self.iden = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::DescriptionPublic => {
                                self.description_public = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::DescriptionPrivate => {
                                self.description_private = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::StartTime => {
                                self.start_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::EndTime => {
                                self.end_time = v.unwrap();
                            }
                            <Self::Entity as sea_orm::entity::EntityTrait>::Column::TrainingType => {
                                self.training_type = v.unwrap();
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("field does not exist on Model"),
                                );
                            }
                        }
                    }
                }
                /// Generated by sea-orm-macros
                pub struct ActiveModel {
                    /// Generated by sea-orm-macros
                    pub node_id: sea_orm::ActiveValue<i64>,
                    /// Generated by sea-orm-macros
                    pub name: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub iden: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub description_public: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub description_private: sea_orm::ActiveValue<String>,
                    /// Generated by sea-orm-macros
                    pub start_time: sea_orm::ActiveValue<DateTime>,
                    /// Generated by sea-orm-macros
                    pub end_time: sea_orm::ActiveValue<DateTime>,
                    /// Generated by sea-orm-macros
                    pub training_type: sea_orm::ActiveValue<String>,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ActiveModel {
                    #[inline]
                    fn clone(&self) -> ActiveModel {
                        ActiveModel {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            name: ::core::clone::Clone::clone(&self.name),
                            iden: ::core::clone::Clone::clone(&self.iden),
                            description_public: ::core::clone::Clone::clone(
                                &self.description_public,
                            ),
                            description_private: ::core::clone::Clone::clone(
                                &self.description_private,
                            ),
                            start_time: ::core::clone::Clone::clone(&self.start_time),
                            end_time: ::core::clone::Clone::clone(&self.end_time),
                            training_type: ::core::clone::Clone::clone(
                                &self.training_type,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for ActiveModel {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        let names: &'static _ = &[
                            "node_id",
                            "name",
                            "iden",
                            "description_public",
                            "description_private",
                            "start_time",
                            "end_time",
                            "training_type",
                        ];
                        let values: &[&dyn ::core::fmt::Debug] = &[
                            &self.node_id,
                            &self.name,
                            &self.iden,
                            &self.description_public,
                            &self.description_private,
                            &self.start_time,
                            &self.end_time,
                            &&self.training_type,
                        ];
                        ::core::fmt::Formatter::debug_struct_fields_finish(
                            f,
                            "ActiveModel",
                            names,
                            values,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for ActiveModel {}
                #[automatically_derived]
                impl ::core::cmp::PartialEq for ActiveModel {
                    #[inline]
                    fn eq(&self, other: &ActiveModel) -> bool {
                        self.node_id == other.node_id && self.name == other.name
                            && self.iden == other.iden
                            && self.description_public == other.description_public
                            && self.description_private == other.description_private
                            && self.start_time == other.start_time
                            && self.end_time == other.end_time
                            && self.training_type == other.training_type
                    }
                }
                #[automatically_derived]
                impl std::default::Default for ActiveModel {
                    fn default() -> Self {
                        <Self as sea_orm::ActiveModelBehavior>::new()
                    }
                }
                #[automatically_derived]
                impl std::convert::From<Model> for ActiveModel {
                    fn from(m: Model) -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::Unchanged(m.node_id),
                            name: sea_orm::ActiveValue::Unchanged(m.name),
                            iden: sea_orm::ActiveValue::Unchanged(m.iden),
                            description_public: sea_orm::ActiveValue::Unchanged(
                                m.description_public,
                            ),
                            description_private: sea_orm::ActiveValue::Unchanged(
                                m.description_private,
                            ),
                            start_time: sea_orm::ActiveValue::Unchanged(m.start_time),
                            end_time: sea_orm::ActiveValue::Unchanged(m.end_time),
                            training_type: sea_orm::ActiveValue::Unchanged(
                                m.training_type,
                            ),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::IntoActiveModel<ActiveModel> for Model {
                    fn into_active_model(self) -> ActiveModel {
                        self.into()
                    }
                }
                #[automatically_derived]
                impl sea_orm::ActiveModelTrait for ActiveModel {
                    type Entity = Entity;
                    fn take(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.node_id);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.name);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.iden);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPublic => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.description_public);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPrivate => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.description_private);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.start_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.end_time);
                                value.into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TrainingType => {
                                let mut value = sea_orm::ActiveValue::NotSet;
                                std::mem::swap(&mut value, &mut self.training_type);
                                value.into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn get(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> sea_orm::ActiveValue<sea_orm::Value> {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPublic => {
                                self.description_public.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPrivate => {
                                self.description_private.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                                self.start_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                                self.end_time.clone().into_wrapped_value()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TrainingType => {
                                self.training_type.clone().into_wrapped_value()
                            }
                            _ => sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                        v: sea_orm::Value,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPublic => {
                                self.description_public = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPrivate => {
                                self.description_private = sea_orm::ActiveValue::set(
                                    v.unwrap(),
                                );
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                                self.start_time = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                                self.end_time = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TrainingType => {
                                self.training_type = sea_orm::ActiveValue::set(v.unwrap());
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn not_set(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPublic => {
                                self.description_public = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPrivate => {
                                self.description_private = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                                self.start_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                                self.end_time = sea_orm::ActiveValue::NotSet;
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TrainingType => {
                                self.training_type = sea_orm::ActiveValue::NotSet;
                            }
                            _ => {}
                        }
                    }
                    fn is_not_set(
                        &self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) -> bool {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPublic => {
                                self.description_public.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPrivate => {
                                self.description_private.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                                self.start_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                                self.end_time.is_not_set()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TrainingType => {
                                self.training_type.is_not_set()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                    fn default() -> Self {
                        Self {
                            node_id: sea_orm::ActiveValue::NotSet,
                            name: sea_orm::ActiveValue::NotSet,
                            iden: sea_orm::ActiveValue::NotSet,
                            description_public: sea_orm::ActiveValue::NotSet,
                            description_private: sea_orm::ActiveValue::NotSet,
                            start_time: sea_orm::ActiveValue::NotSet,
                            end_time: sea_orm::ActiveValue::NotSet,
                            training_type: sea_orm::ActiveValue::NotSet,
                        }
                    }
                    fn default_values() -> Self {
                        use sea_orm::value::{
                            DefaultActiveValue, DefaultActiveValueNone,
                            DefaultActiveValueNotSet,
                        };
                        let mut default = <Self as sea_orm::ActiveModelTrait>::default();
                        default.node_id = (&default.node_id).default_value();
                        default.name = (&default.name).default_value();
                        default.iden = (&default.iden).default_value();
                        default.description_public = (&default.description_public)
                            .default_value();
                        default.description_private = (&default.description_private)
                            .default_value();
                        default.start_time = (&default.start_time).default_value();
                        default.end_time = (&default.end_time).default_value();
                        default.training_type = (&default.training_type).default_value();
                        default
                    }
                    fn reset(
                        &mut self,
                        c: <Self::Entity as sea_orm::EntityTrait>::Column,
                    ) {
                        match c {
                            <Self::Entity as sea_orm::EntityTrait>::Column::NodeId => {
                                self.node_id.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                                self.name.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::Iden => {
                                self.iden.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPublic => {
                                self.description_public.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::DescriptionPrivate => {
                                self.description_private.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::StartTime => {
                                self.start_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::EndTime => {
                                self.end_time.reset()
                            }
                            <Self::Entity as sea_orm::EntityTrait>::Column::TrainingType => {
                                self.training_type.reset()
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("This ActiveModel does not have this field"),
                                );
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl std::convert::TryFrom<ActiveModel> for Model {
                    type Error = sea_orm::DbErr;
                    fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
                        if match a.node_id {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("node_id".to_owned()));
                        }
                        if match a.name {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("name".to_owned()));
                        }
                        if match a.iden {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(sea_orm::DbErr::AttrNotSet("iden".to_owned()));
                        }
                        if match a.description_public {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("description_public".to_owned()),
                            );
                        }
                        if match a.description_private {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("description_private".to_owned()),
                            );
                        }
                        if match a.start_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("start_time".to_owned()),
                            );
                        }
                        if match a.end_time {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("end_time".to_owned()),
                            );
                        }
                        if match a.training_type {
                            sea_orm::ActiveValue::NotSet => true,
                            _ => false,
                        } {
                            return Err(
                                sea_orm::DbErr::AttrNotSet("training_type".to_owned()),
                            );
                        }
                        Ok(Self {
                            node_id: a.node_id.into_value().unwrap().unwrap(),
                            name: a.name.into_value().unwrap().unwrap(),
                            iden: a.iden.into_value().unwrap().unwrap(),
                            description_public: a
                                .description_public
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            description_private: a
                                .description_private
                                .into_value()
                                .unwrap()
                                .unwrap(),
                            start_time: a.start_time.into_value().unwrap().unwrap(),
                            end_time: a.end_time.into_value().unwrap().unwrap(),
                            training_type: a.training_type.into_value().unwrap().unwrap(),
                        })
                    }
                }
                #[automatically_derived]
                impl sea_orm::TryIntoModel<Model> for ActiveModel {
                    fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
                        self.try_into()
                    }
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for Model {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __field4,
                                __field5,
                                __field6,
                                __field7,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        4u64 => _serde::__private::Ok(__Field::__field4),
                                        5u64 => _serde::__private::Ok(__Field::__field5),
                                        6u64 => _serde::__private::Ok(__Field::__field6),
                                        7u64 => _serde::__private::Ok(__Field::__field7),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "name" => _serde::__private::Ok(__Field::__field1),
                                        "iden" => _serde::__private::Ok(__Field::__field2),
                                        "description_public" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        "description_private" => {
                                            _serde::__private::Ok(__Field::__field4)
                                        }
                                        "start_time" => _serde::__private::Ok(__Field::__field5),
                                        "end_time" => _serde::__private::Ok(__Field::__field6),
                                        "training_type" => _serde::__private::Ok(__Field::__field7),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"name" => _serde::__private::Ok(__Field::__field1),
                                        b"iden" => _serde::__private::Ok(__Field::__field2),
                                        b"description_public" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        b"description_private" => {
                                            _serde::__private::Ok(__Field::__field4)
                                        }
                                        b"start_time" => _serde::__private::Ok(__Field::__field5),
                                        b"end_time" => _serde::__private::Ok(__Field::__field6),
                                        b"training_type" => _serde::__private::Ok(__Field::__field7),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<Model>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = Model;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct Model",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field4 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    4usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field5 = match _serde::de::SeqAccess::next_element::<
                                        DateTime,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    5usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field6 = match _serde::de::SeqAccess::next_element::<
                                        DateTime,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    6usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field7 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    7usize,
                                                    &"struct Model with 8 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(Model {
                                        node_id: __field0,
                                        name: __field1,
                                        iden: __field2,
                                        description_public: __field3,
                                        description_private: __field4,
                                        start_time: __field5,
                                        end_time: __field6,
                                        training_type: __field7,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field5: _serde::__private::Option<DateTime> = _serde::__private::None;
                                    let mut __field6: _serde::__private::Option<DateTime> = _serde::__private::None;
                                    let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "description_public",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field4 => {
                                                if _serde::__private::Option::is_some(&__field4) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "description_private",
                                                        ),
                                                    );
                                                }
                                                __field4 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field5 => {
                                                if _serde::__private::Option::is_some(&__field5) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "start_time",
                                                        ),
                                                    );
                                                }
                                                __field5 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<DateTime>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field6 => {
                                                if _serde::__private::Option::is_some(&__field6) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "end_time",
                                                        ),
                                                    );
                                                }
                                                __field6 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<DateTime>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field7 => {
                                                if _serde::__private::Option::is_some(&__field7) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "training_type",
                                                        ),
                                                    );
                                                }
                                                __field7 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("name")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("iden")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("description_public")?
                                        }
                                    };
                                    let __field4 = match __field4 {
                                        _serde::__private::Some(__field4) => __field4,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("description_private")?
                                        }
                                    };
                                    let __field5 = match __field5 {
                                        _serde::__private::Some(__field5) => __field5,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("start_time")?
                                        }
                                    };
                                    let __field6 = match __field6 {
                                        _serde::__private::Some(__field6) => __field6,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("end_time")?
                                        }
                                    };
                                    let __field7 = match __field7 {
                                        _serde::__private::Some(__field7) => __field7,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("training_type")?
                                        }
                                    };
                                    _serde::__private::Ok(Model {
                                        node_id: __field0,
                                        name: __field1,
                                        iden: __field2,
                                        description_public: __field3,
                                        description_private: __field4,
                                        start_time: __field5,
                                        end_time: __field6,
                                        training_type: __field7,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "node_id",
                                "name",
                                "iden",
                                "description_public",
                                "description_private",
                                "start_time",
                                "end_time",
                                "training_type",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "Model",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<Model>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for Model {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "Model",
                                false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "name",
                                &self.name,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "iden",
                                &self.iden,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "description_public",
                                &self.description_public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "description_private",
                                &self.description_private,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "start_time",
                                &self.start_time,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "end_time",
                                &self.end_time,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "training_type",
                                &self.training_type,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl sea_orm::TryGetableFromJson for Model {}
                #[automatically_derived]
                impl std::convert::From<Model> for sea_orm::Value {
                    fn from(source: Model) -> Self {
                        sea_orm::Value::Json(
                            serde_json::to_value(&source)
                                .ok()
                                .map(|s| std::boxed::Box::new(s)),
                        )
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::ValueType for Model {
                    fn try_from(
                        v: sea_orm::Value,
                    ) -> Result<Self, sea_orm::sea_query::ValueTypeErr> {
                        match v {
                            sea_orm::Value::Json(Some(json)) => {
                                Ok(
                                    serde_json::from_value(*json)
                                        .map_err(|_| sea_orm::sea_query::ValueTypeErr)?,
                                )
                            }
                            _ => Err(sea_orm::sea_query::ValueTypeErr),
                        }
                    }
                    fn type_name() -> String {
                        "Model".to_owned()
                    }
                    fn array_type() -> sea_orm::sea_query::ArrayType {
                        sea_orm::sea_query::ArrayType::Json
                    }
                    fn column_type() -> sea_orm::sea_query::ColumnType {
                        sea_orm::sea_query::ColumnType::Json
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::Nullable for Model {
                    fn null() -> sea_orm::Value {
                        sea_orm::Value::Json(None)
                    }
                }
                #[automatically_derived]
                impl sea_orm::sea_query::value::with_array::NotU8 for Model {}
                pub enum Relation {}
                #[automatically_derived]
                impl ::core::marker::Copy for Relation {}
                #[automatically_derived]
                impl ::core::clone::Clone for Relation {
                    #[inline]
                    fn clone(&self) -> Relation {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::fmt::Debug for Relation {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {}
                    }
                }
                ///An iterator over the variants of [Relation]
                #[allow(missing_copy_implementations)]
                pub struct RelationIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<()>,
                }
                impl ::core::fmt::Debug for RelationIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("RelationIter").field("len", &self.len()).finish()
                    }
                }
                impl RelationIter {
                    fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
                        match idx {
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl sea_orm::strum::IntoEnumIterator for Relation {
                    type Iterator = RelationIter;
                    fn iter() -> RelationIter {
                        RelationIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for RelationIter {
                    type Item = Relation;
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 0usize {
                            0
                        } else {
                            0usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 0usize {
                            self.idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            RelationIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for RelationIter {
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for RelationIter {
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 0usize {
                            self.back_idx = 0usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            RelationIter::get(self, 0usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for RelationIter {}
                impl Clone for RelationIter {
                    fn clone(&self) -> RelationIter {
                        RelationIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                #[automatically_derived]
                impl sea_orm::entity::RelationTrait for Relation {
                    fn def(&self) -> sea_orm::entity::RelationDef {
                        match self {
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!("No RelationDef for Relation"),
                                );
                            }
                        }
                    }
                }
                impl ActiveModelBehavior for ActiveModel {}
                impl DbNodeInfo for ActiveModel {
                    fn get_node_type(&self) -> &str {
                        "training"
                    }
                }
                impl DbNodeActiveModel<Model, TrainingNode> for ActiveModel {}
            }
            use crate::Result;
            pub trait DbNodeInfo {
                fn get_node_type(&self) -> &str;
            }
            pub trait DbNodeActiveModel<MODEL, NODE>
            where
                MODEL: Into<NODE>
                    + From<
                        <<Self as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                    >,
                Self: Sized + Send + Sync + ActiveModelTrait + ActiveModelBehavior
                    + DbNodeInfo,
            {
                fn save_into_db(
                    &self,
                    db: &DatabaseConnection,
                ) -> impl std::future::Future<Output = Result<MODEL>> + Send
                where
                    <Self::Entity as EntityTrait>::Model: IntoActiveModel<Self>,
                {
                    async { Ok(self.clone().insert(db).await?.conv::<MODEL>()) }
                }
            }
        }
    }
    pub mod iden {
        pub mod edge {
            #[allow(clippy::module_inception)]
            pub mod edge {
                use sea_orm::DeriveIden;
                pub enum Edge {
                    #[sea_orm(iden = "edge")]
                    Table,
                    #[sea_orm(iden = "edge_id")]
                    EdgeId,
                    #[sea_orm(iden = "edge_type")]
                    EdgeType,
                }
                impl sea_orm::sea_query::Iden for Edge {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "edge")).unwrap()
                            }
                            Self::EdgeId => {
                                s.write_fmt(format_args!("{0}", "edge_id")).unwrap()
                            }
                            Self::EdgeType => {
                                s.write_fmt(format_args!("{0}", "edge_type")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod iden {
                use sea_orm::DeriveIden;
                pub enum Iden {
                    #[sea_orm(iden = "edge_iden")]
                    Table,
                    #[sea_orm(iden = "edge_id")]
                    EdgeId,
                    #[sea_orm(iden = "u_node_id")]
                    UNodeId,
                    #[sea_orm(iden = "v_node_id")]
                    VNodeId,
                    #[sea_orm(iden = "iden")]
                    Iden,
                }
                impl sea_orm::sea_query::Iden for Iden {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "edge_iden")).unwrap()
                            }
                            Self::EdgeId => {
                                s.write_fmt(format_args!("{0}", "edge_id")).unwrap()
                            }
                            Self::UNodeId => {
                                s.write_fmt(format_args!("{0}", "u_node_id")).unwrap()
                            }
                            Self::VNodeId => {
                                s.write_fmt(format_args!("{0}", "v_node_id")).unwrap()
                            }
                            Self::Iden => {
                                s.write_fmt(format_args!("{0}", "iden")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod perm_manage {
                use sea_orm::DeriveIden;
                pub enum PermManage {
                    #[sea_orm(iden = "edge_perm_manage")]
                    Table,
                    #[sea_orm(iden = "edge_id")]
                    EdgeId,
                    #[sea_orm(iden = "u_node_id")]
                    UNodeId,
                    #[sea_orm(iden = "v_node_id")]
                    VNodeId,
                    #[sea_orm(iden = "perm")]
                    Perm,
                }
                impl sea_orm::sea_query::Iden for PermManage {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "edge_perm_manage"))
                                    .unwrap()
                            }
                            Self::EdgeId => {
                                s.write_fmt(format_args!("{0}", "edge_id")).unwrap()
                            }
                            Self::UNodeId => {
                                s.write_fmt(format_args!("{0}", "u_node_id")).unwrap()
                            }
                            Self::VNodeId => {
                                s.write_fmt(format_args!("{0}", "v_node_id")).unwrap()
                            }
                            Self::Perm => {
                                s.write_fmt(format_args!("{0}", "perm")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod perm_view {
                use sea_orm::DeriveIden;
                pub enum PermView {
                    #[sea_orm(iden = "edge_perm_view")]
                    Table,
                    #[sea_orm(iden = "edge_id")]
                    EdgeId,
                    #[sea_orm(iden = "u_node_id")]
                    UNodeId,
                    #[sea_orm(iden = "v_node_id")]
                    VNodeId,
                    #[sea_orm(iden = "perm")]
                    Perm,
                }
                impl sea_orm::sea_query::Iden for PermView {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "edge_perm_view")).unwrap()
                            }
                            Self::EdgeId => {
                                s.write_fmt(format_args!("{0}", "edge_id")).unwrap()
                            }
                            Self::UNodeId => {
                                s.write_fmt(format_args!("{0}", "u_node_id")).unwrap()
                            }
                            Self::VNodeId => {
                                s.write_fmt(format_args!("{0}", "v_node_id")).unwrap()
                            }
                            Self::Perm => {
                                s.write_fmt(format_args!("{0}", "perm")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem_limit {
                use sea_orm::DeriveIden;
                pub enum ProblemLimit {
                    #[sea_orm(iden = "edge_problem_limit")]
                    Table,
                    #[sea_orm(iden = "edge_id")]
                    EdgeId,
                    #[sea_orm(iden = "u_node_id")]
                    UNodeId,
                    #[sea_orm(iden = "v_node_id")]
                    VNodeId,
                    #[sea_orm(iden = "time_limit")]
                    TimeLimit,
                    #[sea_orm(iden = "memory_limit")]
                    MemoryLimit,
                }
                impl sea_orm::sea_query::Iden for ProblemLimit {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "edge_problem_limit"))
                                    .unwrap()
                            }
                            Self::EdgeId => {
                                s.write_fmt(format_args!("{0}", "edge_id")).unwrap()
                            }
                            Self::UNodeId => {
                                s.write_fmt(format_args!("{0}", "u_node_id")).unwrap()
                            }
                            Self::VNodeId => {
                                s.write_fmt(format_args!("{0}", "v_node_id")).unwrap()
                            }
                            Self::TimeLimit => {
                                s.write_fmt(format_args!("{0}", "time_limit")).unwrap()
                            }
                            Self::MemoryLimit => {
                                s.write_fmt(format_args!("{0}", "memory_limit")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem_statement {
                use sea_orm::DeriveIden;
                pub enum ProblemStatement {
                    #[sea_orm(iden = "edge_problem_statement")]
                    Table,
                    #[sea_orm(iden = "edge_id")]
                    EdgeId,
                    #[sea_orm(iden = "u_node_id")]
                    UNodeId,
                    #[sea_orm(iden = "v_node_id")]
                    VNodeId,
                    #[sea_orm(iden = "copyright_risk")]
                    CopyrightRisk,
                }
                impl sea_orm::sea_query::Iden for ProblemStatement {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "edge_problem_statement"))
                                    .unwrap()
                            }
                            Self::EdgeId => {
                                s.write_fmt(format_args!("{0}", "edge_id")).unwrap()
                            }
                            Self::UNodeId => {
                                s.write_fmt(format_args!("{0}", "u_node_id")).unwrap()
                            }
                            Self::VNodeId => {
                                s.write_fmt(format_args!("{0}", "v_node_id")).unwrap()
                            }
                            Self::CopyrightRisk => {
                                s.write_fmt(format_args!("{0}", "copyright_risk")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem_tag {
                use sea_orm::DeriveIden;
                pub enum ProblemTag {
                    #[sea_orm(iden = "edge_problem_tag")]
                    Table,
                    #[sea_orm(iden = "edge_id")]
                    EdgeId,
                    #[sea_orm(iden = "u_node_id")]
                    UNodeId,
                    #[sea_orm(iden = "v_node_id")]
                    VNodeId,
                }
                impl sea_orm::sea_query::Iden for ProblemTag {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "edge_problem_tag"))
                                    .unwrap()
                            }
                            Self::EdgeId => {
                                s.write_fmt(format_args!("{0}", "edge_id")).unwrap()
                            }
                            Self::UNodeId => {
                                s.write_fmt(format_args!("{0}", "u_node_id")).unwrap()
                            }
                            Self::VNodeId => {
                                s.write_fmt(format_args!("{0}", "v_node_id")).unwrap()
                            }
                        };
                    }
                }
            }
        }
        pub mod node {
            pub mod iden {
                use sea_orm::DeriveIden;
                pub enum Iden {
                    #[sea_orm(iden = "node_iden")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "iden")]
                    Iden,
                }
                impl sea_orm::sea_query::Iden for Iden {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_iden")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::Iden => {
                                s.write_fmt(format_args!("{0}", "iden")).unwrap()
                            }
                        };
                    }
                }
            }
            #[allow(clippy::module_inception)]
            pub mod node {
                use sea_orm::DeriveIden;
                pub enum Node {
                    #[sea_orm(iden = "node")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "node_type")]
                    NodeType,
                }
                impl sea_orm::sea_query::Iden for Node {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::NodeType => {
                                s.write_fmt(format_args!("{0}", "node_type")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod pages {
                use sea_orm::DeriveIden;
                pub enum Pages {
                    #[sea_orm(iden = "node_pages")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "iden")]
                    Iden,
                }
                impl sea_orm::sea_query::Iden for Pages {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_pages")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::Iden => {
                                s.write_fmt(format_args!("{0}", "iden")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod perm_group {
                use sea_orm::DeriveIden;
                pub enum PermGroup {
                    #[sea_orm(iden = "node_perm_group")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "iden")]
                    Iden,
                }
                impl sea_orm::sea_query::Iden for PermGroup {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_perm_group")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::Iden => {
                                s.write_fmt(format_args!("{0}", "iden")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem {
                use sea_orm::DeriveIden;
                pub enum Problem {
                    #[sea_orm(iden = "node_problem")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "content_public")]
                    ContentPublic,
                    #[sea_orm(iden = "content_private")]
                    ContentPrivate,
                    #[sea_orm(iden = "name")]
                    Name,
                    #[sea_orm(iden = "creation_time")]
                    CreationTime,
                    #[sea_orm(iden = "creation_order")]
                    CreationOrder,
                }
                impl sea_orm::sea_query::Iden for Problem {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_problem")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::ContentPublic => {
                                s.write_fmt(format_args!("{0}", "content_public")).unwrap()
                            }
                            Self::ContentPrivate => {
                                s.write_fmt(format_args!("{0}", "content_private")).unwrap()
                            }
                            Self::Name => {
                                s.write_fmt(format_args!("{0}", "name")).unwrap()
                            }
                            Self::CreationTime => {
                                s.write_fmt(format_args!("{0}", "creation_time")).unwrap()
                            }
                            Self::CreationOrder => {
                                s.write_fmt(format_args!("{0}", "creation_order")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem_limit {
                pub enum ProblemLimit {
                    #[sea_orm(iden = "node_problem_limit")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "time_limit")]
                    TimeLimit,
                    #[sea_orm(iden = "memory_limit")]
                    MemoryLimit,
                }
                impl sea_orm::sea_query::Iden for ProblemLimit {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_problem_limit"))
                                    .unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::TimeLimit => {
                                s.write_fmt(format_args!("{0}", "time_limit")).unwrap()
                            }
                            Self::MemoryLimit => {
                                s.write_fmt(format_args!("{0}", "memory_limit")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem_source {
                use sea_orm::DeriveIden;
                pub enum ProblemSource {
                    #[sea_orm(iden = "node_problem_source")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "name")]
                    Name,
                    #[sea_orm(iden = "iden")]
                    Iden,
                }
                impl sea_orm::sea_query::Iden for ProblemSource {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_problem_source"))
                                    .unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::Name => {
                                s.write_fmt(format_args!("{0}", "name")).unwrap()
                            }
                            Self::Iden => {
                                s.write_fmt(format_args!("{0}", "iden")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem_statement {
                use sea_orm::DeriveIden;
                pub enum ProblemStatement {
                    #[sea_orm(iden = "node_problem_statement")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "iden")]
                    Iden,
                    #[sea_orm(iden = "source")]
                    Source,
                    #[sea_orm(iden = "content")]
                    Content,
                    #[sea_orm(iden = "creation_time")]
                    CreationTime,
                    #[sea_orm(iden = "update_time")]
                    UpdateTime,
                }
                impl sea_orm::sea_query::Iden for ProblemStatement {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_problem_statement"))
                                    .unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::Iden => {
                                s.write_fmt(format_args!("{0}", "iden")).unwrap()
                            }
                            Self::Source => {
                                s.write_fmt(format_args!("{0}", "source")).unwrap()
                            }
                            Self::Content => {
                                s.write_fmt(format_args!("{0}", "content")).unwrap()
                            }
                            Self::CreationTime => {
                                s.write_fmt(format_args!("{0}", "creation_time")).unwrap()
                            }
                            Self::UpdateTime => {
                                s.write_fmt(format_args!("{0}", "update_time")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod problem_tag {
                use sea_orm::DeriveIden;
                pub enum ProblemTag {
                    #[sea_orm(iden = "node_problem_tag")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "tag_name")]
                    TagName,
                    #[sea_orm(iden = "tag_description")]
                    TagDescription,
                }
                impl sea_orm::sea_query::Iden for ProblemTag {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_problem_tag"))
                                    .unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::TagName => {
                                s.write_fmt(format_args!("{0}", "tag_name")).unwrap()
                            }
                            Self::TagDescription => {
                                s.write_fmt(format_args!("{0}", "tag_description")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod token {
                use sea_orm::DeriveIden;
                pub enum Token {
                    #[sea_orm(iden = "node_token")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "token")]
                    Token,
                    #[sea_orm(iden = "token_type")]
                    TokenType,
                    #[sea_orm(iden = "token_expiration")]
                    TokenExpiration,
                    #[sea_orm(iden = "service")]
                    Service,
                    #[sea_orm(iden = "token_iden")]
                    TokenIden,
                }
                impl sea_orm::sea_query::Iden for Token {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_token")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::Token => {
                                s.write_fmt(format_args!("{0}", "token")).unwrap()
                            }
                            Self::TokenType => {
                                s.write_fmt(format_args!("{0}", "token_type")).unwrap()
                            }
                            Self::TokenExpiration => {
                                s.write_fmt(format_args!("{0}", "token_expiration"))
                                    .unwrap()
                            }
                            Self::Service => {
                                s.write_fmt(format_args!("{0}", "service")).unwrap()
                            }
                            Self::TokenIden => {
                                s.write_fmt(format_args!("{0}", "token_iden")).unwrap()
                            }
                        };
                    }
                }
            }
            pub mod user {
                use sea_orm::DeriveIden;
                pub enum User {
                    #[sea_orm(iden = "node_user")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "user_name")]
                    UserName,
                    #[sea_orm(iden = "user_email")]
                    UserEmail,
                    #[sea_orm(iden = "user_password")]
                    UserPassword,
                    #[sea_orm(iden = "user_avatar")]
                    UserAvatar,
                    #[sea_orm(iden = "user_creation_time")]
                    UserCreationTime,
                    #[sea_orm(iden = "user_creation_order")]
                    UserCreationOrder,
                    #[sea_orm(iden = "user_last_login_time")]
                    UserLastLoginTime,
                    #[sea_orm(iden = "user_description")]
                    UserDescription,
                    #[sea_orm(iden = "user_iden")]
                    UserIden,
                    #[sea_orm(iden = "user_bio")]
                    UserBio,
                    #[sea_orm(iden = "user_profile_show")]
                    UserProfileShow,
                }
                impl sea_orm::sea_query::Iden for User {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_user")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::UserName => {
                                s.write_fmt(format_args!("{0}", "user_name")).unwrap()
                            }
                            Self::UserEmail => {
                                s.write_fmt(format_args!("{0}", "user_email")).unwrap()
                            }
                            Self::UserPassword => {
                                s.write_fmt(format_args!("{0}", "user_password")).unwrap()
                            }
                            Self::UserAvatar => {
                                s.write_fmt(format_args!("{0}", "user_avatar")).unwrap()
                            }
                            Self::UserCreationTime => {
                                s.write_fmt(format_args!("{0}", "user_creation_time"))
                                    .unwrap()
                            }
                            Self::UserCreationOrder => {
                                s.write_fmt(format_args!("{0}", "user_creation_order"))
                                    .unwrap()
                            }
                            Self::UserLastLoginTime => {
                                s.write_fmt(format_args!("{0}", "user_last_login_time"))
                                    .unwrap()
                            }
                            Self::UserDescription => {
                                s.write_fmt(format_args!("{0}", "user_description"))
                                    .unwrap()
                            }
                            Self::UserIden => {
                                s.write_fmt(format_args!("{0}", "user_iden")).unwrap()
                            }
                            Self::UserBio => {
                                s.write_fmt(format_args!("{0}", "user_bio")).unwrap()
                            }
                            Self::UserProfileShow => {
                                s.write_fmt(format_args!("{0}", "user_profile_show"))
                                    .unwrap()
                            }
                        };
                    }
                }
            }
            pub mod training {
                use sea_orm::DeriveIden;
                pub enum Training {
                    #[sea_orm(iden = "node_training")]
                    Table,
                    #[sea_orm(iden = "node_id")]
                    NodeId,
                    #[sea_orm(iden = "description_public")]
                    DescriptionPublic,
                    #[sea_orm(iden = "description_private")]
                    DescriptionPrivate,
                    #[sea_orm(iden = "start_time")]
                    StartTime,
                    #[sea_orm(iden = "end_time")]
                    EndTime,
                    #[sea_orm(iden = "training_type")]
                    TrainingType,
                }
                impl sea_orm::sea_query::Iden for Training {
                    fn prepare(
                        &self,
                        s: &mut dyn ::std::fmt::Write,
                        q: sea_orm::sea_query::Quote,
                    ) {
                        s.write_fmt(format_args!("{0}", q.left())).unwrap();
                        self.unquoted(s);
                        s.write_fmt(format_args!("{0}", q.right())).unwrap();
                    }
                    fn unquoted(&self, s: &mut dyn ::std::fmt::Write) {
                        match self {
                            Self::Table => {
                                s.write_fmt(format_args!("{0}", "node_training")).unwrap()
                            }
                            Self::NodeId => {
                                s.write_fmt(format_args!("{0}", "node_id")).unwrap()
                            }
                            Self::DescriptionPublic => {
                                s.write_fmt(format_args!("{0}", "description_public"))
                                    .unwrap()
                            }
                            Self::DescriptionPrivate => {
                                s.write_fmt(format_args!("{0}", "description_private"))
                                    .unwrap()
                            }
                            Self::StartTime => {
                                s.write_fmt(format_args!("{0}", "start_time")).unwrap()
                            }
                            Self::EndTime => {
                                s.write_fmt(format_args!("{0}", "end_time")).unwrap()
                            }
                            Self::TrainingType => {
                                s.write_fmt(format_args!("{0}", "training_type")).unwrap()
                            }
                        };
                    }
                }
            }
        }
    }
    pub mod init {
        use std::collections::HashMap;
        use async_trait::async_trait;
        use log::LevelFilter;
        use macro_db_init::table_create;
        use sea_orm::{ConnectOptions, Database};
        use sea_orm_migration::prelude::*;
        use crate::graph::edge::perm_view::ViewPermRaw;
        use crate::graph::node::problem_source::{
            ProblemSourceNodePrivateRaw, ProblemSourceNodePublicRaw, ProblemSourceNodeRaw,
        };
        use crate::{
            db::iden, error::CoreError,
            graph::{
                edge::{EdgeRaw, perm_view::{PermViewEdgeRaw, ViewPerm}},
                node::{
                    NodeRaw,
                    pages::{PagesNodePrivateRaw, PagesNodePublicRaw, PagesNodeRaw},
                    perm_group::{
                        PermGroupNodePrivateRaw, PermGroupNodePublicRaw, PermGroupNodeRaw,
                    },
                    user::{UserNodePrivateRaw, UserNodePublicRaw, UserNodeRaw},
                },
            },
        };
        pub struct Migration;
        #[automatically_derived]
        impl sea_orm_migration::MigrationName for Migration {
            fn name(&self) -> &str {
                sea_orm_migration::util::get_file_stem("packages/core/src/db/init.rs")
            }
        }
        fn get_tables() -> HashMap<String, TableCreateStatement> {
            let mut tables = HashMap::new();
            tables
                .insert(
                    "node".to_string(),
                    Table::create()
                        .table(iden::node::node::Node::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::node::Node::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key()
                                .auto_increment(),
                        )
                        .col(
                            ColumnDef::new(iden::node::node::Node::NodeType)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_user".to_string(),
                    Table::create()
                        .table(iden::node::user::User::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::user::User::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserName)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserEmail)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserPassword)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserAvatar)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserCreationTime)
                                .date_time()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserCreationOrder)
                                .big_integer()
                                .not_null()
                                .auto_increment(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserLastLoginTime)
                                .date_time()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserDescription)
                                .text(),
                        )
                        .col(
                            ColumnDef::new(iden::node::user::User::UserIden)
                                .text()
                                .not_null(),
                        )
                        .col(ColumnDef::new(iden::node::user::User::UserBio).text())
                        .col(
                            ColumnDef::new(iden::node::user::User::UserProfileShow)
                                .text(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_token".to_string(),
                    Table::create()
                        .table(iden::node::token::Token::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::token::Token::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::node::token::Token::Token)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::token::Token::TokenType)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::token::Token::TokenExpiration)
                                .date_time()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::token::Token::Service)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::token::Token::TokenIden)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_statement".to_string(),
                    Table::create()
                        .table(iden::node::problem_statement::ProblemStatement::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_statement::ProblemStatement::NodeId,
                                )
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_statement::ProblemStatement::Iden,
                                )
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_statement::ProblemStatement::Source,
                                )
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_statement::ProblemStatement::Content,
                                )
                                .json()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_statement::ProblemStatement::CreationTime,
                                )
                                .date_time()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_statement::ProblemStatement::UpdateTime,
                                )
                                .date_time()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_source".to_string(),
                    Table::create()
                        .table(iden::node::problem_source::ProblemSource::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_source::ProblemSource::NodeId,
                                )
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_source::ProblemSource::Name,
                                )
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_source::ProblemSource::Iden,
                                )
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_pages".to_string(),
                    Table::create()
                        .table(iden::node::pages::Pages::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::pages::Pages::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::node::pages::Pages::Iden)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_perm_group".to_string(),
                    Table::create()
                        .table(iden::node::perm_group::PermGroup::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::perm_group::PermGroup::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::node::perm_group::PermGroup::Iden)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem".to_string(),
                    Table::create()
                        .table(iden::node::problem::Problem::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::problem::Problem::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::node::problem::Problem::Name)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::problem::Problem::ContentPublic)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::problem::Problem::ContentPrivate)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::problem::Problem::CreationTime)
                                .date_time()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::problem::Problem::CreationOrder)
                                .big_integer()
                                .not_null()
                                .auto_increment(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_limit".to_string(),
                    Table::create()
                        .table(iden::node::problem_limit::ProblemLimit::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_limit::ProblemLimit::NodeId,
                                )
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_limit::ProblemLimit::TimeLimit,
                                )
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_limit::ProblemLimit::MemoryLimit,
                                )
                                .big_integer()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_tag".to_string(),
                    Table::create()
                        .table(iden::node::problem_tag::ProblemTag::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::problem_tag::ProblemTag::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::node::problem_tag::ProblemTag::TagName)
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::problem_tag::ProblemTag::TagDescription,
                                )
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_iden".to_string(),
                    Table::create()
                        .table(iden::node::iden::Iden::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::iden::Iden::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::node::iden::Iden::Iden)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "node_training".to_string(),
                    Table::create()
                        .table(iden::node::training::Training::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::node::training::Training::NodeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::training::Training::DescriptionPublic,
                                )
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::node::training::Training::DescriptionPrivate,
                                )
                                .text()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::training::Training::StartTime)
                                .date_time()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::training::Training::EndTime)
                                .date_time()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::node::training::Training::TrainingType)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "edge".to_string(),
                    Table::create()
                        .table(iden::edge::edge::Edge::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::edge::edge::Edge::EdgeId)
                                .big_integer()
                                .not_null()
                                .primary_key()
                                .auto_increment(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::edge::Edge::EdgeType)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_perm_view".to_string(),
                    Table::create()
                        .table(iden::edge::perm_view::PermView::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::edge::perm_view::PermView::EdgeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::perm_view::PermView::UNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::perm_view::PermView::VNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::perm_view::PermView::Perm)
                                .big_integer()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_perm_manage".to_string(),
                    Table::create()
                        .table(iden::edge::perm_manage::PermManage::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::edge::perm_manage::PermManage::EdgeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::perm_manage::PermManage::UNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::perm_manage::PermManage::VNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::perm_manage::PermManage::Perm)
                                .big_integer()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_problem_statement".to_string(),
                    Table::create()
                        .table(iden::edge::problem_statement::ProblemStatement::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(
                                    iden::edge::problem_statement::ProblemStatement::EdgeId,
                                )
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::edge::problem_statement::ProblemStatement::UNodeId,
                                )
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::edge::problem_statement::ProblemStatement::VNodeId,
                                )
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::edge::problem_statement::ProblemStatement::CopyrightRisk,
                                )
                                .big_integer()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_problem_limit".to_string(),
                    Table::create()
                        .table(iden::edge::problem_limit::ProblemLimit::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(
                                    iden::edge::problem_limit::ProblemLimit::EdgeId,
                                )
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::edge::problem_limit::ProblemLimit::UNodeId,
                                )
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(
                                    iden::edge::problem_limit::ProblemLimit::VNodeId,
                                )
                                .big_integer()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_problem_tag".to_string(),
                    Table::create()
                        .table(iden::edge::problem_tag::ProblemTag::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::edge::problem_tag::ProblemTag::EdgeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::problem_tag::ProblemTag::UNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::problem_tag::ProblemTag::VNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_iden".to_string(),
                    Table::create()
                        .table(iden::edge::iden::Iden::Table)
                        .if_not_exists()
                        .col(
                            ColumnDef::new(iden::edge::iden::Iden::EdgeId)
                                .big_integer()
                                .not_null()
                                .primary_key(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::iden::Iden::UNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::iden::Iden::VNodeId)
                                .big_integer()
                                .not_null(),
                        )
                        .col(
                            ColumnDef::new(iden::edge::iden::Iden::Iden)
                                .text()
                                .not_null(),
                        )
                        .to_owned(),
                );
            tables
        }
        fn get_drop_tables() -> HashMap<String, TableDropStatement> {
            let mut tables = HashMap::new();
            tables
                .insert(
                    "node".to_string(),
                    Table::drop()
                        .table(iden::node::node::Node::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_user".to_string(),
                    Table::drop()
                        .table(iden::node::user::User::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_token".to_string(),
                    Table::drop()
                        .table(iden::node::token::Token::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem".to_string(),
                    Table::drop()
                        .table(iden::node::problem::Problem::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_statement".to_string(),
                    Table::drop()
                        .table(iden::node::problem_statement::ProblemStatement::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_pages".to_string(),
                    Table::drop()
                        .table(iden::node::pages::Pages::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_perm_group".to_string(),
                    Table::drop()
                        .table(iden::node::perm_group::PermGroup::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_limit".to_string(),
                    Table::drop()
                        .table(iden::node::problem_limit::ProblemLimit::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_tag".to_string(),
                    Table::drop()
                        .table(iden::node::problem_tag::ProblemTag::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_problem_source".to_string(),
                    Table::drop()
                        .table(iden::node::problem_source::ProblemSource::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_iden".to_string(),
                    Table::drop()
                        .table(iden::node::iden::Iden::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "node_training".to_string(),
                    Table::drop()
                        .table(iden::node::training::Training::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "edge".to_string(),
                    Table::drop()
                        .table(iden::edge::edge::Edge::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_perm_view".to_string(),
                    Table::drop()
                        .table(iden::edge::perm_view::PermView::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_perm_manage".to_string(),
                    Table::drop()
                        .table(iden::edge::perm_manage::PermManage::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_problem_statement".to_string(),
                    Table::drop()
                        .table(iden::edge::problem_statement::ProblemStatement::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_problem_limit".to_string(),
                    Table::drop()
                        .table(iden::edge::problem_limit::ProblemLimit::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_problem_tag".to_string(),
                    Table::drop()
                        .table(iden::edge::problem_tag::ProblemTag::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
                .insert(
                    "edge_iden".to_string(),
                    Table::drop()
                        .table(iden::edge::iden::Iden::Table)
                        .if_exists()
                        .to_owned(),
                );
            tables
        }
        impl MigrationTrait for Migration {
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn up<'life0, 'life1, 'async_trait>(
                &'life0 self,
                manage: &'life1 SchemaManager,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), DbErr>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), DbErr>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let __ret: Result<(), DbErr> = {
                        let tables = get_tables();
                        for (name, table) in tables {
                            {
                                {
                                    let lvl = ::log::Level::Info;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Creating table: {0}", name),
                                            lvl,
                                            &(
                                                "core::db::init",
                                                "core::db::init",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            manage.create_table(table).await?;
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn down<'life0, 'life1, 'async_trait>(
                &'life0 self,
                manage: &'life1 SchemaManager,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), DbErr>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<(), DbErr>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let __ret: Result<(), DbErr> = {
                        let tables = get_drop_tables();
                        for (name, table) in tables {
                            {
                                {
                                    let lvl = ::log::Level::Info;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Dropping table: {0}", name),
                                            lvl,
                                            &(
                                                "core::db::init",
                                                "core::db::init",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            manage.drop_table(table).await?;
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
        pub struct Migrator;
        impl MigratorTrait for Migrator {
            fn migrations() -> Vec<Box<dyn MigrationTrait>> {
                <[_]>::into_vec(::alloc::boxed::box_new([Box::new(Migration)]))
            }
        }
        pub fn init(
            url: &str,
            schema: &str,
            mode: &str,
            up: Vec<&str>,
            down: Vec<&str>,
        ) -> Result<(), CoreError> {
            let body = async {
                let connection_options = ConnectOptions::new(url)
                    .set_schema_search_path(schema)
                    .max_connections(10)
                    .sqlx_logging_level(LevelFilter::Trace)
                    .to_owned();
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Database Update: {0}", up.join(", ")),
                                lvl,
                                &(
                                    "core::db::init",
                                    "core::db::init",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Database Drop: {0}", down.join(", ")),
                                lvl,
                                &(
                                    "core::db::init",
                                    "core::db::init",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Database connecting..."),
                                lvl,
                                &(
                                    "core::db::init",
                                    "core::db::init",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let db = Database::connect(connection_options).await.unwrap();
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Database connected"),
                                lvl,
                                &(
                                    "core::db::init",
                                    "core::db::init",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                if down.contains(&"all") {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Dropping all tables, this will delete all data in the database!",
                                    ),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    if mode != "dev" {
                        {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Dropping all is only available in development mode!(use --mode dev to confirm this action)",
                                        ),
                                        lvl,
                                        &(
                                            "core::db::init",
                                            "core::db::init",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        return Err(
                            CoreError::DbError(
                                sea_orm::error::DbErr::Custom(
                                    "Cannot drop all tables in non-development mode".to_string(),
                                ),
                            ),
                        );
                    }
                    let _ = Migrator::down(&db, None).await;
                } else {
                    let manager = SchemaManager::new(&db);
                    let tables = get_drop_tables();
                    for (name, table) in tables {
                        if down.contains(&name.as_str()) {
                            {
                                {
                                    let lvl = ::log::Level::Info;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Dropping table: {0}", name),
                                            lvl,
                                            &(
                                                "core::db::init",
                                                "core::db::init",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            manager.drop_table(table).await?;
                        }
                    }
                }
                if up.contains(&"all") {
                    let _ = Migrator::up(&db, None).await;
                } else {
                    let manager = SchemaManager::new(&db);
                    let tables = get_tables();
                    for (name, table) in tables {
                        if up.contains(&name.as_str()) {
                            {
                                {
                                    let lvl = ::log::Level::Info;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Creating table: {0}", name),
                                            lvl,
                                            &(
                                                "core::db::init",
                                                "core::db::init",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            manager.create_table(table).await?;
                        }
                    }
                }
                let mut default_pages = ::alloc::vec::Vec::new();
                if up.contains(&"all") || up.contains(&"node_pages") {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Creating default pages"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Creating home page"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let home_page = PagesNodeRaw {
                        iden: "home".to_string(),
                        public: PagesNodePublicRaw {},
                        private: PagesNodePrivateRaw {
                            name: "home".to_string(),
                        },
                    }
                        .save(&db)
                        .await?;
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Creating about page"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let about_page = PagesNodeRaw {
                        iden: "about".to_string(),
                        public: PagesNodePublicRaw {},
                        private: PagesNodePrivateRaw {
                            name: "about".to_string(),
                        },
                    }
                        .save(&db)
                        .await?;
                    default_pages.push(home_page.node_id);
                    default_pages.push(about_page.node_id);
                } else {
                    {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Skipping default pages creation, This may lead to unexpected behavior.",
                                    ),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                if up.contains(&"all") || up.contains(&"node_perm_group") {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Creating default perm group"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let default_strategy = PermGroupNodeRaw {
                        iden: "default".to_string(),
                        service: "default".to_string(),
                        public: PermGroupNodePublicRaw {},
                        private: PermGroupNodePrivateRaw {
                            name: "default strategy".to_string(),
                        },
                    }
                        .save(&db)
                        .await?;
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Perm group -> default pages"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    for i in default_pages.clone() {
                        PermViewEdgeRaw {
                            u: default_strategy.node_id,
                            v: i,
                            perms: ViewPermRaw::Perms(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        ViewPerm::ViewPublic,
                                        ViewPerm::ReadProblem,
                                    ]),
                                ),
                            ),
                        }
                            .save(&db)
                            .await?;
                    }
                } else {
                    {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Skipping default perm group creation, This may lead to unexpected behavior.",
                                    ),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                let mut guest_user_id = 0;
                if up.contains(&"all") || up.contains(&"node_user") {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Creating default user"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let guest_user = UserNodeRaw {
                        public: UserNodePublicRaw {
                            name: "Guest".to_string(),
                            email: "".to_string(),
                            iden: "guest".to_string(),
                            creation_time: chrono::Utc::now().naive_utc(),
                            last_login_time: chrono::Utc::now().naive_utc(),
                            avatar: "".to_string(),
                        },
                        private: UserNodePrivateRaw {
                            password: "".to_string(),
                        },
                    }
                        .save(&db)
                        .await?;
                    guest_user_id = guest_user.node_id;
                } else {
                    {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Skipping default user creation, This may lead to unexpected behavior.",
                                    ),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                if up.contains(&"all")
                    || (up.contains(&"node_perm_group") && up.contains(&"edge_perm_view")
                        && up.contains(&"node_pages"))
                {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("default user -> default pages"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    for i in default_pages {
                        PermViewEdgeRaw {
                            u: guest_user_id,
                            v: i,
                            perms: ViewPermRaw::Perms(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        ViewPerm::ViewPublic,
                                        ViewPerm::ReadProblem,
                                    ]),
                                ),
                            ),
                        }
                            .save(&db)
                            .await?;
                    }
                } else {
                    {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Skipping default perm view edge creation, This may lead to unexpected behavior.",
                                    ),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                }
                if up.contains(&"all") {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Create default problem_source"),
                                    lvl,
                                    &(
                                        "core::db::init",
                                        "core::db::init",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    ProblemSourceNodeRaw {
                        public: ProblemSourceNodePublicRaw {
                            iden: "rmj".to_string(),
                            name: "Rmj.ac".to_string(),
                        },
                        private: ProblemSourceNodePrivateRaw {},
                    }
                        .save(&db)
                        .await?;
                    ProblemSourceNodeRaw {
                        public: ProblemSourceNodePublicRaw {
                            iden: "LG".to_string(),
                            name: "".to_string(),
                        },
                        private: ProblemSourceNodePrivateRaw {},
                    }
                        .save(&db)
                        .await?;
                }
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Database migrated"),
                                lvl,
                                &(
                                    "core::db::init",
                                    "core::db::init",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                Ok(())
            };
            #[allow(
                clippy::expect_used,
                clippy::diverging_sub_expression,
                clippy::needless_return
            )]
            {
                return tokio::runtime::Builder::new_multi_thread()
                    .enable_all()
                    .build()
                    .expect("Failed building the Runtime")
                    .block_on(body);
            }
        }
    }
}
pub mod graph {
    pub mod action {
        pub mod topo {
            use std::collections::HashMap;
            use queue::Queue;
            pub struct TopoGraph {
                map: HashMap<i64, Vec<(i64, i8)>>,
                pub result: HashMap<i64, i8>,
                anti_map: HashMap<i64, Vec<(i64, i8)>>,
                in_degree: HashMap<i64, i64>,
                out_degree: HashMap<i64, i64>,
                max_node_id: i64,
            }
            impl TopoGraph {
                pub fn new(max_node_id: i64) -> Self {
                    TopoGraph {
                        map: HashMap::new(),
                        result: HashMap::new(),
                        anti_map: HashMap::new(),
                        in_degree: HashMap::new(),
                        out_degree: HashMap::new(),
                        max_node_id,
                    }
                }
                pub fn add_edge(&mut self, u: i64, v: i64, w: i8) {
                    self.map.entry(u).or_default().push((v, w));
                    self.anti_map.entry(v).or_default().push((v, w));
                    *self.in_degree.entry(v).or_insert(0) += 1;
                    *self.out_degree.entry(u).or_insert(0) += 1;
                    self.max_node_id = self.max_node_id.max(u).max(v);
                }
                pub fn init(&mut self, s: i64) {
                    let mut que = Queue::new();
                    let _ = que.queue(s);
                    self.result.insert(s, 1);
                    while let Some(u) = que.dequeue() {
                        let current_value = *self.result.get(&u).unwrap_or(&0);
                        for i in self.map.get(&u).unwrap_or(&::alloc::vec::Vec::new()) {
                            let (v, w) = *i;
                            if current_value == 1 && w == 1 {
                                *self.result.entry(v).or_insert(0) = 1;
                            }
                            *self.in_degree.entry(v).or_insert(0) -= 1;
                            if *self.in_degree.get(&v).unwrap() == 0 {
                                let _ = que.queue(v);
                            }
                        }
                    }
                }
            }
        }
        use crate::db::entity::edge::{DbEdgeActiveModel, DbEdgeInfo};
        use crate::db::entity::node::node;
        use crate::env::{
            PATH_VIS, SAVED_NODE_CIRCLE_ID, SAVED_NODE_PATH, SAVED_NODE_PATH_LIST,
            SAVED_NODE_PATH_REV,
        };
        use crate::error::CoreError;
        use crate::graph::action::topo::TopoGraph;
        use crate::graph::edge::{Edge, EdgeQuery, EdgeQueryPerm};
        use crate::{Result, db};
        use async_recursion::async_recursion;
        use sea_orm::ColumnTrait;
        use sea_orm::DatabaseConnection;
        use sea_orm::EntityTrait;
        use sea_orm::{
            ActiveModelBehavior, ActiveModelTrait, IntoActiveModel, QueryFilter,
        };
        use serde::{Deserialize, Serialize};
        #[allow(clippy::too_many_arguments)]
        #[must_use]
        pub fn has_path_dfs<
            'life0,
            'life1,
            'async_recursion,
            DbActive,
            DbModel,
            DbEntity,
            EdgeA,
            T,
        >(
            db: &'life0 DatabaseConnection,
            u: i64,
            v: i64,
            _edge_type: &'life1 T,
            required_perm: i64,
            ckid: i32,
            step: i64,
            max_step: i64,
            no_check: bool,
        ) -> ::core::pin::Pin<
            Box<dyn ::core::future::Future<Output = Result<i8>> + 'async_recursion>,
        >
        where
            DbActive: DbEdgeActiveModel<DbModel, EdgeA> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbEdgeInfo,
            DbModel: Into<EdgeA>
                + From<
                    <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            <DbActive::Entity as EntityTrait>::Model: IntoActiveModel<DbActive>,
            <DbEntity as sea_orm::EntityTrait>::Model: Into<DbModel>,
            EdgeA: Edge<DbActive, DbModel, DbEntity>,
            DbEntity: EntityTrait,
            T: Sized + Send + Sync + Clone
                + EdgeQuery<DbActive, DbModel, DbEntity, EdgeA> + EdgeQueryPerm,
            DbActive: 'async_recursion,
            DbModel: 'async_recursion,
            DbEntity: 'async_recursion,
            EdgeA: 'async_recursion,
            T: 'async_recursion,
            'life0: 'async_recursion,
            'life1: 'async_recursion,
        {
            Box::pin(async move {
                {
                    {
                        let lvl = ::log::Level::Trace;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Check perm from {0} -> {1}, now_step: {2}, required_perm: {3}",
                                    u,
                                    v,
                                    step,
                                    required_perm,
                                ),
                                lvl,
                                &(
                                    "core::graph::action",
                                    "core::graph::action",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                if step > max_step {
                    return Ok(-1);
                }
                if !no_check
                    && let Some(x) = SAVED_NODE_PATH
                        .lock()
                        .unwrap()
                        .get(&(u, T::get_edge_type().to_string()))
                    && let Some(x) = x.get(&v)
                {
                    if T::check_perm(required_perm, *x) {
                        return Ok(1);
                    } else {
                        return Ok(0);
                    }
                }
                if PATH_VIS.lock().unwrap().get(&ckid).and_then(|m| m.get(&u)).is_some()
                {
                    PATH_VIS.lock().unwrap().entry(ckid).or_default().insert(u, true);
                }
                let nv = T::get_perm_v(u, db).await?;
                for ver in nv {
                    if PATH_VIS
                        .lock()
                        .unwrap()
                        .get(&ckid)
                        .and_then(|m| m.get(&ver.0))
                        .is_some()
                    {
                        continue;
                    }
                    if !T::check_perm(required_perm, ver.1) {
                        continue;
                    }
                    if ver.0 == v {
                        return Ok(1);
                    }
                    let val = has_path_dfs(
                            db,
                            ver.0,
                            v,
                            _edge_type,
                            required_perm,
                            ckid,
                            step + 1,
                            max_step,
                            no_check,
                        )
                        .await?;
                    if val == -1 {
                        return Ok(-1);
                    } else if val == 1 {
                        return Ok(1);
                    }
                }
                Ok(0)
            })
        }
        pub fn gen_ckid() -> i32 {
            let mut ckid = SAVED_NODE_CIRCLE_ID.lock().unwrap();
            (*ckid) += 1;
            (*ckid) %= 1000;
            let mut d = (*PATH_VIS).lock().unwrap();
            if d.contains_key(&(*ckid)) {
                d.remove(&(*ckid));
            }
            d.insert(*ckid, std::collections::HashMap::new());
            *ckid
        }
        pub async fn has_path<DbActive, DbModel, DbEntity, EdgeA, T>(
            db: &DatabaseConnection,
            u: i64,
            v: i64,
            edge_type: &T,
            required_perm: i64,
        ) -> Result<i8>
        where
            DbActive: DbEdgeActiveModel<DbModel, EdgeA> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbEdgeInfo,
            DbModel: Into<EdgeA>
                + From<
                    <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            <DbActive::Entity as EntityTrait>::Model: IntoActiveModel<DbActive>,
            <DbEntity as sea_orm::EntityTrait>::Model: Into<DbModel>,
            EdgeA: Edge<DbActive, DbModel, DbEntity>,
            DbEntity: EntityTrait,
            T: EdgeQuery<DbActive, DbModel, DbEntity, EdgeA> + EdgeQueryPerm + Sized
                + Send + Sync + Clone,
        {
            let empty = ::alloc::vec::Vec::new();
            let data = SAVED_NODE_PATH_LIST
                .lock()
                .unwrap()
                .get(T::get_edge_type())
                .unwrap_or(&empty)
                .clone();
            for path in data {
                if let Some(x) = SAVED_NODE_PATH
                    .lock()
                    .unwrap()
                    .get(&(path, T::get_edge_type().to_string()))
                    .and_then(|m| m.get(&v))
                {
                    if T::check_perm(required_perm, *x) {
                        if let Some(x) = SAVED_NODE_PATH_REV
                            .lock()
                            .unwrap()
                            .get(&(path, T::get_edge_type().to_string()))
                            .and_then(|m| m.get(&u))
                        {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Cache hit.{0} -> {1}, perm: {2}", u, v, x),
                                            lvl,
                                            &(
                                                "core::graph::action",
                                                "core::graph::action",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            if T::check_perm(required_perm, *x) {
                                return Ok(1);
                            }
                        }
                    }
                }
            }
            let ckid = gen_ckid();
            let mut required_perm = required_perm;
            while required_perm > 0 {
                let res = has_path_dfs(
                        db,
                        u,
                        v,
                        edge_type,
                        lowbit(required_perm),
                        ckid,
                        0,
                        100,
                        false,
                    )
                    .await?;
                if res < 1 {
                    return Ok(res);
                }
                required_perm -= lowbit(required_perm);
            }
            Ok(1)
        }
        pub fn lowbit(x: i64) -> i64 {
            x & (-x)
        }
        #[allow(unused_variables)]
        pub async fn init_spot<DbActive, DbModel, DbEntity, EdgeA, T>(
            db: &DatabaseConnection,
            edge_type: &T,
            spot_node_id: i64,
            node_number: i64,
        ) -> Result<()>
        where
            DbActive: DbEdgeActiveModel<DbModel, EdgeA> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbEdgeInfo,
            DbModel: Into<EdgeA>
                + From<
                    <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            <DbActive::Entity as EntityTrait>::Model: IntoActiveModel<DbActive>,
            <DbEntity as sea_orm::EntityTrait>::Model: Into<DbModel>,
            EdgeA: Edge<DbActive, DbModel, DbEntity>,
            DbEntity: EntityTrait,
            T: Sized + Send + Sync + Clone
                + EdgeQuery<DbActive, DbModel, DbEntity, EdgeA> + EdgeQueryPerm,
        {
            let mut edge_data = ::alloc::vec::Vec::new();
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("init spot, node_number: {0}", node_number),
                            lvl,
                            &(
                                "core::graph::action",
                                "core::graph::action",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("start to collect graph data from db"),
                            lvl,
                            &(
                                "core::graph::action",
                                "core::graph::action",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let data = T::get_all(db).await?;
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("edge number: {0}", data.len()),
                            lvl,
                            &(
                                "core::graph::action",
                                "core::graph::action",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            for i in data {
                edge_data.push((i.0, i.1, i.2));
            }
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("end collected"),
                            lvl,
                            &(
                                "core::graph::action",
                                "core::graph::action",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("start to run in each perm"),
                            lvl,
                            &(
                                "core::graph::action",
                                "core::graph::action",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            for i in T::get_perm_iter() {
                if i == -1 {
                    continue;
                }
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("start to run perm(number: {0})", i),
                                lvl,
                                &(
                                    "core::graph::action",
                                    "core::graph::action",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("start to build graph"),
                                lvl,
                                &(
                                    "core::graph::action",
                                    "core::graph::action",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let (mut graph, mut anti_graph) = (
                    TopoGraph::new(node_number),
                    TopoGraph::new(node_number),
                );
                for &(u, v, perm) in &edge_data {
                    let perm = i & perm;
                    graph.add_edge(u, v, (perm != 0) as i8);
                    anti_graph.add_edge(v, u, (perm != 0) as i8);
                }
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("end to build graph"),
                                lvl,
                                &(
                                    "core::graph::action",
                                    "core::graph::action",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("start to get topo sort"),
                                lvl,
                                &(
                                    "core::graph::action",
                                    "core::graph::action",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                graph.init(spot_node_id);
                anti_graph.init(spot_node_id);
                for j in 1..=node_number {
                    let result = graph.result.get(&j).unwrap_or(&0);
                    let anti_result = anti_graph.result.get(&j).unwrap_or(&0);
                    if ((*result) as i64) > 0 {
                        *SAVED_NODE_PATH
                            .lock()
                            .unwrap()
                            .entry((spot_node_id, T::get_edge_type().to_string()))
                            .or_default()
                            .entry(j)
                            .or_insert(0) |= i;
                    }
                    if ((*anti_result) as i64) > 0 {
                        *SAVED_NODE_PATH_REV
                            .lock()
                            .unwrap()
                            .entry((spot_node_id, T::get_edge_type().to_string()))
                            .or_default()
                            .entry(j)
                            .or_insert(0) |= i;
                    }
                }
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("end to get topo sort"),
                                lvl,
                                &(
                                    "core::graph::action",
                                    "core::graph::action",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            SAVED_NODE_PATH_LIST
                .lock()
                .unwrap()
                .entry(T::get_edge_type().to_string())
                .or_default()
                .push(spot_node_id);
            Ok(())
        }
        pub struct DefaultNodes {
            pub guest_user_node: i64,
            pub default_strategy_node: i64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DefaultNodes {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DefaultNodes",
                    "guest_user_node",
                    &self.guest_user_node,
                    "default_strategy_node",
                    &&self.default_strategy_node,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DefaultNodes {
            #[inline]
            fn clone(&self) -> DefaultNodes {
                DefaultNodes {
                    guest_user_node: ::core::clone::Clone::clone(&self.guest_user_node),
                    default_strategy_node: ::core::clone::Clone::clone(
                        &self.default_strategy_node,
                    ),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DefaultNodes {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DefaultNodes",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "guest_user_node",
                        &self.guest_user_node,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "default_strategy_node",
                        &self.default_strategy_node,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DefaultNodes {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "guest_user_node" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "default_strategy_node" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"guest_user_node" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"default_strategy_node" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DefaultNodes>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DefaultNodes;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DefaultNodes",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                i64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DefaultNodes with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                i64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DefaultNodes with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DefaultNodes {
                                guest_user_node: __field0,
                                default_strategy_node: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "guest_user_node",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "default_strategy_node",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("guest_user_node")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "default_strategy_node",
                                    )?
                                }
                            };
                            _serde::__private::Ok(DefaultNodes {
                                guest_user_node: __field0,
                                default_strategy_node: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "guest_user_node",
                        "default_strategy_node",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DefaultNodes",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DefaultNodes>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub async fn get_default_node(db: &DatabaseConnection) -> Result<DefaultNodes> {
            let mut result = DefaultNodes {
                guest_user_node: -1,
                default_strategy_node: -1,
            };
            result.guest_user_node = db::entity::node::user::get_guest_user_node(db)
                .await?;
            result.default_strategy_node = db::entity::node::perm_group::get_default_strategy_node(
                    db,
                )
                .await?;
            Ok(result)
        }
        pub async fn get_node_type(
            db: &DatabaseConnection,
            node_id: i64,
        ) -> Result<String> {
            let node = node::Entity::find()
                .filter(node::Column::NodeId.eq(node_id))
                .one(db)
                .await?;
            if let Some(node) = node {
                Ok(node.node_type)
            } else {
                Err(
                    CoreError::NotFound(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Node with id {0} not found", node_id),
                            )
                        }),
                    ),
                )
            }
        }
    }
    pub mod edge {
        use crate::Result;
        use crate::db::entity::edge::{DbEdgeActiveModel, DbEdgeInfo, edge::create_edge};
        use crate::error::CoreError;
        use crate::error::CoreError::{NotFound, StringError};
        use sea_orm::sea_query::IntoCondition;
        use sea_orm::{
            ActiveModelBehavior, ActiveModelTrait, DatabaseConnection, EntityTrait,
            IntoActiveModel, ModelTrait,
        };
        use std::str::FromStr;
        pub enum EdgeType {
            PermView,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for EdgeType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "PermView")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for EdgeType {
            #[inline]
            fn clone(&self) -> EdgeType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for EdgeType {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for EdgeType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for EdgeType {
            #[inline]
            fn eq(&self, other: &EdgeType) -> bool {
                true
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for EdgeType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl From<EdgeType> for &str {
            fn from(edge_type: EdgeType) -> Self {
                match edge_type {
                    EdgeType::PermView => "perm_view",
                }
            }
        }
        pub mod iden {
            pub struct IdenEdge {
                pub id: i64,
                pub u: i64,
                pub v: i64,
                pub iden: String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenEdge {
                #[inline]
                fn clone(&self) -> IdenEdge {
                    IdenEdge {
                        id: ::core::clone::Clone::clone(&self.id),
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        iden: ::core::clone::Clone::clone(&self.iden),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenEdge {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "IdenEdge",
                        "id",
                        &self.id,
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "iden",
                        &&self.iden,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdenEdge {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IdenEdge {
                #[inline]
                fn eq(&self, other: &IdenEdge) -> bool {
                    self.id == other.id && self.u == other.u && self.v == other.v
                        && self.iden == other.iden
                }
            }
            pub struct IdenEdgeRaw {
                pub u: i64,
                pub v: i64,
                pub iden: String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenEdgeRaw {
                #[inline]
                fn clone(&self) -> IdenEdgeRaw {
                    IdenEdgeRaw {
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        iden: ::core::clone::Clone::clone(&self.iden),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenEdgeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "IdenEdgeRaw",
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "iden",
                        &&self.iden,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdenEdgeRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IdenEdgeRaw {
                #[inline]
                fn eq(&self, other: &IdenEdgeRaw) -> bool {
                    self.u == other.u && self.v == other.v && self.iden == other.iden
                }
            }
            impl EdgeRaw<IdenEdge, Model, ActiveModel> for IdenEdgeRaw {
                fn get_edge_type(&self) -> &str {
                    "iden"
                }
                fn get_edge_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::EdgeId
                }
            }
            impl From<IdenEdgeRaw> for ActiveModel {
                fn from(raw: IdenEdgeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    ActiveModel {
                        edge_id: NotSet,
                        u_node_id: Set(raw.u),
                        v_node_id: Set(raw.v),
                        iden: Set(raw.iden),
                    }
                }
            }
            pub struct IdenEdgeQuery;
            #[automatically_derived]
            impl ::core::clone::Clone for IdenEdgeQuery {
                #[inline]
                fn clone(&self) -> IdenEdgeQuery {
                    IdenEdgeQuery
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenEdgeQuery {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "IdenEdgeQuery")
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdenEdgeQuery {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IdenEdgeQuery {
                #[inline]
                fn eq(&self, other: &IdenEdgeQuery) -> bool {
                    true
                }
            }
            impl Edge<ActiveModel, Model, Entity> for IdenEdge {
                fn get_edge_id(&self) -> i64 {
                    self.id
                }
                fn get_u_node_id(&self) -> i64 {
                    self.u
                }
                fn get_v_node_id(&self) -> i64 {
                    self.v
                }
            }
            impl EdgeQuery<ActiveModel, Model, Entity, IdenEdge> for IdenEdgeQuery {
                fn get_edge_type() -> &'static str {
                    "iden"
                }
            }
            use crate::db::entity::edge::iden::{ActiveModel, Column, Entity, Model};
            use crate::graph::edge::Edge;
            use crate::graph::edge::{EdgeQuery, EdgeRaw};
        }
        pub mod perm_manage {
            pub struct PermManageEdge {
                pub id: i64,
                pub u: i64,
                pub v: i64,
                pub perms: Vec<ManagePerm>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermManageEdge {
                #[inline]
                fn clone(&self) -> PermManageEdge {
                    PermManageEdge {
                        id: ::core::clone::Clone::clone(&self.id),
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        perms: ::core::clone::Clone::clone(&self.perms),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PermManageEdge {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "PermManageEdge",
                        "id",
                        &self.id,
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "perms",
                        &&self.perms,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PermManageEdge {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PermManageEdge {
                #[inline]
                fn eq(&self, other: &PermManageEdge) -> bool {
                    self.id == other.id && self.u == other.u && self.v == other.v
                        && self.perms == other.perms
                }
            }
            pub struct PermManageEdgeRaw {
                pub u: i64,
                pub v: i64,
                pub perms: ManagePermRaw,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermManageEdgeRaw {
                #[inline]
                fn clone(&self) -> PermManageEdgeRaw {
                    PermManageEdgeRaw {
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        perms: ::core::clone::Clone::clone(&self.perms),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PermManageEdgeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PermManageEdgeRaw",
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "perms",
                        &&self.perms,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PermManageEdgeRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PermManageEdgeRaw {
                #[inline]
                fn eq(&self, other: &PermManageEdgeRaw) -> bool {
                    self.u == other.u && self.v == other.v && self.perms == other.perms
                }
            }
            pub enum ManagePerm {
                ManageStatement = 1,
                ManageEdge = 2,
                ManagePublicDescription = 4,
                ManagePrivateDescription = 8,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::enum_const::EnumConst for ManagePerm {
                fn get_const_isize(&self) -> Option<isize> {
                    match self {
                        Self::ManageStatement => Some(1),
                        Self::ManageEdge => Some(2),
                        Self::ManagePublicDescription => Some(4),
                        Self::ManagePrivateDescription => Some(8),
                        _ => None,
                    }
                }
                fn from_const_isize(i: isize) -> Option<Self> {
                    match i {
                        1 => Some(Self::ManageStatement),
                        2 => Some(Self::ManageEdge),
                        4 => Some(Self::ManagePublicDescription),
                        8 => Some(Self::ManagePrivateDescription),
                        _ => None,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ManagePerm {}
            #[automatically_derived]
            impl ::core::clone::Clone for ManagePerm {
                #[inline]
                fn clone(&self) -> ManagePerm {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ManagePerm {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            ManagePerm::ManageStatement => "ManageStatement",
                            ManagePerm::ManageEdge => "ManageEdge",
                            ManagePerm::ManagePublicDescription => {
                                "ManagePublicDescription"
                            }
                            ManagePerm::ManagePrivateDescription => {
                                "ManagePrivateDescription"
                            }
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ManagePerm {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ManagePerm {
                #[inline]
                fn eq(&self, other: &ManagePerm) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            ///An iterator over the variants of [ManagePerm]
            #[allow(missing_copy_implementations)]
            pub struct ManagePermIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<fn() -> ()>,
            }
            impl ::core::fmt::Debug for ManagePermIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ManagePermIter").field("len", &self.len()).finish()
                }
            }
            impl ManagePermIter {
                fn get(&self, idx: usize) -> ::core::option::Option<ManagePerm> {
                    match idx {
                        0usize => {
                            ::core::option::Option::Some(ManagePerm::ManageStatement)
                        }
                        1usize => ::core::option::Option::Some(ManagePerm::ManageEdge),
                        2usize => {
                            ::core::option::Option::Some(
                                ManagePerm::ManagePublicDescription,
                            )
                        }
                        3usize => {
                            ::core::option::Option::Some(
                                ManagePerm::ManagePrivateDescription,
                            )
                        }
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::strum::IntoEnumIterator for ManagePerm {
                type Iterator = ManagePermIter;
                #[inline]
                fn iter() -> ManagePermIter {
                    ManagePermIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for ManagePermIter {
                type Item = ManagePerm;
                #[inline]
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                #[inline]
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 4usize {
                        0
                    } else {
                        4usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                #[inline]
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 4usize {
                        self.idx = 4usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        ManagePermIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for ManagePermIter {
                #[inline]
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for ManagePermIter {
                #[inline]
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 4usize {
                        self.back_idx = 4usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        ManagePermIter::get(self, 4usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for ManagePermIter {}
            impl Clone for ManagePermIter {
                #[inline]
                fn clone(&self) -> ManagePermIter {
                    ManagePermIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            pub enum ManagePermRaw {
                All,
                Perms(Vec<ManagePerm>),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ManagePermRaw {
                #[inline]
                fn clone(&self) -> ManagePermRaw {
                    match self {
                        ManagePermRaw::All => ManagePermRaw::All,
                        ManagePermRaw::Perms(__self_0) => {
                            ManagePermRaw::Perms(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ManagePermRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ManagePermRaw::All => ::core::fmt::Formatter::write_str(f, "All"),
                        ManagePermRaw::Perms(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Perms",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ManagePermRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ManagePermRaw {
                #[inline]
                fn eq(&self, other: &ManagePermRaw) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                        && match (self, other) {
                            (
                                ManagePermRaw::Perms(__self_0),
                                ManagePermRaw::Perms(__arg1_0),
                            ) => __self_0 == __arg1_0,
                            _ => true,
                        }
                }
            }
            impl From<ManagePermRaw> for i32 {
                fn from(perms: ManagePermRaw) -> i32 {
                    match perms {
                        ManagePermRaw::All => {
                            let mut res = 0;
                            for i in ManagePerm::iter() {
                                res |= i.get_const_isize().unwrap() as i32;
                            }
                            res
                        }
                        ManagePermRaw::Perms(perms) => {
                            let mut res = 0;
                            for perm in perms {
                                res |= perm.get_const_isize().unwrap() as i32;
                            }
                            res
                        }
                    }
                }
            }
            impl EdgeRaw<PermManageEdge, Model, ActiveModel> for PermManageEdgeRaw {
                fn get_edge_type(&self) -> &str {
                    "perm_manage"
                }
                fn get_edge_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::EdgeId
                }
            }
            impl From<PermManageEdgeRaw> for ActiveModel {
                fn from(raw: PermManageEdgeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    ActiveModel {
                        edge_id: NotSet,
                        u_node_id: Set(raw.u),
                        v_node_id: Set(raw.v),
                        perm: Set(raw.perms.conv::<i32>() as i64),
                    }
                }
            }
            impl From<Model> for PermManageEdge {
                fn from(model: Model) -> Self {
                    let perms: Perms = model.perm.into();
                    PermManageEdge {
                        id: model.edge_id,
                        u: model.u_node_id,
                        v: model.v_node_id,
                        perms: perms.0,
                    }
                }
            }
            impl From<i64> for Perms {
                fn from(perm: i64) -> Self {
                    let mut perms = Vec::new();
                    for p in ManagePerm::iter() {
                        if perm & p.get_const_isize().unwrap() as i64 != 0 {
                            perms.push(p);
                        }
                    }
                    Perms(perms)
                }
            }
            pub struct Perms(Vec<ManagePerm>);
            impl From<Perms> for i64 {
                fn from(perms: Perms) -> i64 {
                    let mut res = 0;
                    for perm in perms.0 {
                        res |= perm.get_const_isize().unwrap();
                    }
                    res as i64
                }
            }
            impl From<Vec<ManagePerm>> for Perms {
                fn from(perms: Vec<ManagePerm>) -> Self {
                    Perms(perms)
                }
            }
            impl From<&[ManagePerm]> for Perms {
                fn from(perms: &[ManagePerm]) -> Self {
                    Perms(perms.to_vec())
                }
            }
            pub struct PermManageEdgeQuery;
            #[automatically_derived]
            impl ::core::clone::Clone for PermManageEdgeQuery {
                #[inline]
                fn clone(&self) -> PermManageEdgeQuery {
                    PermManageEdgeQuery
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PermManageEdgeQuery {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PermManageEdgeQuery")
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for PermManageEdgeQuery {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &PermManageEdgeQuery,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PermManageEdgeQuery {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PermManageEdgeQuery {
                #[inline]
                fn eq(&self, other: &PermManageEdgeQuery) -> bool {
                    true
                }
            }
            impl Edge<ActiveModel, Model, Entity> for PermManageEdge {
                fn get_edge_id(&self) -> i64 {
                    self.id
                }
                fn get_u_node_id(&self) -> i64 {
                    self.u
                }
                fn get_v_node_id(&self) -> i64 {
                    self.v
                }
            }
            impl EdgeQuery<ActiveModel, Model, Entity, PermManageEdge>
            for PermManageEdgeQuery {
                fn get_edge_type() -> &'static str {
                    "perm_manage"
                }
            }
            impl EdgeQueryPerm for PermManageEdgeQuery {
                async fn get_perm_v(
                    u: i64,
                    db: &DatabaseConnection,
                ) -> Result<Vec<(i64, i64)>> {
                    let edges = Entity::find()
                        .filter(Column::UNodeId.eq(u))
                        .all(db)
                        .await?;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| (edge.v_node_id, edge.perm))
                            .collect(),
                    )
                }
                fn get_perm_iter() -> impl Iterator<Item = i64> {
                    ManagePerm::iter().map(|perm| perm.get_const_isize().unwrap() as i64)
                }
                async fn get_all(
                    db: &DatabaseConnection,
                ) -> Result<Vec<(i64, i64, i64)>> {
                    let edges = Entity::find().all(db).await?;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| (edge.u_node_id, edge.v_node_id, edge.perm))
                            .collect(),
                    )
                }
            }
            use crate::Result;
            use crate::db::entity::edge::perm_manage::{
                ActiveModel, Column, Entity, Model,
            };
            use crate::graph::edge::{Edge, EdgeQuery, EdgeQueryPerm, EdgeRaw};
            use enum_const::EnumConst;
            use sea_orm::{ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter};
            use strum::IntoEnumIterator;
            use strum_macros::EnumIter;
            use tap::Conv;
        }
        pub mod perm_view {
            pub struct PermViewEdge {
                pub id: i64,
                pub u: i64,
                pub v: i64,
                pub perms: Vec<ViewPerm>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermViewEdge {
                #[inline]
                fn clone(&self) -> PermViewEdge {
                    PermViewEdge {
                        id: ::core::clone::Clone::clone(&self.id),
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        perms: ::core::clone::Clone::clone(&self.perms),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PermViewEdge {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "PermViewEdge",
                        "id",
                        &self.id,
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "perms",
                        &&self.perms,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PermViewEdge {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PermViewEdge {
                #[inline]
                fn eq(&self, other: &PermViewEdge) -> bool {
                    self.id == other.id && self.u == other.u && self.v == other.v
                        && self.perms == other.perms
                }
            }
            pub struct PermViewEdgeRaw {
                pub u: i64,
                pub v: i64,
                pub perms: ViewPermRaw,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermViewEdgeRaw {
                #[inline]
                fn clone(&self) -> PermViewEdgeRaw {
                    PermViewEdgeRaw {
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        perms: ::core::clone::Clone::clone(&self.perms),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PermViewEdgeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PermViewEdgeRaw",
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "perms",
                        &&self.perms,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PermViewEdgeRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PermViewEdgeRaw {
                #[inline]
                fn eq(&self, other: &PermViewEdgeRaw) -> bool {
                    self.u == other.u && self.v == other.v && self.perms == other.perms
                }
            }
            pub enum ViewPermRaw {
                All,
                Perms(Vec<ViewPerm>),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ViewPermRaw {
                #[inline]
                fn clone(&self) -> ViewPermRaw {
                    match self {
                        ViewPermRaw::All => ViewPermRaw::All,
                        ViewPermRaw::Perms(__self_0) => {
                            ViewPermRaw::Perms(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ViewPermRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ViewPermRaw::All => ::core::fmt::Formatter::write_str(f, "All"),
                        ViewPermRaw::Perms(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Perms",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ViewPermRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ViewPermRaw {
                #[inline]
                fn eq(&self, other: &ViewPermRaw) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                        && match (self, other) {
                            (
                                ViewPermRaw::Perms(__self_0),
                                ViewPermRaw::Perms(__arg1_0),
                            ) => __self_0 == __arg1_0,
                            _ => true,
                        }
                }
            }
            pub enum ViewPerm {
                All = -1,
                ReadProblem = 1,
                ViewPublic = 2,
                ViewPrivate = 4,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::enum_const::EnumConst for ViewPerm {
                fn get_const_isize(&self) -> Option<isize> {
                    match self {
                        Self::All => Some(-1),
                        Self::ReadProblem => Some(1),
                        Self::ViewPublic => Some(2),
                        Self::ViewPrivate => Some(4),
                        _ => None,
                    }
                }
                fn from_const_isize(i: isize) -> Option<Self> {
                    match i {
                        -1 => Some(Self::All),
                        1 => Some(Self::ReadProblem),
                        2 => Some(Self::ViewPublic),
                        4 => Some(Self::ViewPrivate),
                        _ => None,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ViewPerm {}
            #[automatically_derived]
            impl ::core::clone::Clone for ViewPerm {
                #[inline]
                fn clone(&self) -> ViewPerm {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ViewPerm {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            ViewPerm::All => "All",
                            ViewPerm::ReadProblem => "ReadProblem",
                            ViewPerm::ViewPublic => "ViewPublic",
                            ViewPerm::ViewPrivate => "ViewPrivate",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ViewPerm {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ViewPerm {
                #[inline]
                fn eq(&self, other: &ViewPerm) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            ///An iterator over the variants of [ViewPerm]
            #[allow(missing_copy_implementations)]
            pub struct ViewPermIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<fn() -> ()>,
            }
            impl ::core::fmt::Debug for ViewPermIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ViewPermIter").field("len", &self.len()).finish()
                }
            }
            impl ViewPermIter {
                fn get(&self, idx: usize) -> ::core::option::Option<ViewPerm> {
                    match idx {
                        0usize => ::core::option::Option::Some(ViewPerm::All),
                        1usize => ::core::option::Option::Some(ViewPerm::ReadProblem),
                        2usize => ::core::option::Option::Some(ViewPerm::ViewPublic),
                        3usize => ::core::option::Option::Some(ViewPerm::ViewPrivate),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::strum::IntoEnumIterator for ViewPerm {
                type Iterator = ViewPermIter;
                #[inline]
                fn iter() -> ViewPermIter {
                    ViewPermIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for ViewPermIter {
                type Item = ViewPerm;
                #[inline]
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                #[inline]
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 4usize {
                        0
                    } else {
                        4usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                #[inline]
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 4usize {
                        self.idx = 4usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        ViewPermIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for ViewPermIter {
                #[inline]
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for ViewPermIter {
                #[inline]
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 4usize {
                        self.back_idx = 4usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        ViewPermIter::get(self, 4usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for ViewPermIter {}
            impl Clone for ViewPermIter {
                #[inline]
                fn clone(&self) -> ViewPermIter {
                    ViewPermIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            impl From<ViewPermRaw> for i32 {
                fn from(perms: ViewPermRaw) -> i32 {
                    match perms {
                        ViewPermRaw::All => {
                            let mut res = 0;
                            for i in ViewPerm::iter() {
                                if i != ViewPerm::All {
                                    res |= i.get_const_isize().unwrap() as i32;
                                }
                            }
                            res
                        }
                        ViewPermRaw::Perms(perms) => {
                            let mut res = 0;
                            for perm in perms {
                                res |= perm.get_const_isize().unwrap() as i32;
                            }
                            res
                        }
                    }
                }
            }
            impl EdgeRaw<PermViewEdge, Model, ActiveModel> for PermViewEdgeRaw {
                fn get_edge_type(&self) -> &str {
                    "perm_view"
                }
                fn get_edge_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::EdgeId
                }
            }
            impl From<PermViewEdgeRaw> for ActiveModel {
                fn from(raw: PermViewEdgeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    use tap::Conv;
                    ActiveModel {
                        edge_id: NotSet,
                        u_node_id: Set(raw.u),
                        v_node_id: Set(raw.v),
                        perm: Set(raw.perms.conv::<i32>() as i64),
                    }
                }
            }
            impl From<Model> for PermViewEdge {
                fn from(model: Model) -> Self {
                    let perms: Perms = model.perm.into();
                    PermViewEdge {
                        id: model.edge_id,
                        u: model.u_node_id,
                        v: model.v_node_id,
                        perms: perms.0,
                    }
                }
            }
            impl Perm for ViewPerm {}
            pub struct Perms(Vec<ViewPerm>);
            impl From<i64> for Perms {
                fn from(perms: i64) -> Self {
                    let mut res = Vec::new();
                    if perms == -1 {
                        res.push(ViewPerm::All);
                    } else {
                        for perm in ViewPerm::iter() {
                            if (perms & perm.get_const_isize().unwrap() as i64) != 0 {
                                res.push(perm);
                            }
                        }
                    }
                    Perms(res)
                }
            }
            impl From<Perms> for i64 {
                fn from(perms: Perms) -> i64 {
                    let mut res = 0;
                    for perm in perms.0 {
                        res |= perm.get_const_isize().unwrap();
                    }
                    res as i64
                }
            }
            impl From<Vec<ViewPerm>> for Perms {
                fn from(perms: Vec<ViewPerm>) -> Self {
                    Perms(perms)
                }
            }
            impl From<&[ViewPerm]> for Perms {
                fn from(perms: &[ViewPerm]) -> Self {
                    Perms(perms.to_vec())
                }
            }
            pub struct PermViewEdgeQuery;
            #[automatically_derived]
            impl ::core::clone::Clone for PermViewEdgeQuery {
                #[inline]
                fn clone(&self) -> PermViewEdgeQuery {
                    PermViewEdgeQuery
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PermViewEdgeQuery {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PermViewEdgeQuery")
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PermViewEdgeQuery {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PermViewEdgeQuery {
                #[inline]
                fn eq(&self, other: &PermViewEdgeQuery) -> bool {
                    true
                }
            }
            impl Edge<ActiveModel, Model, Entity> for PermViewEdge {
                fn get_edge_id(&self) -> i64 {
                    self.id
                }
                fn get_u_node_id(&self) -> i64 {
                    self.u
                }
                fn get_v_node_id(&self) -> i64 {
                    self.v
                }
            }
            impl EdgeQuery<ActiveModel, Model, Entity, PermViewEdge>
            for PermViewEdgeQuery {
                fn get_edge_type() -> &'static str {
                    "perm_view"
                }
            }
            impl EdgeQueryPerm for PermViewEdgeQuery {
                async fn get_perm_v(
                    i: i64,
                    db: &DatabaseConnection,
                ) -> Result<Vec<(i64, i64)>> {
                    use crate::db::entity::edge::perm_view::Entity as PermViewEntity;
                    use sea_orm::{ColumnTrait, EntityTrait, QueryFilter};
                    let edges = PermViewEntity::find()
                        .filter(Column::UNodeId.eq(i))
                        .all(db)
                        .await?;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| (edge.v_node_id, edge.perm))
                            .collect(),
                    )
                }
                fn get_perm_iter() -> impl Iterator<Item = i64> {
                    ViewPerm::iter().map(|perm| perm.get_const_isize().unwrap() as i64)
                }
                async fn get_all(
                    db: &DatabaseConnection,
                ) -> Result<Vec<(i64, i64, i64)>> {
                    use crate::db::entity::edge::perm_view::Entity as PermViewEntity;
                    use sea_orm::EntityTrait;
                    let edges = PermViewEntity::find().all(db).await?;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| (edge.u_node_id, edge.v_node_id, edge.perm))
                            .collect(),
                    )
                }
            }
            use crate::Result;
            use crate::db::entity::edge::perm_view::{ActiveModel, Column, Entity, Model};
            use crate::graph::edge::EdgeQuery;
            use crate::graph::edge::EdgeRaw;
            use crate::graph::edge::{Edge, EdgeQueryPerm};
            use crate::utils::perm::Perm;
            use enum_const::EnumConst;
            use sea_orm::DatabaseConnection;
            use strum::IntoEnumIterator;
            use strum_macros::EnumIter;
        }
        pub mod problem_limit {
            pub struct ProblemLimitEdge {
                pub id: i64,
                pub u: i64,
                pub v: i64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemLimitEdge {
                #[inline]
                fn clone(&self) -> ProblemLimitEdge {
                    ProblemLimitEdge {
                        id: ::core::clone::Clone::clone(&self.id),
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemLimitEdge {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ProblemLimitEdge",
                        "id",
                        &self.id,
                        "u",
                        &self.u,
                        "v",
                        &&self.v,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemLimitEdge {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemLimitEdge {
                #[inline]
                fn eq(&self, other: &ProblemLimitEdge) -> bool {
                    self.id == other.id && self.u == other.u && self.v == other.v
                }
            }
            pub struct ProblemLimitEdgeRaw {
                pub u: i64,
                pub v: i64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemLimitEdgeRaw {
                #[inline]
                fn clone(&self) -> ProblemLimitEdgeRaw {
                    ProblemLimitEdgeRaw {
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemLimitEdgeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ProblemLimitEdgeRaw",
                        "u",
                        &self.u,
                        "v",
                        &&self.v,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemLimitEdgeRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemLimitEdgeRaw {
                #[inline]
                fn eq(&self, other: &ProblemLimitEdgeRaw) -> bool {
                    self.u == other.u && self.v == other.v
                }
            }
            impl EdgeRaw<ProblemLimitEdge, Model, ActiveModel> for ProblemLimitEdgeRaw {
                fn get_edge_type(&self) -> &str {
                    "problem_limit"
                }
                fn get_edge_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::EdgeId
                }
            }
            impl From<ProblemLimitEdgeRaw> for ActiveModel {
                fn from(raw: ProblemLimitEdgeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    ActiveModel {
                        edge_id: NotSet,
                        u_node_id: Set(raw.u),
                        v_node_id: Set(raw.v),
                    }
                }
            }
            pub struct ProblemLimitEdgeQuery;
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemLimitEdgeQuery {
                #[inline]
                fn clone(&self) -> ProblemLimitEdgeQuery {
                    ProblemLimitEdgeQuery
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemLimitEdgeQuery {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ProblemLimitEdgeQuery")
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemLimitEdgeQuery {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemLimitEdgeQuery {
                #[inline]
                fn eq(&self, other: &ProblemLimitEdgeQuery) -> bool {
                    true
                }
            }
            impl From<Model> for ProblemLimitEdge {
                fn from(model: Model) -> Self {
                    ProblemLimitEdge {
                        id: model.edge_id,
                        u: model.u_node_id,
                        v: model.v_node_id,
                    }
                }
            }
            impl Edge<ActiveModel, Model, Entity> for ProblemLimitEdge {
                fn get_edge_id(&self) -> i64 {
                    self.id
                }
                fn get_u_node_id(&self) -> i64 {
                    self.u
                }
                fn get_v_node_id(&self) -> i64 {
                    self.v
                }
            }
            impl EdgeQuery<ActiveModel, Model, Entity, ProblemLimitEdge>
            for ProblemLimitEdgeQuery {
                fn get_edge_type() -> &'static str {
                    "problem_limit"
                }
            }
            use crate::db::entity::edge::problem_limit::{
                ActiveModel, Column, Entity, Model,
            };
            use crate::graph::edge::{Edge, EdgeQuery, EdgeRaw};
        }
        pub mod problem_statement {
            pub struct ProblemStatementEdge {
                pub id: i64,
                pub u: i64,
                pub v: i64,
                pub copyright_risk: i64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemStatementEdge {
                #[inline]
                fn clone(&self) -> ProblemStatementEdge {
                    ProblemStatementEdge {
                        id: ::core::clone::Clone::clone(&self.id),
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        copyright_risk: ::core::clone::Clone::clone(&self.copyright_risk),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemStatementEdge {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "ProblemStatementEdge",
                        "id",
                        &self.id,
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "copyright_risk",
                        &&self.copyright_risk,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemStatementEdge {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemStatementEdge {
                #[inline]
                fn eq(&self, other: &ProblemStatementEdge) -> bool {
                    self.id == other.id && self.u == other.u && self.v == other.v
                        && self.copyright_risk == other.copyright_risk
                }
            }
            pub struct ProblemStatementEdgeRaw {
                pub u: i64,
                pub v: i64,
                pub copyright_risk: i64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemStatementEdgeRaw {
                #[inline]
                fn clone(&self) -> ProblemStatementEdgeRaw {
                    ProblemStatementEdgeRaw {
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                        copyright_risk: ::core::clone::Clone::clone(&self.copyright_risk),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemStatementEdgeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ProblemStatementEdgeRaw",
                        "u",
                        &self.u,
                        "v",
                        &self.v,
                        "copyright_risk",
                        &&self.copyright_risk,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemStatementEdgeRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemStatementEdgeRaw {
                #[inline]
                fn eq(&self, other: &ProblemStatementEdgeRaw) -> bool {
                    self.u == other.u && self.v == other.v
                        && self.copyright_risk == other.copyright_risk
                }
            }
            impl EdgeRaw<ProblemStatementEdge, Model, ActiveModel>
            for ProblemStatementEdgeRaw {
                fn get_edge_type(&self) -> &str {
                    "problem_statement"
                }
                fn get_edge_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::EdgeId
                }
            }
            impl From<ProblemStatementEdgeRaw> for ActiveModel {
                fn from(raw: ProblemStatementEdgeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    ActiveModel {
                        edge_id: NotSet,
                        u_node_id: Set(raw.u),
                        v_node_id: Set(raw.v),
                        copyright_risk: Set(raw.copyright_risk),
                    }
                }
            }
            impl From<Model> for ProblemStatementEdge {
                fn from(model: Model) -> Self {
                    ProblemStatementEdge {
                        id: model.edge_id,
                        u: model.u_node_id,
                        v: model.v_node_id,
                        copyright_risk: model.copyright_risk,
                    }
                }
            }
            pub struct ProblemStatementEdgeQuery;
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemStatementEdgeQuery {
                #[inline]
                fn clone(&self) -> ProblemStatementEdgeQuery {
                    ProblemStatementEdgeQuery
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemStatementEdgeQuery {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ProblemStatementEdgeQuery")
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemStatementEdgeQuery {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemStatementEdgeQuery {
                #[inline]
                fn eq(&self, other: &ProblemStatementEdgeQuery) -> bool {
                    true
                }
            }
            impl Edge<ActiveModel, Model, Entity> for ProblemStatementEdge {
                fn get_edge_id(&self) -> i64 {
                    self.id
                }
                fn get_u_node_id(&self) -> i64 {
                    self.u
                }
                fn get_v_node_id(&self) -> i64 {
                    self.v
                }
            }
            impl EdgeQuery<ActiveModel, Model, Entity, ProblemStatementEdge>
            for ProblemStatementEdgeQuery {
                fn get_edge_type() -> &'static str {
                    "problem_statement"
                }
            }
            use crate::db::entity::edge::problem_statement::{
                ActiveModel, Column, Entity, Model,
            };
            use crate::graph::edge::{Edge, EdgeQuery, EdgeRaw};
        }
        pub mod problem_tag {
            pub struct ProblemTagEdge {
                pub id: i64,
                pub u: i64,
                pub v: i64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemTagEdge {
                #[inline]
                fn clone(&self) -> ProblemTagEdge {
                    ProblemTagEdge {
                        id: ::core::clone::Clone::clone(&self.id),
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemTagEdge {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ProblemTagEdge",
                        "id",
                        &self.id,
                        "u",
                        &self.u,
                        "v",
                        &&self.v,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemTagEdge {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemTagEdge {
                #[inline]
                fn eq(&self, other: &ProblemTagEdge) -> bool {
                    self.id == other.id && self.u == other.u && self.v == other.v
                }
            }
            pub struct ProblemTagEdgeRaw {
                pub u: i64,
                pub v: i64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemTagEdgeRaw {
                #[inline]
                fn clone(&self) -> ProblemTagEdgeRaw {
                    ProblemTagEdgeRaw {
                        u: ::core::clone::Clone::clone(&self.u),
                        v: ::core::clone::Clone::clone(&self.v),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemTagEdgeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ProblemTagEdgeRaw",
                        "u",
                        &self.u,
                        "v",
                        &&self.v,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ProblemTagEdgeRaw {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ProblemTagEdgeRaw {
                #[inline]
                fn eq(&self, other: &ProblemTagEdgeRaw) -> bool {
                    self.u == other.u && self.v == other.v
                }
            }
            impl EdgeRaw<ProblemTagEdge, problem_tag::Model, problem_tag::ActiveModel>
            for ProblemTagEdgeRaw {
                fn get_edge_type(&self) -> &str {
                    "problem_tag"
                }
                fn get_edge_id_column(
                    &self,
                ) -> <<problem_tag::ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    problem_tag::Column::EdgeId
                }
            }
            impl From<ProblemTagEdgeRaw> for problem_tag::ActiveModel {
                fn from(raw: ProblemTagEdgeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    problem_tag::ActiveModel {
                        edge_id: NotSet,
                        u_node_id: Set(raw.u),
                        v_node_id: Set(raw.v),
                    }
                }
            }
            pub struct ProblemTagEdgeQuery;
            use crate::db::entity::edge::problem_tag;
            use crate::graph::edge::EdgeRaw;
        }
        pub trait EdgeQuery<DbActive, DbModel, DbEntity, EdgeA>
        where
            DbActive: DbEdgeActiveModel<DbModel, EdgeA> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbEdgeInfo,
            DbModel: Into<EdgeA>
                + From<
                    <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            <DbActive::Entity as EntityTrait>::Model: IntoActiveModel<DbActive>,
            Self: Sized + Send + Sync + Clone,
            DbEntity: EntityTrait,
            EdgeA: Edge<DbActive, DbModel, DbEntity>,
            <DbEntity as sea_orm::EntityTrait>::Model: Into<DbModel>,
        {
            fn get_u_edge_id_column() -> <DbEntity as EntityTrait>::Column {
                <DbEntity as EntityTrait>::Column::from_str("u_node_id").ok().unwrap()
            }
            fn get_v_edge_id_column() -> <DbEntity as EntityTrait>::Column {
                <DbEntity as EntityTrait>::Column::from_str("v_node_id").ok().unwrap()
            }
            fn get_u_edge_id_column_2() -> <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column::from_str(
                        "u_node_id",
                    )
                    .ok()
                    .unwrap()
            }
            fn get_v_edge_id_column_2() -> <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column::from_str(
                        "v_node_id",
                    )
                    .ok()
                    .unwrap()
            }
            fn get_v(
                u: i64,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Vec<i64>>> {
                async move {
                    use sea_orm::{ColumnTrait, QueryFilter};
                    let edges = DbEntity::find()
                        .filter(Self::get_u_edge_id_column().eq(u))
                        .all(db)
                        .await?;
                    use tap::Conv;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| {
                                edge.conv::<DbModel>().conv::<EdgeA>().get_v_node_id()
                            })
                            .collect(),
                    )
                }
            }
            fn get_v_filter<T: IntoCondition>(
                u: i64,
                filter: T,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Vec<i64>>> {
                async move {
                    use sea_orm::{ColumnTrait, QueryFilter};
                    let edges = DbEntity::find()
                        .filter(filter)
                        .filter(Self::get_u_edge_id_column().eq(u))
                        .all(db)
                        .await?;
                    use tap::Conv;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| {
                                edge.conv::<DbModel>().conv::<EdgeA>().get_v_node_id()
                            })
                            .collect(),
                    )
                }
            }
            fn get_u(
                v: i64,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Vec<i64>>> {
                async move {
                    use sea_orm::{ColumnTrait, QueryFilter};
                    let edges = DbEntity::find()
                        .filter(Self::get_v_edge_id_column().eq(v))
                        .all(db)
                        .await?;
                    use tap::Conv;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| {
                                edge.conv::<DbModel>().conv::<EdgeA>().get_u_node_id()
                            })
                            .collect(),
                    )
                }
            }
            fn get_u_one(
                v: i64,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<i64>> {
                async move {
                    use sea_orm::{ColumnTrait, QueryFilter};
                    let edge = DbEntity::find()
                        .filter(Self::get_v_edge_id_column().eq(v))
                        .one(db)
                        .await?;
                    if edge.is_none() {
                        return Err(NotFound("Not Found Edge id".to_string()));
                    }
                    use tap::Conv;
                    Ok(edge.unwrap().conv::<DbModel>().conv::<EdgeA>().get_u_node_id())
                }
            }
            fn get_v_one(
                u: i64,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<i64>> {
                async move {
                    use sea_orm::{ColumnTrait, QueryFilter};
                    let edge = DbEntity::find()
                        .filter(Self::get_u_edge_id_column().eq(u))
                        .one(db)
                        .await?;
                    if edge.is_none() {
                        return Err(NotFound("Not Found Edge id".to_string()));
                    }
                    use tap::Conv;
                    Ok(edge.unwrap().conv::<DbModel>().conv::<EdgeA>().get_v_node_id())
                }
            }
            fn get_u_filter<T: IntoCondition>(
                v: i64,
                filter: T,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Vec<i64>>> {
                async move {
                    use sea_orm::{ColumnTrait, QueryFilter};
                    let edges = DbEntity::find()
                        .filter(filter)
                        .filter(Self::get_v_edge_id_column().eq(v))
                        .all(db)
                        .await?;
                    use tap::Conv;
                    Ok(
                        edges
                            .into_iter()
                            .map(|edge| {
                                edge.conv::<DbModel>().conv::<EdgeA>().get_u_node_id()
                            })
                            .collect(),
                    )
                }
            }
            fn destroy_edge(
                db: &DatabaseConnection,
                u: i64,
                v: i64,
            ) -> impl std::future::Future<Output = Result<()>> {
                async move {
                    use sea_orm::{ColumnTrait, QueryFilter};
                    let mut edge = DbActive::new();
                    edge.set(Self::get_u_edge_id_column_2(), u.into());
                    edge.set(Self::get_v_edge_id_column_2(), v.into());
                    edge.delete(db).await?;
                    Ok(())
                }
            }
            fn get_edge_type() -> &'static str;
            fn check_perm(perm_a: i64, perm_b: i64) -> bool {
                (perm_a & perm_b) == perm_a
            }
        }
        pub trait EdgeQueryPerm {
            fn get_perm_v(
                i: i64,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Vec<(i64, i64)>>>;
            fn get_perm_iter() -> impl Iterator<Item = i64>;
            fn get_all(
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Vec<(i64, i64, i64)>>>;
        }
        pub trait Edge<DbActive, DbModel, DbEntity>
        where
            DbActive: DbEdgeActiveModel<DbModel, Self> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbEdgeInfo,
            DbModel: Into<Self>
                + From<
                    <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            <DbActive::Entity as EntityTrait>::Model: IntoActiveModel<DbActive>,
            Self: Sized + Send + Sync + Clone,
            DbEntity: EntityTrait,
            <DbEntity as sea_orm::EntityTrait>::Model: Into<DbModel>,
        {
            fn get_edge_id_column() -> <DbActive::Entity as EntityTrait>::Column {
                <DbActive::Entity as EntityTrait>::Column::from_str("edge_id")
                    .ok()
                    .unwrap()
            }
            fn get_edge_id(&self) -> i64;
            fn get_u_node_id(&self) -> i64;
            fn get_v_node_id(&self) -> i64;
            fn from_db(
                db: &DatabaseConnection,
                edge_id: i64,
            ) -> impl std::future::Future<Output = Result<Self>> + Send {
                async move {
                    use tap::Conv;
                    let edge_id_column = Self::get_edge_id_column();
                    use sea_orm::ColumnTrait;
                    use sea_orm::QueryFilter;
                    let model = DbEntity::find()
                        .filter(edge_id_column.eq(edge_id))
                        .one(db)
                        .await?
                        .ok_or_else(|| NotFound(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Edge with id {0} not found", edge_id),
                                )
                            }),
                        ))?;
                    Ok(model.conv::<DbModel>().into())
                }
            }
        }
        pub trait EdgeRaw<Edge, EdgeModel, EdgeActive>
        where
            Self: Into<EdgeActive> + Clone + Send + Sync + std::fmt::Debug,
            EdgeModel: Into<Edge> + Send + Sync
                + From<
                    <<EdgeActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            EdgeActive: DbEdgeActiveModel<EdgeModel, Edge> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbEdgeInfo,
            <EdgeActive::Entity as EntityTrait>::Model: IntoActiveModel<EdgeActive>
                + Send + Sync,
        {
            fn get_edge_type(&self) -> &str;
            fn get_edge_id_column(&self) -> <EdgeActive::Entity as EntityTrait>::Column;
            fn save(
                &self,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Edge>> {
                async {
                    use tap::Conv;
                    let edge_type = self.get_edge_type();
                    let edge_id = create_edge(db, edge_type).await?.edge_id;
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Saving edge({1}), data:{0:?}",
                                        *self,
                                        edge_type,
                                    ),
                                    lvl,
                                    &(
                                        "core::graph::edge",
                                        "core::graph::edge",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let mut value = (*self).clone().conv::<EdgeActive>();
                    value.set(self.get_edge_id_column(), edge_id.into());
                    Ok(value.save_into_db(db).await?.into())
                }
            }
        }
    }
    pub mod node {
        pub mod group {
            use serde::{Deserialize, Serialize};
            pub struct GroupNode {
                pub node_id: i64,
                pub node_iden: String,
                pub public: GroupNodePublic,
                pub private: GroupNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for GroupNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "node_iden" => _serde::__private::Ok(__Field::__field1),
                                    "public" => _serde::__private::Ok(__Field::__field2),
                                    "private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"node_iden" => _serde::__private::Ok(__Field::__field1),
                                    b"public" => _serde::__private::Ok(__Field::__field2),
                                    b"private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<GroupNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = GroupNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct GroupNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct GroupNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct GroupNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    GroupNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct GroupNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    GroupNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct GroupNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(GroupNode {
                                    node_id: __field0,
                                    node_iden: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    GroupNodePublic,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    GroupNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_iden",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    GroupNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    GroupNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_iden")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(GroupNode {
                                    node_id: __field0,
                                    node_iden: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "node_iden",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "GroupNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<GroupNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for GroupNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "GroupNode",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_iden",
                            &self.node_iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for GroupNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "GroupNode",
                        "node_id",
                        &self.node_id,
                        "node_iden",
                        &self.node_iden,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GroupNode {
                #[inline]
                fn clone(&self) -> GroupNode {
                    GroupNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        node_iden: ::core::clone::Clone::clone(&self.node_iden),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            pub struct GroupNodePublic {
                pub name: String,
                pub description: String,
                pub creation_time: i64,
                pub creation_order: i64,
                pub avatar: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for GroupNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "description" => _serde::__private::Ok(__Field::__field1),
                                    "creation_time" => _serde::__private::Ok(__Field::__field2),
                                    "creation_order" => _serde::__private::Ok(__Field::__field3),
                                    "avatar" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"description" => _serde::__private::Ok(__Field::__field1),
                                    b"creation_time" => _serde::__private::Ok(__Field::__field2),
                                    b"creation_order" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    b"avatar" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<GroupNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = GroupNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct GroupNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct GroupNodePublic with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct GroupNodePublic with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct GroupNodePublic with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct GroupNodePublic with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct GroupNodePublic with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(GroupNodePublic {
                                    name: __field0,
                                    description: __field1,
                                    creation_time: __field2,
                                    creation_order: __field3,
                                    avatar: __field4,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "description",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_time",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_order",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("avatar"),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("description")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_time")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_order")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("avatar")?
                                    }
                                };
                                _serde::__private::Ok(GroupNodePublic {
                                    name: __field0,
                                    description: __field1,
                                    creation_time: __field2,
                                    creation_order: __field3,
                                    avatar: __field4,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "description",
                            "creation_time",
                            "creation_order",
                            "avatar",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "GroupNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<GroupNodePublic>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for GroupNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "GroupNodePublic",
                            false as usize + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "description",
                            &self.description,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_time",
                            &self.creation_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_order",
                            &self.creation_order,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "avatar",
                            &self.avatar,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for GroupNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "GroupNodePublic",
                        "name",
                        &self.name,
                        "description",
                        &self.description,
                        "creation_time",
                        &self.creation_time,
                        "creation_order",
                        &self.creation_order,
                        "avatar",
                        &&self.avatar,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GroupNodePublic {
                #[inline]
                fn clone(&self) -> GroupNodePublic {
                    GroupNodePublic {
                        name: ::core::clone::Clone::clone(&self.name),
                        description: ::core::clone::Clone::clone(&self.description),
                        creation_time: ::core::clone::Clone::clone(&self.creation_time),
                        creation_order: ::core::clone::Clone::clone(
                            &self.creation_order,
                        ),
                        avatar: ::core::clone::Clone::clone(&self.avatar),
                    }
                }
            }
            pub struct GroupNodePrivate {
                pub info: Vec<String>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for GroupNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "info" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"info" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<GroupNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = GroupNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct GroupNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Vec<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct GroupNodePrivate with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(GroupNodePrivate { info: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("info"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("info")?
                                    }
                                };
                                _serde::__private::Ok(GroupNodePrivate { info: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["info"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "GroupNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<GroupNodePrivate>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for GroupNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "GroupNodePrivate",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "info",
                            &self.info,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for GroupNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "GroupNodePrivate",
                        "info",
                        &&self.info,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GroupNodePrivate {
                #[inline]
                fn clone(&self) -> GroupNodePrivate {
                    GroupNodePrivate {
                        info: ::core::clone::Clone::clone(&self.info),
                    }
                }
            }
            impl GroupNode {
                pub fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                pub fn get_node_iden(&self) -> String {
                    self.node_iden.clone()
                }
            }
        }
        pub mod iden {
            pub struct IdenNodePublic {
                pub iden: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for IdenNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "iden" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"iden" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<IdenNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = IdenNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct IdenNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct IdenNodePublic with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(IdenNodePublic { iden: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                _serde::__private::Ok(IdenNodePublic { iden: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["iden"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "IdenNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<IdenNodePublic>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for IdenNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "IdenNodePublic",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "IdenNodePublic",
                        "iden",
                        &&self.iden,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenNodePublic {
                #[inline]
                fn clone(&self) -> IdenNodePublic {
                    IdenNodePublic {
                        iden: ::core::clone::Clone::clone(&self.iden),
                    }
                }
            }
            pub struct IdenNodePrivate {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for IdenNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<IdenNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = IdenNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct IdenNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(IdenNodePrivate {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(IdenNodePrivate {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "IdenNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<IdenNodePrivate>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for IdenNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "IdenNodePrivate",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "IdenNodePrivate")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenNodePrivate {
                #[inline]
                fn clone(&self) -> IdenNodePrivate {
                    IdenNodePrivate {}
                }
            }
            pub struct IdenNodePublicRaw {
                pub iden: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for IdenNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "iden" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"iden" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<IdenNodePublicRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = IdenNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct IdenNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct IdenNodePublicRaw with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(IdenNodePublicRaw {
                                    iden: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                _serde::__private::Ok(IdenNodePublicRaw {
                                    iden: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["iden"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "IdenNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<IdenNodePublicRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for IdenNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "IdenNodePublicRaw",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "IdenNodePublicRaw",
                        "iden",
                        &&self.iden,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenNodePublicRaw {
                #[inline]
                fn clone(&self) -> IdenNodePublicRaw {
                    IdenNodePublicRaw {
                        iden: ::core::clone::Clone::clone(&self.iden),
                    }
                }
            }
            pub struct IdenNodePrivateRaw {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for IdenNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<IdenNodePrivateRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = IdenNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct IdenNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(IdenNodePrivateRaw {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(IdenNodePrivateRaw {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "IdenNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    IdenNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for IdenNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "IdenNodePrivateRaw",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "IdenNodePrivateRaw")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenNodePrivateRaw {
                #[inline]
                fn clone(&self) -> IdenNodePrivateRaw {
                    IdenNodePrivateRaw {}
                }
            }
            pub struct IdenNode {
                pub node_id: i64,
                pub public: IdenNodePublic,
                pub private: IdenNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for IdenNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<IdenNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = IdenNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct IdenNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct IdenNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    IdenNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct IdenNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    IdenNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct IdenNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(IdenNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    IdenNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    IdenNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    IdenNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    IdenNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(IdenNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "IdenNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<IdenNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for IdenNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "IdenNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "IdenNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenNode {
                #[inline]
                fn clone(&self) -> IdenNode {
                    IdenNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl Node<ActiveModel, Model, Entity> for IdenNode {
                fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::NodeId
                }
            }
            #[node_raw(node_type = "iden")]
            pub struct IdenNodeRaw {
                pub public: IdenNodePublicRaw,
                pub private: IdenNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for IdenNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "public" => _serde::__private::Ok(__Field::__field0),
                                    "private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"public" => _serde::__private::Ok(__Field::__field0),
                                    b"private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<IdenNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = IdenNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct IdenNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    IdenNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct IdenNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    IdenNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct IdenNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(IdenNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    IdenNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    IdenNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    IdenNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    IdenNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(IdenNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["public", "private"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "IdenNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<IdenNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for IdenNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "IdenNodeRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for IdenNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "IdenNodeRaw",
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdenNodeRaw {
                #[inline]
                fn clone(&self) -> IdenNodeRaw {
                    IdenNodeRaw {
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl NodeRaw<IdenNode, Model, ActiveModel> for IdenNodeRaw {
                fn get_node_type(&self) -> &str {
                    "iden"
                }
                fn get_node_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::NodeId
                }
            }
            impl From<Model> for IdenNode {
                fn from(model: Model) -> Self {
                    IdenNode {
                        node_id: model.node_id,
                        public: IdenNodePublic { iden: model.iden },
                        private: IdenNodePrivate {},
                    }
                }
            }
            impl From<IdenNodeRaw> for ActiveModel {
                fn from(value: IdenNodeRaw) -> Self {
                    ActiveModel {
                        node_id: NotSet,
                        iden: Set(value.public.iden),
                    }
                }
            }
            use crate::db::entity::node::iden::{ActiveModel, Column, Entity, Model};
            use crate::graph::node::{Node, NodeRaw};
            use macro_node_iden::{Node, NodeRaw};
            use sea_orm::ActiveValue::{NotSet, Set};
            use sea_orm::EntityTrait;
            use serde::{Deserialize, Serialize};
        }
        pub mod pages {
            use serde::{Deserialize, Serialize};
            use db::entity::node::pages::ActiveModel as PagesNodeActiveModel;
            use db::entity::node::pages::Column as PagesNodeColumn;
            use db::entity::node::pages::Model as PagesNodeModel;
            use crate::db;
            use crate::graph::node::NodeRaw;
            pub struct PagesNodePublic {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PagesNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PagesNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PagesNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PagesNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(PagesNodePublic {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(PagesNodePublic {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PagesNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PagesNodePublic>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PagesNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PagesNodePublic",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PagesNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PagesNodePublic")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PagesNodePublic {
                #[inline]
                fn clone(&self) -> PagesNodePublic {
                    PagesNodePublic {}
                }
            }
            pub struct PagesNodePrivate {
                pub name: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PagesNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PagesNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PagesNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PagesNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PagesNodePrivate with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PagesNodePrivate { name: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                _serde::__private::Ok(PagesNodePrivate { name: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PagesNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PagesNodePrivate>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PagesNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PagesNodePrivate",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PagesNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "PagesNodePrivate",
                        "name",
                        &&self.name,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PagesNodePrivate {
                #[inline]
                fn clone(&self) -> PagesNodePrivate {
                    PagesNodePrivate {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            pub struct PagesNodePublicRaw {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PagesNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PagesNodePublicRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PagesNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PagesNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(PagesNodePublicRaw {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(PagesNodePublicRaw {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PagesNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    PagesNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PagesNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PagesNodePublicRaw",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PagesNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PagesNodePublicRaw")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PagesNodePublicRaw {
                #[inline]
                fn clone(&self) -> PagesNodePublicRaw {
                    PagesNodePublicRaw {}
                }
            }
            pub struct PagesNodePrivateRaw {
                pub name: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PagesNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PagesNodePrivateRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PagesNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PagesNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PagesNodePrivateRaw with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PagesNodePrivateRaw {
                                    name: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                _serde::__private::Ok(PagesNodePrivateRaw {
                                    name: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PagesNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    PagesNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PagesNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PagesNodePrivateRaw",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PagesNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "PagesNodePrivateRaw",
                        "name",
                        &&self.name,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PagesNodePrivateRaw {
                #[inline]
                fn clone(&self) -> PagesNodePrivateRaw {
                    PagesNodePrivateRaw {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            pub struct PagesNode {
                pub node_id: i64,
                pub public: PagesNodePublic,
                pub private: PagesNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PagesNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PagesNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PagesNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PagesNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PagesNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    PagesNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct PagesNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    PagesNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct PagesNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PagesNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    PagesNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    PagesNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PagesNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PagesNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(PagesNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PagesNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PagesNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PagesNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PagesNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PagesNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PagesNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PagesNode {
                #[inline]
                fn clone(&self) -> PagesNode {
                    PagesNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            pub struct PagesNodeRaw {
                pub iden: String,
                pub public: PagesNodePublicRaw,
                pub private: PagesNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PagesNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "iden" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"iden" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PagesNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PagesNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PagesNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PagesNodeRaw with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    PagesNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct PagesNodeRaw with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    PagesNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct PagesNodeRaw with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PagesNodeRaw {
                                    iden: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    PagesNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    PagesNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PagesNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PagesNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(PagesNodeRaw {
                                    iden: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "iden",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PagesNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PagesNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PagesNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PagesNodeRaw",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PagesNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PagesNodeRaw",
                        "iden",
                        &self.iden,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PagesNodeRaw {
                #[inline]
                fn clone(&self) -> PagesNodeRaw {
                    PagesNodeRaw {
                        iden: ::core::clone::Clone::clone(&self.iden),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl From<PagesNodeRaw> for PagesNodeActiveModel {
                fn from(value: PagesNodeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    Self {
                        node_id: NotSet,
                        iden: Set(value.iden),
                    }
                }
            }
            impl NodeRaw<PagesNode, PagesNodeModel, PagesNodeActiveModel>
            for PagesNodeRaw {
                fn get_node_id_column(
                    &self,
                ) -> <<PagesNodeActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    PagesNodeColumn::NodeId
                }
                fn get_node_type(&self) -> &str {
                    "pages"
                }
            }
        }
        pub mod perm_group {
            use serde::{Deserialize, Serialize};
            use db::entity::node::perm_group::ActiveModel as PermGroupNodeActiveModel;
            use db::entity::node::perm_group::Column as PermGroupNodeColumn;
            use db::entity::node::perm_group::Model as PermGroupNodeModel;
            use crate::db;
            use crate::graph::node::NodeRaw;
            pub struct PermGroupNodePublic {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PermGroupNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PermGroupNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PermGroupNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PermGroupNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(PermGroupNodePublic {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(PermGroupNodePublic {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PermGroupNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    PermGroupNodePublic,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PermGroupNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PermGroupNodePublic",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PermGroupNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PermGroupNodePublic")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermGroupNodePublic {
                #[inline]
                fn clone(&self) -> PermGroupNodePublic {
                    PermGroupNodePublic {}
                }
            }
            pub struct PermGroupNodePrivate {
                pub name: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PermGroupNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PermGroupNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PermGroupNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PermGroupNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PermGroupNodePrivate with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PermGroupNodePrivate {
                                    name: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                _serde::__private::Ok(PermGroupNodePrivate {
                                    name: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PermGroupNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    PermGroupNodePrivate,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PermGroupNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PermGroupNodePrivate",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PermGroupNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "PermGroupNodePrivate",
                        "name",
                        &&self.name,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermGroupNodePrivate {
                #[inline]
                fn clone(&self) -> PermGroupNodePrivate {
                    PermGroupNodePrivate {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            pub struct PermGroupNodePublicRaw {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PermGroupNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                PermGroupNodePublicRaw,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PermGroupNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PermGroupNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(PermGroupNodePublicRaw {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(PermGroupNodePublicRaw {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PermGroupNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    PermGroupNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PermGroupNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PermGroupNodePublicRaw",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PermGroupNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "PermGroupNodePublicRaw")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermGroupNodePublicRaw {
                #[inline]
                fn clone(&self) -> PermGroupNodePublicRaw {
                    PermGroupNodePublicRaw {}
                }
            }
            pub struct PermGroupNodePrivateRaw {
                pub name: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PermGroupNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                PermGroupNodePrivateRaw,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PermGroupNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PermGroupNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PermGroupNodePrivateRaw with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PermGroupNodePrivateRaw {
                                    name: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                _serde::__private::Ok(PermGroupNodePrivateRaw {
                                    name: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PermGroupNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    PermGroupNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PermGroupNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PermGroupNodePrivateRaw",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PermGroupNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "PermGroupNodePrivateRaw",
                        "name",
                        &&self.name,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermGroupNodePrivateRaw {
                #[inline]
                fn clone(&self) -> PermGroupNodePrivateRaw {
                    PermGroupNodePrivateRaw {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            pub struct PermGroupNode {
                pub node_id: i64,
                pub public: PermGroupNodePublic,
                pub private: PermGroupNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PermGroupNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PermGroupNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PermGroupNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PermGroupNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PermGroupNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    PermGroupNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct PermGroupNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    PermGroupNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct PermGroupNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PermGroupNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    PermGroupNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    PermGroupNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PermGroupNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PermGroupNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(PermGroupNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PermGroupNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PermGroupNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PermGroupNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PermGroupNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PermGroupNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PermGroupNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermGroupNode {
                #[inline]
                fn clone(&self) -> PermGroupNode {
                    PermGroupNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            pub struct PermGroupNodeRaw {
                pub iden: String,
                pub service: String,
                pub public: PermGroupNodePublicRaw,
                pub private: PermGroupNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PermGroupNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "iden" => _serde::__private::Ok(__Field::__field0),
                                    "service" => _serde::__private::Ok(__Field::__field1),
                                    "public" => _serde::__private::Ok(__Field::__field2),
                                    "private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"iden" => _serde::__private::Ok(__Field::__field0),
                                    b"service" => _serde::__private::Ok(__Field::__field1),
                                    b"public" => _serde::__private::Ok(__Field::__field2),
                                    b"private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PermGroupNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PermGroupNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PermGroupNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PermGroupNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct PermGroupNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    PermGroupNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct PermGroupNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    PermGroupNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct PermGroupNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PermGroupNodeRaw {
                                    iden: __field0,
                                    service: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    PermGroupNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    PermGroupNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "service",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PermGroupNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    PermGroupNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("service")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(PermGroupNodeRaw {
                                    iden: __field0,
                                    service: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "iden",
                            "service",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PermGroupNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PermGroupNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PermGroupNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PermGroupNodeRaw",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "service",
                            &self.service,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for PermGroupNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "PermGroupNodeRaw",
                        "iden",
                        &self.iden,
                        "service",
                        &self.service,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PermGroupNodeRaw {
                #[inline]
                fn clone(&self) -> PermGroupNodeRaw {
                    PermGroupNodeRaw {
                        iden: ::core::clone::Clone::clone(&self.iden),
                        service: ::core::clone::Clone::clone(&self.service),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl From<PermGroupNodeRaw> for PermGroupNodeActiveModel {
                fn from(value: PermGroupNodeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    Self {
                        node_id: NotSet,
                        iden: Set(value.iden),
                    }
                }
            }
            impl NodeRaw<PermGroupNode, PermGroupNodeModel, PermGroupNodeActiveModel>
            for PermGroupNodeRaw {
                fn get_node_id_column(
                    &self,
                ) -> <<PermGroupNodeActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    PermGroupNodeColumn::NodeId
                }
                fn get_node_type(&self) -> &str {
                    "perm_group"
                }
            }
        }
        pub mod problem {
            pub struct ProblemNodePublic {
                pub name: String,
                pub creation_time: NaiveDateTime,
                pub creation_order: i64,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "creation_time" => _serde::__private::Ok(__Field::__field1),
                                    "creation_order" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"creation_time" => _serde::__private::Ok(__Field::__field1),
                                    b"creation_order" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProblemNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemNodePublic with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemNodePublic with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ProblemNodePublic with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemNodePublic {
                                    name: __field0,
                                    creation_time: __field1,
                                    creation_order: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_time",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_order",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_time")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_order")?
                                    }
                                };
                                _serde::__private::Ok(ProblemNodePublic {
                                    name: __field0,
                                    creation_time: __field1,
                                    creation_order: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "creation_time",
                            "creation_order",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ProblemNodePublic>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemNodePublic",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_time",
                            &self.creation_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_order",
                            &self.creation_order,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ProblemNodePublic",
                        "name",
                        &self.name,
                        "creation_time",
                        &self.creation_time,
                        "creation_order",
                        &&self.creation_order,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemNodePublic {
                #[inline]
                fn clone(&self) -> ProblemNodePublic {
                    ProblemNodePublic {
                        name: ::core::clone::Clone::clone(&self.name),
                        creation_time: ::core::clone::Clone::clone(&self.creation_time),
                        creation_order: ::core::clone::Clone::clone(&self.creation_order),
                    }
                }
            }
            pub struct ProblemNodePrivate {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProblemNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(ProblemNodePrivate {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(ProblemNodePrivate {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemNodePrivate,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemNodePrivate",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ProblemNodePrivate")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemNodePrivate {
                #[inline]
                fn clone(&self) -> ProblemNodePrivate {
                    ProblemNodePrivate {}
                }
            }
            pub struct ProblemNodePublicRaw {
                pub name: String,
                pub creation_time: NaiveDateTime,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "creation_time" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"creation_time" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProblemNodePublicRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemNodePublicRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemNodePublicRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemNodePublicRaw {
                                    name: __field0,
                                    creation_time: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_time",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_time")?
                                    }
                                };
                                _serde::__private::Ok(ProblemNodePublicRaw {
                                    name: __field0,
                                    creation_time: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "creation_time",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemNodePublicRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_time",
                            &self.creation_time,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ProblemNodePublicRaw",
                        "name",
                        &self.name,
                        "creation_time",
                        &&self.creation_time,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemNodePublicRaw {
                #[inline]
                fn clone(&self) -> ProblemNodePublicRaw {
                    ProblemNodePublicRaw {
                        name: ::core::clone::Clone::clone(&self.name),
                        creation_time: ::core::clone::Clone::clone(&self.creation_time),
                    }
                }
            }
            pub struct ProblemNodePrivateRaw {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ProblemNodePrivateRaw,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(ProblemNodePrivateRaw {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(ProblemNodePrivateRaw {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemNodePrivateRaw",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ProblemNodePrivateRaw")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemNodePrivateRaw {
                #[inline]
                fn clone(&self) -> ProblemNodePrivateRaw {
                    ProblemNodePrivateRaw {}
                }
            }
            pub struct ProblemNode {
                pub node_id: i64,
                pub public: ProblemNodePublic,
                pub private: ProblemNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProblemNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    ProblemNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    ProblemNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ProblemNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    ProblemNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    ProblemNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(ProblemNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ProblemNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ProblemNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemNode {
                #[inline]
                fn clone(&self) -> ProblemNode {
                    ProblemNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl Node<ActiveModel, Model, Entity> for ProblemNode {
                fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::NodeId
                }
            }
            #[node_raw(node_type = "problem")]
            pub struct ProblemNodeRaw {
                pub public: ProblemNodePublicRaw,
                pub private: ProblemNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "public" => _serde::__private::Ok(__Field::__field0),
                                    "private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"public" => _serde::__private::Ok(__Field::__field0),
                                    b"private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProblemNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    ProblemNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    ProblemNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    ProblemNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    ProblemNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(ProblemNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["public", "private"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ProblemNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemNodeRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ProblemNodeRaw",
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemNodeRaw {
                #[inline]
                fn clone(&self) -> ProblemNodeRaw {
                    ProblemNodeRaw {
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl NodeRaw<ProblemNode, Model, ActiveModel> for ProblemNodeRaw {
                fn get_node_type(&self) -> &str {
                    "problem"
                }
                fn get_node_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::NodeId
                }
            }
            impl From<Model> for ProblemNode {
                fn from(model: Model) -> Self {
                    ProblemNode {
                        node_id: model.node_id,
                        public: ProblemNodePublic {
                            name: model.name,
                            creation_time: model.creation_time,
                            creation_order: model.creation_order,
                        },
                        private: ProblemNodePrivate {},
                    }
                }
            }
            impl From<ProblemNodeRaw> for ActiveModel {
                fn from(value: ProblemNodeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    Self {
                        node_id: NotSet,
                        name: Set(value.public.name),
                        content_public: Set("".to_string()),
                        content_private: Set("".to_string()),
                        creation_time: Set(value.public.creation_time),
                        creation_order: NotSet,
                    }
                }
            }
            pub mod limit {
                pub struct ProblemLimitNodePublic {
                    pub time_limit: i64,
                    pub memory_limit: i64,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemLimitNodePublic {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "time_limit" => _serde::__private::Ok(__Field::__field0),
                                        "memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"time_limit" => _serde::__private::Ok(__Field::__field0),
                                        b"memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemLimitNodePublic,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemLimitNodePublic;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemLimitNodePublic",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemLimitNodePublic with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemLimitNodePublic with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNodePublic {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "time_limit",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "memory_limit",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("time_limit")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("memory_limit")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNodePublic {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "time_limit",
                                "memory_limit",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemLimitNodePublic",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemLimitNodePublic,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemLimitNodePublic {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemLimitNodePublic",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "time_limit",
                                &self.time_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "memory_limit",
                                &self.memory_limit,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemLimitNodePublic {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ProblemLimitNodePublic",
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &&self.memory_limit,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemLimitNodePublic {
                    #[inline]
                    fn clone(&self) -> ProblemLimitNodePublic {
                        ProblemLimitNodePublic {
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(&self.memory_limit),
                        }
                    }
                }
                pub struct ProblemLimitNodePrivate {}
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemLimitNodePrivate {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemLimitNodePrivate,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemLimitNodePrivate;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemLimitNodePrivate",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(ProblemLimitNodePrivate {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(ProblemLimitNodePrivate {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemLimitNodePrivate",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemLimitNodePrivate,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemLimitNodePrivate {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemLimitNodePrivate",
                                false as usize,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemLimitNodePrivate {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "ProblemLimitNodePrivate")
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemLimitNodePrivate {
                    #[inline]
                    fn clone(&self) -> ProblemLimitNodePrivate {
                        ProblemLimitNodePrivate {}
                    }
                }
                pub struct ProblemLimitNodePublicRaw {
                    pub time_limit: i64,
                    pub memory_limit: i64,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemLimitNodePublicRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "time_limit" => _serde::__private::Ok(__Field::__field0),
                                        "memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"time_limit" => _serde::__private::Ok(__Field::__field0),
                                        b"memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemLimitNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemLimitNodePublicRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemLimitNodePublicRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemLimitNodePublicRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemLimitNodePublicRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNodePublicRaw {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "time_limit",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "memory_limit",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("time_limit")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("memory_limit")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNodePublicRaw {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "time_limit",
                                "memory_limit",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemLimitNodePublicRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemLimitNodePublicRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemLimitNodePublicRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemLimitNodePublicRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "time_limit",
                                &self.time_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "memory_limit",
                                &self.memory_limit,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemLimitNodePublicRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ProblemLimitNodePublicRaw",
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &&self.memory_limit,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemLimitNodePublicRaw {
                    #[inline]
                    fn clone(&self) -> ProblemLimitNodePublicRaw {
                        ProblemLimitNodePublicRaw {
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(&self.memory_limit),
                        }
                    }
                }
                pub struct ProblemLimitNodePrivateRaw {}
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemLimitNodePrivateRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemLimitNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemLimitNodePrivateRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemLimitNodePrivateRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(ProblemLimitNodePrivateRaw {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(ProblemLimitNodePrivateRaw {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemLimitNodePrivateRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemLimitNodePrivateRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemLimitNodePrivateRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemLimitNodePrivateRaw",
                                false as usize,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemLimitNodePrivateRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "ProblemLimitNodePrivateRaw",
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemLimitNodePrivateRaw {
                    #[inline]
                    fn clone(&self) -> ProblemLimitNodePrivateRaw {
                        ProblemLimitNodePrivateRaw {}
                    }
                }
                pub struct ProblemLimitNode {
                    pub node_id: i64,
                    pub public: ProblemLimitNodePublic,
                    pub private: ProblemLimitNodePrivate,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemLimitNode {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "public" => _serde::__private::Ok(__Field::__field1),
                                        "private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"public" => _serde::__private::Ok(__Field::__field1),
                                        b"private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<ProblemLimitNode>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemLimitNode;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemLimitNode",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemLimitNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        ProblemLimitNodePublic,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemLimitNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        ProblemLimitNodePrivate,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct ProblemLimitNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        ProblemLimitNodePublic,
                                    > = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<
                                        ProblemLimitNodePrivate,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemLimitNodePublic,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemLimitNodePrivate,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "node_id",
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemLimitNode",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<ProblemLimitNode>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemLimitNode {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemLimitNode",
                                false as usize + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemLimitNode {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ProblemLimitNode",
                            "node_id",
                            &self.node_id,
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemLimitNode {
                    #[inline]
                    fn clone(&self) -> ProblemLimitNode {
                        ProblemLimitNode {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl Node<ActiveModel, Model, Entity> for ProblemLimitNode {
                    fn get_node_id(&self) -> i64 {
                        self.node_id
                    }
                    fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                #[node_raw(node_type = "problem_limit")]
                pub struct ProblemLimitNodeRaw {
                    pub public: ProblemLimitNodePublicRaw,
                    pub private: ProblemLimitNodePrivateRaw,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemLimitNodeRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "public" => _serde::__private::Ok(__Field::__field0),
                                        "private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"public" => _serde::__private::Ok(__Field::__field0),
                                        b"private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<ProblemLimitNodeRaw>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemLimitNodeRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemLimitNodeRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        ProblemLimitNodePublicRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemLimitNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        ProblemLimitNodePrivateRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemLimitNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        ProblemLimitNodePublicRaw,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        ProblemLimitNodePrivateRaw,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemLimitNodePublicRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemLimitNodePrivateRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemLimitNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemLimitNodeRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemLimitNodeRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemLimitNodeRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemLimitNodeRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemLimitNodeRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ProblemLimitNodeRaw",
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemLimitNodeRaw {
                    #[inline]
                    fn clone(&self) -> ProblemLimitNodeRaw {
                        ProblemLimitNodeRaw {
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl NodeRaw<ProblemLimitNode, Model, ActiveModel>
                for ProblemLimitNodeRaw {
                    fn get_node_type(&self) -> &str {
                        "problem_limit"
                    }
                    fn get_node_id_column(
                        &self,
                    ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                impl From<Model> for ProblemLimitNode {
                    fn from(model: Model) -> Self {
                        ProblemLimitNode {
                            node_id: model.node_id,
                            public: ProblemLimitNodePublic {
                                time_limit: model.time_limit,
                                memory_limit: model.memory_limit,
                            },
                            private: ProblemLimitNodePrivate {},
                        }
                    }
                }
                impl From<ProblemLimitNodeRaw> for ActiveModel {
                    fn from(value: ProblemLimitNodeRaw) -> Self {
                        ActiveModel {
                            node_id: NotSet,
                            time_limit: Set(value.public.time_limit),
                            memory_limit: Set(value.public.memory_limit),
                        }
                    }
                }
                use macro_node_iden::{Node, NodeRaw};
                use sea_orm::ActiveValue::{NotSet, Set};
                use sea_orm::EntityTrait;
                use serde::{Deserialize, Serialize};
                use crate::db::entity::node::problem_limit::{
                    ActiveModel, Column, Entity, Model,
                };
                use crate::graph::node::{Node, NodeRaw};
            }
            pub mod statement {
                pub struct ProblemStatementNodePublic {
                    pub statements: Vec<ContentType>,
                    pub source: String,
                    pub creation_time: NaiveDateTime,
                    pub update_time: NaiveDateTime,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemStatementNodePublic {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "statements" => _serde::__private::Ok(__Field::__field0),
                                        "source" => _serde::__private::Ok(__Field::__field1),
                                        "creation_time" => _serde::__private::Ok(__Field::__field2),
                                        "update_time" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"statements" => _serde::__private::Ok(__Field::__field0),
                                        b"source" => _serde::__private::Ok(__Field::__field1),
                                        b"creation_time" => _serde::__private::Ok(__Field::__field2),
                                        b"update_time" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemStatementNodePublic,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemStatementNodePublic;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemStatementNodePublic",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        Vec<ContentType>,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemStatementNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemStatementNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        NaiveDateTime,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct ProblemStatementNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        NaiveDateTime,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct ProblemStatementNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNodePublic {
                                        statements: __field0,
                                        source: __field1,
                                        creation_time: __field2,
                                        update_time: __field3,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        Vec<ContentType>,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<
                                        NaiveDateTime,
                                    > = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<
                                        NaiveDateTime,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "statements",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        Vec<ContentType>,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "creation_time",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        NaiveDateTime,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "update_time",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        NaiveDateTime,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("statements")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("source")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("creation_time")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("update_time")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNodePublic {
                                        statements: __field0,
                                        source: __field1,
                                        creation_time: __field2,
                                        update_time: __field3,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "statements",
                                "source",
                                "creation_time",
                                "update_time",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemStatementNodePublic",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemStatementNodePublic,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemStatementNodePublic {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemStatementNodePublic",
                                false as usize + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "statements",
                                &self.statements,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "source",
                                &self.source,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "creation_time",
                                &self.creation_time,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "update_time",
                                &self.update_time,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemStatementNodePublic {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "ProblemStatementNodePublic",
                            "statements",
                            &self.statements,
                            "source",
                            &self.source,
                            "creation_time",
                            &self.creation_time,
                            "update_time",
                            &&self.update_time,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemStatementNodePublic {
                    #[inline]
                    fn clone(&self) -> ProblemStatementNodePublic {
                        ProblemStatementNodePublic {
                            statements: ::core::clone::Clone::clone(&self.statements),
                            source: ::core::clone::Clone::clone(&self.source),
                            creation_time: ::core::clone::Clone::clone(
                                &self.creation_time,
                            ),
                            update_time: ::core::clone::Clone::clone(&self.update_time),
                        }
                    }
                }
                pub struct ProblemStatementNodePrivate {}
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemStatementNodePrivate {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemStatementNodePrivate,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemStatementNodePrivate;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemStatementNodePrivate",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(ProblemStatementNodePrivate {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(ProblemStatementNodePrivate {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemStatementNodePrivate",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemStatementNodePrivate,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemStatementNodePrivate {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemStatementNodePrivate",
                                false as usize,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemStatementNodePrivate {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "ProblemStatementNodePrivate",
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemStatementNodePrivate {
                    #[inline]
                    fn clone(&self) -> ProblemStatementNodePrivate {
                        ProblemStatementNodePrivate {}
                    }
                }
                pub struct ProblemStatementNodePublicRaw {
                    pub statements: Vec<ContentType>,
                    pub source: String,
                    pub iden: String,
                    pub creation_time: NaiveDateTime,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de>
                    for ProblemStatementNodePublicRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "statements" => _serde::__private::Ok(__Field::__field0),
                                        "source" => _serde::__private::Ok(__Field::__field1),
                                        "iden" => _serde::__private::Ok(__Field::__field2),
                                        "creation_time" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"statements" => _serde::__private::Ok(__Field::__field0),
                                        b"source" => _serde::__private::Ok(__Field::__field1),
                                        b"iden" => _serde::__private::Ok(__Field::__field2),
                                        b"creation_time" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemStatementNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemStatementNodePublicRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemStatementNodePublicRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        Vec<ContentType>,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemStatementNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemStatementNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct ProblemStatementNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        NaiveDateTime,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct ProblemStatementNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNodePublicRaw {
                                        statements: __field0,
                                        source: __field1,
                                        iden: __field2,
                                        creation_time: __field3,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        Vec<ContentType>,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<
                                        NaiveDateTime,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "statements",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        Vec<ContentType>,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "creation_time",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        NaiveDateTime,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("statements")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("source")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("iden")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("creation_time")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNodePublicRaw {
                                        statements: __field0,
                                        source: __field1,
                                        iden: __field2,
                                        creation_time: __field3,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "statements",
                                "source",
                                "iden",
                                "creation_time",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemStatementNodePublicRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemStatementNodePublicRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemStatementNodePublicRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemStatementNodePublicRaw",
                                false as usize + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "statements",
                                &self.statements,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "source",
                                &self.source,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "iden",
                                &self.iden,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "creation_time",
                                &self.creation_time,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemStatementNodePublicRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "ProblemStatementNodePublicRaw",
                            "statements",
                            &self.statements,
                            "source",
                            &self.source,
                            "iden",
                            &self.iden,
                            "creation_time",
                            &&self.creation_time,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemStatementNodePublicRaw {
                    #[inline]
                    fn clone(&self) -> ProblemStatementNodePublicRaw {
                        ProblemStatementNodePublicRaw {
                            statements: ::core::clone::Clone::clone(&self.statements),
                            source: ::core::clone::Clone::clone(&self.source),
                            iden: ::core::clone::Clone::clone(&self.iden),
                            creation_time: ::core::clone::Clone::clone(
                                &self.creation_time,
                            ),
                        }
                    }
                }
                pub struct ProblemStatementNodePrivateRaw {}
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de>
                    for ProblemStatementNodePrivateRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemStatementNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemStatementNodePrivateRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemStatementNodePrivateRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(ProblemStatementNodePrivateRaw {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(ProblemStatementNodePrivateRaw {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemStatementNodePrivateRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemStatementNodePrivateRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemStatementNodePrivateRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemStatementNodePrivateRaw",
                                false as usize,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemStatementNodePrivateRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "ProblemStatementNodePrivateRaw",
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemStatementNodePrivateRaw {
                    #[inline]
                    fn clone(&self) -> ProblemStatementNodePrivateRaw {
                        ProblemStatementNodePrivateRaw {}
                    }
                }
                pub struct ProblemStatementNode {
                    pub node_id: i64,
                    pub public: ProblemStatementNodePublic,
                    pub private: ProblemStatementNodePrivate,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemStatementNode {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "public" => _serde::__private::Ok(__Field::__field1),
                                        "private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"public" => _serde::__private::Ok(__Field::__field1),
                                        b"private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemStatementNode,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemStatementNode;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemStatementNode",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemStatementNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        ProblemStatementNodePublic,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemStatementNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        ProblemStatementNodePrivate,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct ProblemStatementNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        ProblemStatementNodePublic,
                                    > = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<
                                        ProblemStatementNodePrivate,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemStatementNodePublic,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemStatementNodePrivate,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "node_id",
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemStatementNode",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemStatementNode,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemStatementNode {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemStatementNode",
                                false as usize + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemStatementNode {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ProblemStatementNode",
                            "node_id",
                            &self.node_id,
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemStatementNode {
                    #[inline]
                    fn clone(&self) -> ProblemStatementNode {
                        ProblemStatementNode {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl Node<ActiveModel, Model, Entity> for ProblemStatementNode {
                    fn get_node_id(&self) -> i64 {
                        self.node_id
                    }
                    fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                #[node_raw(node_type = "problem_statement")]
                pub struct ProblemStatementNodeRaw {
                    pub public: ProblemStatementNodePublicRaw,
                    pub private: ProblemStatementNodePrivateRaw,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemStatementNodeRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "public" => _serde::__private::Ok(__Field::__field0),
                                        "private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"public" => _serde::__private::Ok(__Field::__field0),
                                        b"private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemStatementNodeRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemStatementNodeRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemStatementNodeRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        ProblemStatementNodePublicRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemStatementNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        ProblemStatementNodePrivateRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemStatementNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        ProblemStatementNodePublicRaw,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        ProblemStatementNodePrivateRaw,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemStatementNodePublicRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemStatementNodePrivateRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemStatementNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemStatementNodeRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemStatementNodeRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemStatementNodeRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemStatementNodeRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemStatementNodeRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ProblemStatementNodeRaw",
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemStatementNodeRaw {
                    #[inline]
                    fn clone(&self) -> ProblemStatementNodeRaw {
                        ProblemStatementNodeRaw {
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl NodeRaw<ProblemStatementNode, Model, ActiveModel>
                for ProblemStatementNodeRaw {
                    fn get_node_type(&self) -> &str {
                        "problem_statement"
                    }
                    fn get_node_id_column(
                        &self,
                    ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                impl From<Model> for ProblemStatementNode {
                    fn from(model: Model) -> Self {
                        ProblemStatementNode {
                            node_id: model.node_id,
                            public: ProblemStatementNodePublic {
                                statements: model.content,
                                source: model.source,
                                creation_time: model.creation_time,
                                update_time: model.update_time,
                            },
                            private: ProblemStatementNodePrivate {},
                        }
                    }
                }
                impl From<ProblemStatementNodeRaw> for ActiveModel {
                    fn from(value: ProblemStatementNodeRaw) -> Self {
                        ActiveModel {
                            node_id: NotSet,
                            iden: Set(value.public.iden),
                            source: Set(value.public.source),
                            content: Set(value.public.statements),
                            creation_time: Set(value.public.creation_time),
                            update_time: Set(value.public.creation_time),
                        }
                    }
                }
                use crate::db::entity::node::problem_statement::{
                    ActiveModel, Column, ContentType, Entity, Model,
                };
                use crate::graph::node::{Node, NodeRaw};
                use chrono::NaiveDateTime;
                use macro_node_iden::{Node, NodeRaw};
                use sea_orm::ActiveValue::{NotSet, Set};
                use sea_orm::EntityTrait;
                use serde::{Deserialize, Serialize};
            }
            pub mod tag {
                pub struct ProblemTagNodePublic {
                    pub tag_name: String,
                    pub tag_description: String,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemTagNodePublic {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "tag_name" => _serde::__private::Ok(__Field::__field0),
                                        "tag_description" => {
                                            _serde::__private::Ok(__Field::__field1)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"tag_name" => _serde::__private::Ok(__Field::__field0),
                                        b"tag_description" => {
                                            _serde::__private::Ok(__Field::__field1)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemTagNodePublic,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemTagNodePublic;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemTagNodePublic",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemTagNodePublic with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemTagNodePublic with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNodePublic {
                                        tag_name: __field0,
                                        tag_description: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "tag_name",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "tag_description",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("tag_name")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("tag_description")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNodePublic {
                                        tag_name: __field0,
                                        tag_description: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "tag_name",
                                "tag_description",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemTagNodePublic",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemTagNodePublic,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemTagNodePublic {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemTagNodePublic",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "tag_name",
                                &self.tag_name,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "tag_description",
                                &self.tag_description,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemTagNodePublic {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ProblemTagNodePublic",
                            "tag_name",
                            &self.tag_name,
                            "tag_description",
                            &&self.tag_description,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemTagNodePublic {
                    #[inline]
                    fn clone(&self) -> ProblemTagNodePublic {
                        ProblemTagNodePublic {
                            tag_name: ::core::clone::Clone::clone(&self.tag_name),
                            tag_description: ::core::clone::Clone::clone(
                                &self.tag_description,
                            ),
                        }
                    }
                }
                pub struct ProblemTagNodePrivate {}
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemTagNodePrivate {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemTagNodePrivate,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemTagNodePrivate;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemTagNodePrivate",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(ProblemTagNodePrivate {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(ProblemTagNodePrivate {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemTagNodePrivate",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemTagNodePrivate,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemTagNodePrivate {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemTagNodePrivate",
                                false as usize,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemTagNodePrivate {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "ProblemTagNodePrivate")
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemTagNodePrivate {
                    #[inline]
                    fn clone(&self) -> ProblemTagNodePrivate {
                        ProblemTagNodePrivate {}
                    }
                }
                pub struct ProblemTagNodePublicRaw {
                    pub tag_name: String,
                    pub tag_description: String,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemTagNodePublicRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "tag_name" => _serde::__private::Ok(__Field::__field0),
                                        "tag_description" => {
                                            _serde::__private::Ok(__Field::__field1)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"tag_name" => _serde::__private::Ok(__Field::__field0),
                                        b"tag_description" => {
                                            _serde::__private::Ok(__Field::__field1)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemTagNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemTagNodePublicRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemTagNodePublicRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemTagNodePublicRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemTagNodePublicRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNodePublicRaw {
                                        tag_name: __field0,
                                        tag_description: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "tag_name",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "tag_description",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("tag_name")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("tag_description")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNodePublicRaw {
                                        tag_name: __field0,
                                        tag_description: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "tag_name",
                                "tag_description",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemTagNodePublicRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemTagNodePublicRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemTagNodePublicRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemTagNodePublicRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "tag_name",
                                &self.tag_name,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "tag_description",
                                &self.tag_description,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemTagNodePublicRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ProblemTagNodePublicRaw",
                            "tag_name",
                            &self.tag_name,
                            "tag_description",
                            &&self.tag_description,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemTagNodePublicRaw {
                    #[inline]
                    fn clone(&self) -> ProblemTagNodePublicRaw {
                        ProblemTagNodePublicRaw {
                            tag_name: ::core::clone::Clone::clone(&self.tag_name),
                            tag_description: ::core::clone::Clone::clone(
                                &self.tag_description,
                            ),
                        }
                    }
                }
                pub struct ProblemTagNodePrivateRaw {}
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemTagNodePrivateRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    ProblemTagNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemTagNodePrivateRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemTagNodePrivateRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(ProblemTagNodePrivateRaw {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(ProblemTagNodePrivateRaw {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemTagNodePrivateRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        ProblemTagNodePrivateRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemTagNodePrivateRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemTagNodePrivateRaw",
                                false as usize,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemTagNodePrivateRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(f, "ProblemTagNodePrivateRaw")
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemTagNodePrivateRaw {
                    #[inline]
                    fn clone(&self) -> ProblemTagNodePrivateRaw {
                        ProblemTagNodePrivateRaw {}
                    }
                }
                pub struct ProblemTagNode {
                    pub node_id: i64,
                    pub public: ProblemTagNodePublic,
                    pub private: ProblemTagNodePrivate,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemTagNode {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "public" => _serde::__private::Ok(__Field::__field1),
                                        "private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"public" => _serde::__private::Ok(__Field::__field1),
                                        b"private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<ProblemTagNode>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemTagNode;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemTagNode",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemTagNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        ProblemTagNodePublic,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemTagNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        ProblemTagNodePrivate,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct ProblemTagNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        ProblemTagNodePublic,
                                    > = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<
                                        ProblemTagNodePrivate,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemTagNodePublic,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemTagNodePrivate,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "node_id",
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemTagNode",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<ProblemTagNode>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemTagNode {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemTagNode",
                                false as usize + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemTagNode {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "ProblemTagNode",
                            "node_id",
                            &self.node_id,
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemTagNode {
                    #[inline]
                    fn clone(&self) -> ProblemTagNode {
                        ProblemTagNode {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl Node<ActiveModel, Model, Entity> for ProblemTagNode {
                    fn get_node_id(&self) -> i64 {
                        self.node_id
                    }
                    fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                #[node_raw(node_type = "problem_tag")]
                pub struct ProblemTagNodeRaw {
                    pub public: ProblemTagNodePublicRaw,
                    pub private: ProblemTagNodePrivateRaw,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for ProblemTagNodeRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "public" => _serde::__private::Ok(__Field::__field0),
                                        "private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"public" => _serde::__private::Ok(__Field::__field0),
                                        b"private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<ProblemTagNodeRaw>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = ProblemTagNodeRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct ProblemTagNodeRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        ProblemTagNodePublicRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct ProblemTagNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        ProblemTagNodePrivateRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct ProblemTagNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        ProblemTagNodePublicRaw,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        ProblemTagNodePrivateRaw,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemTagNodePublicRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        ProblemTagNodePrivateRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(ProblemTagNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "ProblemTagNodeRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<ProblemTagNodeRaw>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for ProblemTagNodeRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "ProblemTagNodeRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for ProblemTagNodeRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "ProblemTagNodeRaw",
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for ProblemTagNodeRaw {
                    #[inline]
                    fn clone(&self) -> ProblemTagNodeRaw {
                        ProblemTagNodeRaw {
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl NodeRaw<ProblemTagNode, Model, ActiveModel> for ProblemTagNodeRaw {
                    fn get_node_type(&self) -> &str {
                        "problem_tag"
                    }
                    fn get_node_id_column(
                        &self,
                    ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                impl From<Model> for ProblemTagNode {
                    fn from(model: Model) -> Self {
                        ProblemTagNode {
                            node_id: model.node_id,
                            public: ProblemTagNodePublic {
                                tag_name: model.tag_name,
                                tag_description: model.tag_description,
                            },
                            private: ProblemTagNodePrivate {},
                        }
                    }
                }
                impl From<ProblemTagNodeRaw> for ActiveModel {
                    fn from(value: ProblemTagNodeRaw) -> Self {
                        ActiveModel {
                            node_id: NotSet,
                            tag_name: Set(value.public.tag_name),
                            tag_description: Set(value.public.tag_description),
                        }
                    }
                }
                use crate::db::entity::node::problem_tag::{
                    ActiveModel, Column, Entity, Model,
                };
                use crate::graph::node::{Node, NodeRaw};
                use macro_node_iden::{Node, NodeRaw};
                use sea_orm::ActiveValue::{NotSet, Set};
                use sea_orm::EntityTrait;
                use serde::{Deserialize, Serialize};
            }
            use crate::db::entity::node::problem::{ActiveModel, Column, Entity, Model};
            use crate::graph::node::{Node, NodeRaw};
            use chrono::NaiveDateTime;
            use macro_node_iden::{Node, NodeRaw};
            use sea_orm::EntityTrait;
            use serde::{Deserialize, Serialize};
        }
        pub mod problem_source {
            pub struct ProblemSourceNodePublic {
                pub name: String,
                pub iden: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemSourceNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "iden" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"iden" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ProblemSourceNodePublic,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemSourceNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemSourceNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemSourceNodePublic with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemSourceNodePublic with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNodePublic {
                                    name: __field0,
                                    iden: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNodePublic {
                                    name: __field0,
                                    iden: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name", "iden"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemSourceNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemSourceNodePublic,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemSourceNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemSourceNodePublic",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemSourceNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ProblemSourceNodePublic",
                        "name",
                        &self.name,
                        "iden",
                        &&self.iden,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemSourceNodePublic {
                #[inline]
                fn clone(&self) -> ProblemSourceNodePublic {
                    ProblemSourceNodePublic {
                        name: ::core::clone::Clone::clone(&self.name),
                        iden: ::core::clone::Clone::clone(&self.iden),
                    }
                }
            }
            pub struct ProblemSourceNodePrivate {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemSourceNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ProblemSourceNodePrivate,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemSourceNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemSourceNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(ProblemSourceNodePrivate {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(ProblemSourceNodePrivate {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemSourceNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemSourceNodePrivate,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemSourceNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemSourceNodePrivate",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemSourceNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ProblemSourceNodePrivate")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemSourceNodePrivate {
                #[inline]
                fn clone(&self) -> ProblemSourceNodePrivate {
                    ProblemSourceNodePrivate {}
                }
            }
            pub struct ProblemSourceNodePublicRaw {
                pub name: String,
                pub iden: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemSourceNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "iden" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"iden" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ProblemSourceNodePublicRaw,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemSourceNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemSourceNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemSourceNodePublicRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemSourceNodePublicRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNodePublicRaw {
                                    name: __field0,
                                    iden: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNodePublicRaw {
                                    name: __field0,
                                    iden: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["name", "iden"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemSourceNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemSourceNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemSourceNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemSourceNodePublicRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemSourceNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ProblemSourceNodePublicRaw",
                        "name",
                        &self.name,
                        "iden",
                        &&self.iden,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemSourceNodePublicRaw {
                #[inline]
                fn clone(&self) -> ProblemSourceNodePublicRaw {
                    ProblemSourceNodePublicRaw {
                        name: ::core::clone::Clone::clone(&self.name),
                        iden: ::core::clone::Clone::clone(&self.iden),
                    }
                }
            }
            pub struct ProblemSourceNodePrivateRaw {}
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemSourceNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ProblemSourceNodePrivateRaw,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemSourceNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemSourceNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                _: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                _serde::__private::Ok(ProblemSourceNodePrivateRaw {})
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                _serde::__private::Ok(ProblemSourceNodePrivateRaw {})
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemSourceNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemSourceNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemSourceNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemSourceNodePrivateRaw",
                            false as usize,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemSourceNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "ProblemSourceNodePrivateRaw")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemSourceNodePrivateRaw {
                #[inline]
                fn clone(&self) -> ProblemSourceNodePrivateRaw {
                    ProblemSourceNodePrivateRaw {}
                }
            }
            pub struct ProblemSourceNode {
                pub node_id: i64,
                pub public: ProblemSourceNodePublic,
                pub private: ProblemSourceNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemSourceNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProblemSourceNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemSourceNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemSourceNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemSourceNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    ProblemSourceNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemSourceNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    ProblemSourceNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ProblemSourceNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    ProblemSourceNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    ProblemSourceNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemSourceNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemSourceNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemSourceNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ProblemSourceNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemSourceNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemSourceNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemSourceNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "ProblemSourceNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemSourceNode {
                #[inline]
                fn clone(&self) -> ProblemSourceNode {
                    ProblemSourceNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl Node<ActiveModel, Model, Entity> for ProblemSourceNode {
                fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::NodeId
                }
            }
            #[node_raw(node_type = "problem_source")]
            pub struct ProblemSourceNodeRaw {
                pub public: ProblemSourceNodePublicRaw,
                pub private: ProblemSourceNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProblemSourceNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "public" => _serde::__private::Ok(__Field::__field0),
                                    "private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"public" => _serde::__private::Ok(__Field::__field0),
                                    b"private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProblemSourceNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProblemSourceNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProblemSourceNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    ProblemSourceNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProblemSourceNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    ProblemSourceNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProblemSourceNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    ProblemSourceNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    ProblemSourceNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemSourceNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    ProblemSourceNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(ProblemSourceNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["public", "private"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProblemSourceNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ProblemSourceNodeRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProblemSourceNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProblemSourceNodeRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for ProblemSourceNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ProblemSourceNodeRaw",
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProblemSourceNodeRaw {
                #[inline]
                fn clone(&self) -> ProblemSourceNodeRaw {
                    ProblemSourceNodeRaw {
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl NodeRaw<ProblemSourceNode, Model, ActiveModel>
            for ProblemSourceNodeRaw {
                fn get_node_type(&self) -> &str {
                    "problem_source"
                }
                fn get_node_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::NodeId
                }
            }
            impl From<Model> for ProblemSourceNode {
                fn from(model: Model) -> Self {
                    ProblemSourceNode {
                        node_id: model.node_id,
                        public: ProblemSourceNodePublic {
                            name: model.name,
                            iden: model.iden,
                        },
                        private: ProblemSourceNodePrivate {},
                    }
                }
            }
            impl From<ProblemSourceNodeRaw> for ActiveModel {
                fn from(value: ProblemSourceNodeRaw) -> Self {
                    ActiveModel {
                        node_id: NotSet,
                        name: Set(value.public.name),
                        iden: Set(value.public.iden),
                    }
                }
            }
            use crate::db::entity::node::problem_source::{
                ActiveModel, Column, Entity, Model,
            };
            use crate::graph::node::{Node, NodeRaw};
            use macro_node_iden::{Node, NodeRaw};
            use sea_orm::ActiveValue::{NotSet, Set};
            use sea_orm::EntityTrait;
            use serde::{Deserialize, Serialize};
        }
        pub mod record {
            pub enum RecordStatus {
                Accepted = 100,
                PartialAccepted = 101,
                WrongAnswer = 200,
                TimeLimitExceeded = 301,
                MemoryLimitExceeded = 302,
                OutputLimitExceeded = 303,
                RuntimeError = 400,
                CompileError = 500,
                DangerousCode = 501,
                RemoteServiceUnknownError = 600,
                SandboxError = 601,
                RemotePlatformRefused = 700,
                RemotePlatformConnectionFailed = 701,
                RemotePlatformUnknownError = 702,
                Waiting = 800,
                UnknownError = 900,
                Unverified = 901,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::enum_const::EnumConst for RecordStatus {
                fn get_const_isize(&self) -> Option<isize> {
                    match self {
                        Self::Accepted => Some(100),
                        Self::PartialAccepted => Some(101),
                        Self::WrongAnswer => Some(200),
                        Self::TimeLimitExceeded => Some(301),
                        Self::MemoryLimitExceeded => Some(302),
                        Self::OutputLimitExceeded => Some(303),
                        Self::RuntimeError => Some(400),
                        Self::CompileError => Some(500),
                        Self::DangerousCode => Some(501),
                        Self::RemoteServiceUnknownError => Some(600),
                        Self::SandboxError => Some(601),
                        Self::RemotePlatformRefused => Some(700),
                        Self::RemotePlatformConnectionFailed => Some(701),
                        Self::RemotePlatformUnknownError => Some(702),
                        Self::Waiting => Some(800),
                        Self::UnknownError => Some(900),
                        Self::Unverified => Some(901),
                        _ => None,
                    }
                }
                fn from_const_isize(i: isize) -> Option<Self> {
                    match i {
                        100 => Some(Self::Accepted),
                        101 => Some(Self::PartialAccepted),
                        200 => Some(Self::WrongAnswer),
                        301 => Some(Self::TimeLimitExceeded),
                        302 => Some(Self::MemoryLimitExceeded),
                        303 => Some(Self::OutputLimitExceeded),
                        400 => Some(Self::RuntimeError),
                        500 => Some(Self::CompileError),
                        501 => Some(Self::DangerousCode),
                        600 => Some(Self::RemoteServiceUnknownError),
                        601 => Some(Self::SandboxError),
                        700 => Some(Self::RemotePlatformRefused),
                        701 => Some(Self::RemotePlatformConnectionFailed),
                        702 => Some(Self::RemotePlatformUnknownError),
                        800 => Some(Self::Waiting),
                        900 => Some(Self::UnknownError),
                        901 => Some(Self::Unverified),
                        _ => None,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for RecordStatus {}
            #[automatically_derived]
            impl ::core::clone::Clone for RecordStatus {
                #[inline]
                fn clone(&self) -> RecordStatus {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for RecordStatus {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            RecordStatus::Accepted => "Accepted",
                            RecordStatus::PartialAccepted => "PartialAccepted",
                            RecordStatus::WrongAnswer => "WrongAnswer",
                            RecordStatus::TimeLimitExceeded => "TimeLimitExceeded",
                            RecordStatus::MemoryLimitExceeded => "MemoryLimitExceeded",
                            RecordStatus::OutputLimitExceeded => "OutputLimitExceeded",
                            RecordStatus::RuntimeError => "RuntimeError",
                            RecordStatus::CompileError => "CompileError",
                            RecordStatus::DangerousCode => "DangerousCode",
                            RecordStatus::RemoteServiceUnknownError => {
                                "RemoteServiceUnknownError"
                            }
                            RecordStatus::SandboxError => "SandboxError",
                            RecordStatus::RemotePlatformRefused => {
                                "RemotePlatformRefused"
                            }
                            RecordStatus::RemotePlatformConnectionFailed => {
                                "RemotePlatformConnectionFailed"
                            }
                            RecordStatus::RemotePlatformUnknownError => {
                                "RemotePlatformUnknownError"
                            }
                            RecordStatus::Waiting => "Waiting",
                            RecordStatus::UnknownError => "UnknownError",
                            RecordStatus::Unverified => "Unverified",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for RecordStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for RecordStatus {
                #[inline]
                fn eq(&self, other: &RecordStatus) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            ///An iterator over the variants of [RecordStatus]
            #[allow(missing_copy_implementations)]
            pub struct RecordStatusIter {
                idx: usize,
                back_idx: usize,
                marker: ::core::marker::PhantomData<fn() -> ()>,
            }
            impl ::core::fmt::Debug for RecordStatusIter {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RecordStatusIter").field("len", &self.len()).finish()
                }
            }
            impl RecordStatusIter {
                fn get(&self, idx: usize) -> ::core::option::Option<RecordStatus> {
                    match idx {
                        0usize => ::core::option::Option::Some(RecordStatus::Accepted),
                        1usize => {
                            ::core::option::Option::Some(RecordStatus::PartialAccepted)
                        }
                        2usize => ::core::option::Option::Some(RecordStatus::WrongAnswer),
                        3usize => {
                            ::core::option::Option::Some(RecordStatus::TimeLimitExceeded)
                        }
                        4usize => {
                            ::core::option::Option::Some(
                                RecordStatus::MemoryLimitExceeded,
                            )
                        }
                        5usize => {
                            ::core::option::Option::Some(
                                RecordStatus::OutputLimitExceeded,
                            )
                        }
                        6usize => {
                            ::core::option::Option::Some(RecordStatus::RuntimeError)
                        }
                        7usize => {
                            ::core::option::Option::Some(RecordStatus::CompileError)
                        }
                        8usize => {
                            ::core::option::Option::Some(RecordStatus::DangerousCode)
                        }
                        9usize => {
                            ::core::option::Option::Some(
                                RecordStatus::RemoteServiceUnknownError,
                            )
                        }
                        10usize => {
                            ::core::option::Option::Some(RecordStatus::SandboxError)
                        }
                        11usize => {
                            ::core::option::Option::Some(
                                RecordStatus::RemotePlatformRefused,
                            )
                        }
                        12usize => {
                            ::core::option::Option::Some(
                                RecordStatus::RemotePlatformConnectionFailed,
                            )
                        }
                        13usize => {
                            ::core::option::Option::Some(
                                RecordStatus::RemotePlatformUnknownError,
                            )
                        }
                        14usize => ::core::option::Option::Some(RecordStatus::Waiting),
                        15usize => {
                            ::core::option::Option::Some(RecordStatus::UnknownError)
                        }
                        16usize => ::core::option::Option::Some(RecordStatus::Unverified),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::strum::IntoEnumIterator for RecordStatus {
                type Iterator = RecordStatusIter;
                #[inline]
                fn iter() -> RecordStatusIter {
                    RecordStatusIter {
                        idx: 0,
                        back_idx: 0,
                        marker: ::core::marker::PhantomData,
                    }
                }
            }
            impl Iterator for RecordStatusIter {
                type Item = RecordStatus;
                #[inline]
                fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
                    self.nth(0)
                }
                #[inline]
                fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                    let t = if self.idx + self.back_idx >= 17usize {
                        0
                    } else {
                        17usize - self.idx - self.back_idx
                    };
                    (t, Some(t))
                }
                #[inline]
                fn nth(
                    &mut self,
                    n: usize,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let idx = self.idx + n + 1;
                    if idx + self.back_idx > 17usize {
                        self.idx = 17usize;
                        ::core::option::Option::None
                    } else {
                        self.idx = idx;
                        RecordStatusIter::get(self, idx - 1)
                    }
                }
            }
            impl ExactSizeIterator for RecordStatusIter {
                #[inline]
                fn len(&self) -> usize {
                    self.size_hint().0
                }
            }
            impl DoubleEndedIterator for RecordStatusIter {
                #[inline]
                fn next_back(
                    &mut self,
                ) -> ::core::option::Option<<Self as Iterator>::Item> {
                    let back_idx = self.back_idx + 1;
                    if self.idx + back_idx > 17usize {
                        self.back_idx = 17usize;
                        ::core::option::Option::None
                    } else {
                        self.back_idx = back_idx;
                        RecordStatusIter::get(self, 17usize - self.back_idx)
                    }
                }
            }
            impl ::core::iter::FusedIterator for RecordStatusIter {}
            impl Clone for RecordStatusIter {
                #[inline]
                fn clone(&self) -> RecordStatusIter {
                    RecordStatusIter {
                        idx: self.idx,
                        back_idx: self.back_idx,
                        marker: self.marker.clone(),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RecordStatus {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    12u64 => _serde::__private::Ok(__Field::__field12),
                                    13u64 => _serde::__private::Ok(__Field::__field13),
                                    14u64 => _serde::__private::Ok(__Field::__field14),
                                    15u64 => _serde::__private::Ok(__Field::__field15),
                                    16u64 => _serde::__private::Ok(__Field::__field16),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 17",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Accepted" => _serde::__private::Ok(__Field::__field0),
                                    "PartialAccepted" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "WrongAnswer" => _serde::__private::Ok(__Field::__field2),
                                    "TimeLimitExceeded" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    "MemoryLimitExceeded" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "OutputLimitExceeded" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    "RuntimeError" => _serde::__private::Ok(__Field::__field6),
                                    "CompileError" => _serde::__private::Ok(__Field::__field7),
                                    "DangerousCode" => _serde::__private::Ok(__Field::__field8),
                                    "RemoteServiceUnknownError" => {
                                        _serde::__private::Ok(__Field::__field9)
                                    }
                                    "SandboxError" => _serde::__private::Ok(__Field::__field10),
                                    "RemotePlatformRefused" => {
                                        _serde::__private::Ok(__Field::__field11)
                                    }
                                    "RemotePlatformConnectionFailed" => {
                                        _serde::__private::Ok(__Field::__field12)
                                    }
                                    "RemotePlatformUnknownError" => {
                                        _serde::__private::Ok(__Field::__field13)
                                    }
                                    "Waiting" => _serde::__private::Ok(__Field::__field14),
                                    "UnknownError" => _serde::__private::Ok(__Field::__field15),
                                    "Unverified" => _serde::__private::Ok(__Field::__field16),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Accepted" => _serde::__private::Ok(__Field::__field0),
                                    b"PartialAccepted" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"WrongAnswer" => _serde::__private::Ok(__Field::__field2),
                                    b"TimeLimitExceeded" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    b"MemoryLimitExceeded" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"OutputLimitExceeded" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    b"RuntimeError" => _serde::__private::Ok(__Field::__field6),
                                    b"CompileError" => _serde::__private::Ok(__Field::__field7),
                                    b"DangerousCode" => _serde::__private::Ok(__Field::__field8),
                                    b"RemoteServiceUnknownError" => {
                                        _serde::__private::Ok(__Field::__field9)
                                    }
                                    b"SandboxError" => _serde::__private::Ok(__Field::__field10),
                                    b"RemotePlatformRefused" => {
                                        _serde::__private::Ok(__Field::__field11)
                                    }
                                    b"RemotePlatformConnectionFailed" => {
                                        _serde::__private::Ok(__Field::__field12)
                                    }
                                    b"RemotePlatformUnknownError" => {
                                        _serde::__private::Ok(__Field::__field13)
                                    }
                                    b"Waiting" => _serde::__private::Ok(__Field::__field14),
                                    b"UnknownError" => _serde::__private::Ok(__Field::__field15),
                                    b"Unverified" => _serde::__private::Ok(__Field::__field16),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RecordStatus>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RecordStatus;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum RecordStatus",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::Accepted)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::PartialAccepted)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::WrongAnswer)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::TimeLimitExceeded)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::MemoryLimitExceeded)
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::OutputLimitExceeded)
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::RuntimeError)
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::CompileError)
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::DangerousCode)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(
                                            RecordStatus::RemoteServiceUnknownError,
                                        )
                                    }
                                    (__Field::__field10, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::SandboxError)
                                    }
                                    (__Field::__field11, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::RemotePlatformRefused)
                                    }
                                    (__Field::__field12, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(
                                            RecordStatus::RemotePlatformConnectionFailed,
                                        )
                                    }
                                    (__Field::__field13, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(
                                            RecordStatus::RemotePlatformUnknownError,
                                        )
                                    }
                                    (__Field::__field14, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::Waiting)
                                    }
                                    (__Field::__field15, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::UnknownError)
                                    }
                                    (__Field::__field16, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(RecordStatus::Unverified)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Accepted",
                            "PartialAccepted",
                            "WrongAnswer",
                            "TimeLimitExceeded",
                            "MemoryLimitExceeded",
                            "OutputLimitExceeded",
                            "RuntimeError",
                            "CompileError",
                            "DangerousCode",
                            "RemoteServiceUnknownError",
                            "SandboxError",
                            "RemotePlatformRefused",
                            "RemotePlatformConnectionFailed",
                            "RemotePlatformUnknownError",
                            "Waiting",
                            "UnknownError",
                            "Unverified",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "RecordStatus",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RecordStatus>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RecordStatus {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            RecordStatus::Accepted => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    0u32,
                                    "Accepted",
                                )
                            }
                            RecordStatus::PartialAccepted => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    1u32,
                                    "PartialAccepted",
                                )
                            }
                            RecordStatus::WrongAnswer => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    2u32,
                                    "WrongAnswer",
                                )
                            }
                            RecordStatus::TimeLimitExceeded => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    3u32,
                                    "TimeLimitExceeded",
                                )
                            }
                            RecordStatus::MemoryLimitExceeded => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    4u32,
                                    "MemoryLimitExceeded",
                                )
                            }
                            RecordStatus::OutputLimitExceeded => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    5u32,
                                    "OutputLimitExceeded",
                                )
                            }
                            RecordStatus::RuntimeError => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    6u32,
                                    "RuntimeError",
                                )
                            }
                            RecordStatus::CompileError => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    7u32,
                                    "CompileError",
                                )
                            }
                            RecordStatus::DangerousCode => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    8u32,
                                    "DangerousCode",
                                )
                            }
                            RecordStatus::RemoteServiceUnknownError => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    9u32,
                                    "RemoteServiceUnknownError",
                                )
                            }
                            RecordStatus::SandboxError => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    10u32,
                                    "SandboxError",
                                )
                            }
                            RecordStatus::RemotePlatformRefused => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    11u32,
                                    "RemotePlatformRefused",
                                )
                            }
                            RecordStatus::RemotePlatformConnectionFailed => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    12u32,
                                    "RemotePlatformConnectionFailed",
                                )
                            }
                            RecordStatus::RemotePlatformUnknownError => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    13u32,
                                    "RemotePlatformUnknownError",
                                )
                            }
                            RecordStatus::Waiting => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    14u32,
                                    "Waiting",
                                )
                            }
                            RecordStatus::UnknownError => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    15u32,
                                    "UnknownError",
                                )
                            }
                            RecordStatus::Unverified => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "RecordStatus",
                                    16u32,
                                    "Unverified",
                                )
                            }
                        }
                    }
                }
            };
            pub struct RecordNodePublic {
                pub record_order: i64,
                pub record_score: i64,
                pub record_platform: String,
                pub record_status: RecordStatus,
                pub record_message: String,
                pub record_time: NaiveDateTime,
                pub record_update_time: NaiveDateTime,
                pub code: Option<String>,
                pub code_language: Option<String>,
                pub record_url: Option<String>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RecordNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "record_order" => _serde::__private::Ok(__Field::__field0),
                                    "record_score" => _serde::__private::Ok(__Field::__field1),
                                    "record_platform" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "record_status" => _serde::__private::Ok(__Field::__field3),
                                    "record_message" => _serde::__private::Ok(__Field::__field4),
                                    "record_time" => _serde::__private::Ok(__Field::__field5),
                                    "record_update_time" => {
                                        _serde::__private::Ok(__Field::__field6)
                                    }
                                    "code" => _serde::__private::Ok(__Field::__field7),
                                    "code_language" => _serde::__private::Ok(__Field::__field8),
                                    "record_url" => _serde::__private::Ok(__Field::__field9),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"record_order" => _serde::__private::Ok(__Field::__field0),
                                    b"record_score" => _serde::__private::Ok(__Field::__field1),
                                    b"record_platform" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"record_status" => _serde::__private::Ok(__Field::__field3),
                                    b"record_message" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"record_time" => _serde::__private::Ok(__Field::__field5),
                                    b"record_update_time" => {
                                        _serde::__private::Ok(__Field::__field6)
                                    }
                                    b"code" => _serde::__private::Ok(__Field::__field7),
                                    b"code_language" => _serde::__private::Ok(__Field::__field8),
                                    b"record_url" => _serde::__private::Ok(__Field::__field9),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RecordNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RecordNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RecordNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    RecordStatus,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                6usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                7usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field8 = match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                8usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field9 = match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                9usize,
                                                &"struct RecordNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RecordNodePublic {
                                    record_order: __field0,
                                    record_score: __field1,
                                    record_platform: __field2,
                                    record_status: __field3,
                                    record_message: __field4,
                                    record_time: __field5,
                                    record_update_time: __field6,
                                    code: __field7,
                                    code_language: __field8,
                                    record_url: __field9,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<RecordStatus> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field6: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field7: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field8: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field9: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_order",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_score",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_platform",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_status",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RecordStatus,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_message",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_time",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field6 => {
                                            if _serde::__private::Option::is_some(&__field6) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_update_time",
                                                    ),
                                                );
                                            }
                                            __field6 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field7 => {
                                            if _serde::__private::Option::is_some(&__field7) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("code"),
                                                );
                                            }
                                            __field7 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field8 => {
                                            if _serde::__private::Option::is_some(&__field8) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "code_language",
                                                    ),
                                                );
                                            }
                                            __field8 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field9 => {
                                            if _serde::__private::Option::is_some(&__field9) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_url",
                                                    ),
                                                );
                                            }
                                            __field9 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_order")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_score")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_platform")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_status")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_message")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_time")?
                                    }
                                };
                                let __field6 = match __field6 {
                                    _serde::__private::Some(__field6) => __field6,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_update_time")?
                                    }
                                };
                                let __field7 = match __field7 {
                                    _serde::__private::Some(__field7) => __field7,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("code")?
                                    }
                                };
                                let __field8 = match __field8 {
                                    _serde::__private::Some(__field8) => __field8,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("code_language")?
                                    }
                                };
                                let __field9 = match __field9 {
                                    _serde::__private::Some(__field9) => __field9,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_url")?
                                    }
                                };
                                _serde::__private::Ok(RecordNodePublic {
                                    record_order: __field0,
                                    record_score: __field1,
                                    record_platform: __field2,
                                    record_status: __field3,
                                    record_message: __field4,
                                    record_time: __field5,
                                    record_update_time: __field6,
                                    code: __field7,
                                    code_language: __field8,
                                    record_url: __field9,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "record_order",
                            "record_score",
                            "record_platform",
                            "record_status",
                            "record_message",
                            "record_time",
                            "record_update_time",
                            "code",
                            "code_language",
                            "record_url",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RecordNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RecordNodePublic>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RecordNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RecordNodePublic",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_order",
                            &self.record_order,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_score",
                            &self.record_score,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_platform",
                            &self.record_platform,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_status",
                            &self.record_status,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_message",
                            &self.record_message,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_time",
                            &self.record_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_update_time",
                            &self.record_update_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "code",
                            &self.code,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "code_language",
                            &self.code_language,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_url",
                            &self.record_url,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for RecordNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "record_order",
                        "record_score",
                        "record_platform",
                        "record_status",
                        "record_message",
                        "record_time",
                        "record_update_time",
                        "code",
                        "code_language",
                        "record_url",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.record_order,
                        &self.record_score,
                        &self.record_platform,
                        &self.record_status,
                        &self.record_message,
                        &self.record_time,
                        &self.record_update_time,
                        &self.code,
                        &self.code_language,
                        &&self.record_url,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "RecordNodePublic",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RecordNodePublic {
                #[inline]
                fn clone(&self) -> RecordNodePublic {
                    RecordNodePublic {
                        record_order: ::core::clone::Clone::clone(&self.record_order),
                        record_score: ::core::clone::Clone::clone(&self.record_score),
                        record_platform: ::core::clone::Clone::clone(
                            &self.record_platform,
                        ),
                        record_status: ::core::clone::Clone::clone(&self.record_status),
                        record_message: ::core::clone::Clone::clone(
                            &self.record_message,
                        ),
                        record_time: ::core::clone::Clone::clone(&self.record_time),
                        record_update_time: ::core::clone::Clone::clone(
                            &self.record_update_time,
                        ),
                        code: ::core::clone::Clone::clone(&self.code),
                        code_language: ::core::clone::Clone::clone(&self.code_language),
                        record_url: ::core::clone::Clone::clone(&self.record_url),
                    }
                }
            }
            pub struct RecordNodePrivate {
                pub code: String,
                pub code_language: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RecordNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "code" => _serde::__private::Ok(__Field::__field0),
                                    "code_language" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"code" => _serde::__private::Ok(__Field::__field0),
                                    b"code_language" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RecordNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RecordNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RecordNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RecordNodePrivate with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RecordNodePrivate with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RecordNodePrivate {
                                    code: __field0,
                                    code_language: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("code"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "code_language",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("code")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("code_language")?
                                    }
                                };
                                _serde::__private::Ok(RecordNodePrivate {
                                    code: __field0,
                                    code_language: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "code",
                            "code_language",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RecordNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RecordNodePrivate>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RecordNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RecordNodePrivate",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "code",
                            &self.code,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "code_language",
                            &self.code_language,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for RecordNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "RecordNodePrivate",
                        "code",
                        &self.code,
                        "code_language",
                        &&self.code_language,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RecordNodePrivate {
                #[inline]
                fn clone(&self) -> RecordNodePrivate {
                    RecordNodePrivate {
                        code: ::core::clone::Clone::clone(&self.code),
                        code_language: ::core::clone::Clone::clone(&self.code_language),
                    }
                }
            }
            pub struct RecordNodePublicRaw {
                pub record_score: i64,
                pub record_platform: String,
                pub record_url: Option<String>,
                pub record_status: RecordStatus,
                pub record_message: Option<String>,
                pub record_time: NaiveDateTime,
                pub statement_id: i64,
                pub public_status: bool,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RecordNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "record_score" => _serde::__private::Ok(__Field::__field0),
                                    "record_platform" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "record_url" => _serde::__private::Ok(__Field::__field2),
                                    "record_status" => _serde::__private::Ok(__Field::__field3),
                                    "record_message" => _serde::__private::Ok(__Field::__field4),
                                    "record_time" => _serde::__private::Ok(__Field::__field5),
                                    "statement_id" => _serde::__private::Ok(__Field::__field6),
                                    "public_status" => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"record_score" => _serde::__private::Ok(__Field::__field0),
                                    b"record_platform" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"record_url" => _serde::__private::Ok(__Field::__field2),
                                    b"record_status" => _serde::__private::Ok(__Field::__field3),
                                    b"record_message" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"record_time" => _serde::__private::Ok(__Field::__field5),
                                    b"statement_id" => _serde::__private::Ok(__Field::__field6),
                                    b"public_status" => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RecordNodePublicRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RecordNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RecordNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    RecordStatus,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    Option<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                6usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                7usize,
                                                &"struct RecordNodePublicRaw with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RecordNodePublicRaw {
                                    record_score: __field0,
                                    record_platform: __field1,
                                    record_url: __field2,
                                    record_status: __field3,
                                    record_message: __field4,
                                    record_time: __field5,
                                    statement_id: __field6,
                                    public_status: __field7,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<RecordStatus> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    Option<String>,
                                > = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field6: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field7: _serde::__private::Option<bool> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_score",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_platform",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_url",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_status",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RecordStatus,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_message",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "record_time",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field6 => {
                                            if _serde::__private::Option::is_some(&__field6) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "statement_id",
                                                    ),
                                                );
                                            }
                                            __field6 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field7 => {
                                            if _serde::__private::Option::is_some(&__field7) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "public_status",
                                                    ),
                                                );
                                            }
                                            __field7 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_score")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_platform")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_url")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_status")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_message")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("record_time")?
                                    }
                                };
                                let __field6 = match __field6 {
                                    _serde::__private::Some(__field6) => __field6,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("statement_id")?
                                    }
                                };
                                let __field7 = match __field7 {
                                    _serde::__private::Some(__field7) => __field7,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public_status")?
                                    }
                                };
                                _serde::__private::Ok(RecordNodePublicRaw {
                                    record_score: __field0,
                                    record_platform: __field1,
                                    record_url: __field2,
                                    record_status: __field3,
                                    record_message: __field4,
                                    record_time: __field5,
                                    statement_id: __field6,
                                    public_status: __field7,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "record_score",
                            "record_platform",
                            "record_url",
                            "record_status",
                            "record_message",
                            "record_time",
                            "statement_id",
                            "public_status",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RecordNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    RecordNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RecordNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RecordNodePublicRaw",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_score",
                            &self.record_score,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_platform",
                            &self.record_platform,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_url",
                            &self.record_url,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_status",
                            &self.record_status,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_message",
                            &self.record_message,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "record_time",
                            &self.record_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "statement_id",
                            &self.statement_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public_status",
                            &self.public_status,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for RecordNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "record_score",
                        "record_platform",
                        "record_url",
                        "record_status",
                        "record_message",
                        "record_time",
                        "statement_id",
                        "public_status",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.record_score,
                        &self.record_platform,
                        &self.record_url,
                        &self.record_status,
                        &self.record_message,
                        &self.record_time,
                        &self.statement_id,
                        &&self.public_status,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "RecordNodePublicRaw",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RecordNodePublicRaw {
                #[inline]
                fn clone(&self) -> RecordNodePublicRaw {
                    RecordNodePublicRaw {
                        record_score: ::core::clone::Clone::clone(&self.record_score),
                        record_platform: ::core::clone::Clone::clone(
                            &self.record_platform,
                        ),
                        record_url: ::core::clone::Clone::clone(&self.record_url),
                        record_status: ::core::clone::Clone::clone(&self.record_status),
                        record_message: ::core::clone::Clone::clone(
                            &self.record_message,
                        ),
                        record_time: ::core::clone::Clone::clone(&self.record_time),
                        statement_id: ::core::clone::Clone::clone(&self.statement_id),
                        public_status: ::core::clone::Clone::clone(&self.public_status),
                    }
                }
            }
            pub struct RecordNodePrivateRaw {
                pub code: String,
                pub code_language: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RecordNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "code" => _serde::__private::Ok(__Field::__field0),
                                    "code_language" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"code" => _serde::__private::Ok(__Field::__field0),
                                    b"code_language" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RecordNodePrivateRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RecordNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RecordNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RecordNodePrivateRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RecordNodePrivateRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RecordNodePrivateRaw {
                                    code: __field0,
                                    code_language: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("code"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "code_language",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("code")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("code_language")?
                                    }
                                };
                                _serde::__private::Ok(RecordNodePrivateRaw {
                                    code: __field0,
                                    code_language: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "code",
                            "code_language",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RecordNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    RecordNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RecordNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RecordNodePrivateRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "code",
                            &self.code,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "code_language",
                            &self.code_language,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for RecordNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "RecordNodePrivateRaw",
                        "code",
                        &self.code,
                        "code_language",
                        &&self.code_language,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RecordNodePrivateRaw {
                #[inline]
                fn clone(&self) -> RecordNodePrivateRaw {
                    RecordNodePrivateRaw {
                        code: ::core::clone::Clone::clone(&self.code),
                        code_language: ::core::clone::Clone::clone(&self.code_language),
                    }
                }
            }
            pub struct RecordNode {
                pub node_id: i64,
                pub public: RecordNodePublic,
                pub private: RecordNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RecordNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RecordNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RecordNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RecordNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RecordNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    RecordNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RecordNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    RecordNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct RecordNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RecordNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    RecordNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    RecordNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RecordNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RecordNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(RecordNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RecordNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RecordNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RecordNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RecordNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for RecordNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "RecordNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RecordNode {
                #[inline]
                fn clone(&self) -> RecordNode {
                    RecordNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl Node<ActiveModel, Model, Entity> for RecordNode {
                fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::NodeId
                }
            }
            #[node_raw(node_type = "record")]
            pub struct RecordNodeRaw {
                pub public: RecordNodePublicRaw,
                pub private: RecordNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RecordNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "public" => _serde::__private::Ok(__Field::__field0),
                                    "private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"public" => _serde::__private::Ok(__Field::__field0),
                                    b"private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RecordNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RecordNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RecordNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    RecordNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RecordNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    RecordNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RecordNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RecordNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    RecordNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    RecordNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RecordNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RecordNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(RecordNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["public", "private"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RecordNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RecordNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RecordNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RecordNodeRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for RecordNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "RecordNodeRaw",
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RecordNodeRaw {
                #[inline]
                fn clone(&self) -> RecordNodeRaw {
                    RecordNodeRaw {
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl NodeRaw<RecordNode, Model, ActiveModel> for RecordNodeRaw {
                fn get_node_type(&self) -> &str {
                    "record"
                }
                fn get_node_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::NodeId
                }
            }
            impl From<RecordNodeRaw> for ActiveModel {
                fn from(value: RecordNodeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    Self {
                        node_id: NotSet,
                        record_order: NotSet,
                        record_score: Set(value.public.record_score),
                        record_platform: Set(value.public.record_platform),
                        record_status: Set(value.public.record_status.into()),
                        record_message: Set(value.public.record_message),
                        record_time: Set(value.public.record_time),
                        record_update_time: Set(value.public.record_time),
                        record_url: Set(value.public.record_url),
                        code: Set(value.private.code),
                        code_language: Set(value.private.code_language),
                        public_status: Set(value.public.public_status),
                        statement_id: Set(value.public.statement_id),
                    }
                }
            }
            impl From<Model> for RecordNode {
                fn from(model: Model) -> Self {
                    Self {
                        node_id: model.node_id,
                        public: RecordNodePublic {
                            record_order: model.record_order,
                            record_score: model.record_score,
                            record_platform: model.record_platform,
                            record_status: model.record_status.into(),
                            record_message: model.record_message.unwrap_or_default(),
                            record_time: model.record_time,
                            record_update_time: model.record_update_time,
                            code: if model.public_status {
                                Some(model.code.clone())
                            } else {
                                None
                            },
                            code_language: if model.public_status {
                                Some(model.code_language.clone())
                            } else {
                                None
                            },
                            record_url: model.record_url,
                        },
                        private: RecordNodePrivate {
                            code: model.code,
                            code_language: model.code_language,
                        },
                    }
                }
            }
            use crate::db;
            use crate::graph::node::Node;
            use crate::graph::node::NodeRaw;
            use chrono::NaiveDateTime;
            use db::entity::node::record::{ActiveModel, Column, Entity, Model};
            use enum_const::EnumConst;
            use macro_node_iden::{Node, NodeRaw};
            use sea_orm::EntityTrait;
            use serde::{Deserialize, Serialize};
            use strum_macros::EnumIter;
            pub mod subtask {
                pub enum SubtaskCalcMethod {
                    Sum = 0,
                    Max = 1,
                    Min = 2,
                    Function = 3,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for SubtaskCalcMethod {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "variant identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => {
                                            _serde::__private::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"variant index 0 <= i < 4",
                                                ),
                                            )
                                        }
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "Sum" => _serde::__private::Ok(__Field::__field0),
                                        "Max" => _serde::__private::Ok(__Field::__field1),
                                        "Min" => _serde::__private::Ok(__Field::__field2),
                                        "Function" => _serde::__private::Ok(__Field::__field3),
                                        _ => {
                                            _serde::__private::Err(
                                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                                            )
                                        }
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"Sum" => _serde::__private::Ok(__Field::__field0),
                                        b"Max" => _serde::__private::Ok(__Field::__field1),
                                        b"Min" => _serde::__private::Ok(__Field::__field2),
                                        b"Function" => _serde::__private::Ok(__Field::__field3),
                                        _ => {
                                            let __value = &_serde::__private::from_utf8_lossy(__value);
                                            _serde::__private::Err(
                                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                                            )
                                        }
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<SubtaskCalcMethod>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = SubtaskCalcMethod;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "enum SubtaskCalcMethod",
                                    )
                                }
                                fn visit_enum<__A>(
                                    self,
                                    __data: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::EnumAccess<'de>,
                                {
                                    match _serde::de::EnumAccess::variant(__data)? {
                                        (__Field::__field0, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(SubtaskCalcMethod::Sum)
                                        }
                                        (__Field::__field1, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(SubtaskCalcMethod::Max)
                                        }
                                        (__Field::__field2, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(SubtaskCalcMethod::Min)
                                        }
                                        (__Field::__field3, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(SubtaskCalcMethod::Function)
                                        }
                                    }
                                }
                            }
                            #[doc(hidden)]
                            const VARIANTS: &'static [&'static str] = &[
                                "Sum",
                                "Max",
                                "Min",
                                "Function",
                            ];
                            _serde::Deserializer::deserialize_enum(
                                __deserializer,
                                "SubtaskCalcMethod",
                                VARIANTS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<SubtaskCalcMethod>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for SubtaskCalcMethod {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            match *self {
                                SubtaskCalcMethod::Sum => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "SubtaskCalcMethod",
                                        0u32,
                                        "Sum",
                                    )
                                }
                                SubtaskCalcMethod::Max => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "SubtaskCalcMethod",
                                        1u32,
                                        "Max",
                                    )
                                }
                                SubtaskCalcMethod::Min => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "SubtaskCalcMethod",
                                        2u32,
                                        "Min",
                                    )
                                }
                                SubtaskCalcMethod::Function => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "SubtaskCalcMethod",
                                        3u32,
                                        "Function",
                                    )
                                }
                            }
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for SubtaskCalcMethod {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::write_str(
                            f,
                            match self {
                                SubtaskCalcMethod::Sum => "Sum",
                                SubtaskCalcMethod::Max => "Max",
                                SubtaskCalcMethod::Min => "Min",
                                SubtaskCalcMethod::Function => "Function",
                            },
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SubtaskCalcMethod {
                    #[inline]
                    fn clone(&self) -> SubtaskCalcMethod {
                        match self {
                            SubtaskCalcMethod::Sum => SubtaskCalcMethod::Sum,
                            SubtaskCalcMethod::Max => SubtaskCalcMethod::Max,
                            SubtaskCalcMethod::Min => SubtaskCalcMethod::Min,
                            SubtaskCalcMethod::Function => SubtaskCalcMethod::Function,
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::enum_const::EnumConst for SubtaskCalcMethod {
                    fn get_const_isize(&self) -> Option<isize> {
                        match self {
                            Self::Sum => Some(0),
                            Self::Max => Some(1),
                            Self::Min => Some(2),
                            Self::Function => Some(3),
                            _ => None,
                        }
                    }
                    fn from_const_isize(i: isize) -> Option<Self> {
                        match i {
                            0 => Some(Self::Sum),
                            1 => Some(Self::Max),
                            2 => Some(Self::Min),
                            3 => Some(Self::Function),
                            _ => None,
                        }
                    }
                }
                ///An iterator over the variants of [SubtaskCalcMethod]
                #[allow(missing_copy_implementations)]
                pub struct SubtaskCalcMethodIter {
                    idx: usize,
                    back_idx: usize,
                    marker: ::core::marker::PhantomData<fn() -> ()>,
                }
                impl ::core::fmt::Debug for SubtaskCalcMethodIter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SubtaskCalcMethodIter")
                            .field("len", &self.len())
                            .finish()
                    }
                }
                impl SubtaskCalcMethodIter {
                    fn get(
                        &self,
                        idx: usize,
                    ) -> ::core::option::Option<SubtaskCalcMethod> {
                        match idx {
                            0usize => {
                                ::core::option::Option::Some(SubtaskCalcMethod::Sum)
                            }
                            1usize => {
                                ::core::option::Option::Some(SubtaskCalcMethod::Max)
                            }
                            2usize => {
                                ::core::option::Option::Some(SubtaskCalcMethod::Min)
                            }
                            3usize => {
                                ::core::option::Option::Some(SubtaskCalcMethod::Function)
                            }
                            _ => ::core::option::Option::None,
                        }
                    }
                }
                impl ::strum::IntoEnumIterator for SubtaskCalcMethod {
                    type Iterator = SubtaskCalcMethodIter;
                    #[inline]
                    fn iter() -> SubtaskCalcMethodIter {
                        SubtaskCalcMethodIter {
                            idx: 0,
                            back_idx: 0,
                            marker: ::core::marker::PhantomData,
                        }
                    }
                }
                impl Iterator for SubtaskCalcMethodIter {
                    type Item = SubtaskCalcMethod;
                    #[inline]
                    fn next(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        self.nth(0)
                    }
                    #[inline]
                    fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
                        let t = if self.idx + self.back_idx >= 4usize {
                            0
                        } else {
                            4usize - self.idx - self.back_idx
                        };
                        (t, Some(t))
                    }
                    #[inline]
                    fn nth(
                        &mut self,
                        n: usize,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let idx = self.idx + n + 1;
                        if idx + self.back_idx > 4usize {
                            self.idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.idx = idx;
                            SubtaskCalcMethodIter::get(self, idx - 1)
                        }
                    }
                }
                impl ExactSizeIterator for SubtaskCalcMethodIter {
                    #[inline]
                    fn len(&self) -> usize {
                        self.size_hint().0
                    }
                }
                impl DoubleEndedIterator for SubtaskCalcMethodIter {
                    #[inline]
                    fn next_back(
                        &mut self,
                    ) -> ::core::option::Option<<Self as Iterator>::Item> {
                        let back_idx = self.back_idx + 1;
                        if self.idx + back_idx > 4usize {
                            self.back_idx = 4usize;
                            ::core::option::Option::None
                        } else {
                            self.back_idx = back_idx;
                            SubtaskCalcMethodIter::get(self, 4usize - self.back_idx)
                        }
                    }
                }
                impl ::core::iter::FusedIterator for SubtaskCalcMethodIter {}
                impl Clone for SubtaskCalcMethodIter {
                    #[inline]
                    fn clone(&self) -> SubtaskCalcMethodIter {
                        SubtaskCalcMethodIter {
                            idx: self.idx,
                            back_idx: self.back_idx,
                            marker: self.marker.clone(),
                        }
                    }
                }
                impl From<SubtaskCalcMethod> for i32 {
                    fn from(method: SubtaskCalcMethod) -> Self {
                        method.get_const_isize().unwrap_or(0) as i32
                    }
                }
                impl From<String> for SubtaskCalcMethod {
                    fn from(s: String) -> Self {
                        match s.as_str() {
                            "sum" => SubtaskCalcMethod::Sum,
                            "max" => SubtaskCalcMethod::Max,
                            "min" => SubtaskCalcMethod::Min,
                            "function" => SubtaskCalcMethod::Function,
                            _ => SubtaskCalcMethod::Sum,
                        }
                    }
                }
                impl ToString for SubtaskCalcMethod {
                    fn to_string(&self) -> String {
                        match self {
                            SubtaskCalcMethod::Sum => "sum".to_string(),
                            SubtaskCalcMethod::Max => "max".to_string(),
                            SubtaskCalcMethod::Min => "min".to_string(),
                            SubtaskCalcMethod::Function => "function".to_string(),
                        }
                    }
                }
                impl From<i32> for SubtaskCalcMethod {
                    fn from(method: i32) -> Self {
                        match method {
                            0 => SubtaskCalcMethod::Sum,
                            1 => SubtaskCalcMethod::Max,
                            2 => SubtaskCalcMethod::Min,
                            3 => SubtaskCalcMethod::Function,
                            _ => SubtaskCalcMethod::Sum,
                        }
                    }
                }
                pub struct SubtaskNodePublic {
                    pub subtask_id: i32,
                    pub time_limit: i64,
                    pub memory_limit: i64,
                    pub subtask_calc_method: SubtaskCalcMethod,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for SubtaskNodePublic {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "subtask_id" => _serde::__private::Ok(__Field::__field0),
                                        "time_limit" => _serde::__private::Ok(__Field::__field1),
                                        "memory_limit" => _serde::__private::Ok(__Field::__field2),
                                        "subtask_calc_method" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"subtask_id" => _serde::__private::Ok(__Field::__field0),
                                        b"time_limit" => _serde::__private::Ok(__Field::__field1),
                                        b"memory_limit" => _serde::__private::Ok(__Field::__field2),
                                        b"subtask_calc_method" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<SubtaskNodePublic>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = SubtaskNodePublic;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct SubtaskNodePublic",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i32,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct SubtaskNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct SubtaskNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct SubtaskNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        SubtaskCalcMethod,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct SubtaskNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePublic {
                                        subtask_id: __field0,
                                        time_limit: __field1,
                                        memory_limit: __field2,
                                        subtask_calc_method: __field3,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<
                                        SubtaskCalcMethod,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "subtask_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "time_limit",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "memory_limit",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "subtask_calc_method",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        SubtaskCalcMethod,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("subtask_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("time_limit")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("memory_limit")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("subtask_calc_method")?
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePublic {
                                        subtask_id: __field0,
                                        time_limit: __field1,
                                        memory_limit: __field2,
                                        subtask_calc_method: __field3,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "subtask_id",
                                "time_limit",
                                "memory_limit",
                                "subtask_calc_method",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "SubtaskNodePublic",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<SubtaskNodePublic>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for SubtaskNodePublic {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "SubtaskNodePublic",
                                false as usize + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "subtask_id",
                                &self.subtask_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "time_limit",
                                &self.time_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "memory_limit",
                                &self.memory_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "subtask_calc_method",
                                &self.subtask_calc_method,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for SubtaskNodePublic {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "SubtaskNodePublic",
                            "subtask_id",
                            &self.subtask_id,
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &self.memory_limit,
                            "subtask_calc_method",
                            &&self.subtask_calc_method,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SubtaskNodePublic {
                    #[inline]
                    fn clone(&self) -> SubtaskNodePublic {
                        SubtaskNodePublic {
                            subtask_id: ::core::clone::Clone::clone(&self.subtask_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            subtask_calc_method: ::core::clone::Clone::clone(
                                &self.subtask_calc_method,
                            ),
                        }
                    }
                }
                pub struct SubtaskNodePrivate {
                    pub subtask_calc_function: Option<String>,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for SubtaskNodePrivate {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "subtask_calc_function" => {
                                            _serde::__private::Ok(__Field::__field0)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"subtask_calc_function" => {
                                            _serde::__private::Ok(__Field::__field0)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<SubtaskNodePrivate>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = SubtaskNodePrivate;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct SubtaskNodePrivate",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        Option<String>,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct SubtaskNodePrivate with 1 element",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePrivate {
                                        subtask_calc_function: __field0,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        Option<String>,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "subtask_calc_function",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        Option<String>,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field(
                                                "subtask_calc_function",
                                            )?
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePrivate {
                                        subtask_calc_function: __field0,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "subtask_calc_function",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "SubtaskNodePrivate",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        SubtaskNodePrivate,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for SubtaskNodePrivate {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "SubtaskNodePrivate",
                                false as usize + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "subtask_calc_function",
                                &self.subtask_calc_function,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for SubtaskNodePrivate {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SubtaskNodePrivate",
                            "subtask_calc_function",
                            &&self.subtask_calc_function,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SubtaskNodePrivate {
                    #[inline]
                    fn clone(&self) -> SubtaskNodePrivate {
                        SubtaskNodePrivate {
                            subtask_calc_function: ::core::clone::Clone::clone(
                                &self.subtask_calc_function,
                            ),
                        }
                    }
                }
                pub struct SubtaskNodePublicRaw {
                    pub subtask_id: i32,
                    pub time_limit: i64,
                    pub memory_limit: i64,
                    pub subtask_calc_method: SubtaskCalcMethod,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for SubtaskNodePublicRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "subtask_id" => _serde::__private::Ok(__Field::__field0),
                                        "time_limit" => _serde::__private::Ok(__Field::__field1),
                                        "memory_limit" => _serde::__private::Ok(__Field::__field2),
                                        "subtask_calc_method" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"subtask_id" => _serde::__private::Ok(__Field::__field0),
                                        b"time_limit" => _serde::__private::Ok(__Field::__field1),
                                        b"memory_limit" => _serde::__private::Ok(__Field::__field2),
                                        b"subtask_calc_method" => {
                                            _serde::__private::Ok(__Field::__field3)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    SubtaskNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = SubtaskNodePublicRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct SubtaskNodePublicRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i32,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct SubtaskNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct SubtaskNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct SubtaskNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        SubtaskCalcMethod,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct SubtaskNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePublicRaw {
                                        subtask_id: __field0,
                                        time_limit: __field1,
                                        memory_limit: __field2,
                                        subtask_calc_method: __field3,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<
                                        SubtaskCalcMethod,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "subtask_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i32>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "time_limit",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "memory_limit",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "subtask_calc_method",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        SubtaskCalcMethod,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("subtask_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("time_limit")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("memory_limit")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("subtask_calc_method")?
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePublicRaw {
                                        subtask_id: __field0,
                                        time_limit: __field1,
                                        memory_limit: __field2,
                                        subtask_calc_method: __field3,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "subtask_id",
                                "time_limit",
                                "memory_limit",
                                "subtask_calc_method",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "SubtaskNodePublicRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        SubtaskNodePublicRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for SubtaskNodePublicRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "SubtaskNodePublicRaw",
                                false as usize + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "subtask_id",
                                &self.subtask_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "time_limit",
                                &self.time_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "memory_limit",
                                &self.memory_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "subtask_calc_method",
                                &self.subtask_calc_method,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for SubtaskNodePublicRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "SubtaskNodePublicRaw",
                            "subtask_id",
                            &self.subtask_id,
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &self.memory_limit,
                            "subtask_calc_method",
                            &&self.subtask_calc_method,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SubtaskNodePublicRaw {
                    #[inline]
                    fn clone(&self) -> SubtaskNodePublicRaw {
                        SubtaskNodePublicRaw {
                            subtask_id: ::core::clone::Clone::clone(&self.subtask_id),
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            subtask_calc_method: ::core::clone::Clone::clone(
                                &self.subtask_calc_method,
                            ),
                        }
                    }
                }
                pub struct SubtaskNodePrivateRaw {
                    pub subtask_calc_function: Option<String>,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for SubtaskNodePrivateRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "subtask_calc_function" => {
                                            _serde::__private::Ok(__Field::__field0)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"subtask_calc_function" => {
                                            _serde::__private::Ok(__Field::__field0)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    SubtaskNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = SubtaskNodePrivateRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct SubtaskNodePrivateRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        Option<String>,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct SubtaskNodePrivateRaw with 1 element",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePrivateRaw {
                                        subtask_calc_function: __field0,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        Option<String>,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "subtask_calc_function",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        Option<String>,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field(
                                                "subtask_calc_function",
                                            )?
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodePrivateRaw {
                                        subtask_calc_function: __field0,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "subtask_calc_function",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "SubtaskNodePrivateRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        SubtaskNodePrivateRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for SubtaskNodePrivateRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "SubtaskNodePrivateRaw",
                                false as usize + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "subtask_calc_function",
                                &self.subtask_calc_function,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for SubtaskNodePrivateRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "SubtaskNodePrivateRaw",
                            "subtask_calc_function",
                            &&self.subtask_calc_function,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SubtaskNodePrivateRaw {
                    #[inline]
                    fn clone(&self) -> SubtaskNodePrivateRaw {
                        SubtaskNodePrivateRaw {
                            subtask_calc_function: ::core::clone::Clone::clone(
                                &self.subtask_calc_function,
                            ),
                        }
                    }
                }
                pub struct SubtaskNode {
                    pub node_id: i64,
                    pub public: SubtaskNodePublic,
                    pub private: SubtaskNodePrivate,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for SubtaskNode {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "public" => _serde::__private::Ok(__Field::__field1),
                                        "private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"public" => _serde::__private::Ok(__Field::__field1),
                                        b"private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<SubtaskNode>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = SubtaskNode;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct SubtaskNode",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct SubtaskNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        SubtaskNodePublic,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct SubtaskNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        SubtaskNodePrivate,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct SubtaskNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        SubtaskNodePublic,
                                    > = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<
                                        SubtaskNodePrivate,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        SubtaskNodePublic,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        SubtaskNodePrivate,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "node_id",
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "SubtaskNode",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<SubtaskNode>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for SubtaskNode {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "SubtaskNode",
                                false as usize + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for SubtaskNode {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "SubtaskNode",
                            "node_id",
                            &self.node_id,
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SubtaskNode {
                    #[inline]
                    fn clone(&self) -> SubtaskNode {
                        SubtaskNode {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl Node<ActiveModel, Model, Entity> for SubtaskNode {
                    fn get_node_id(&self) -> i64 {
                        self.node_id
                    }
                    fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                #[node_raw(node_type = "testcase_subtask")]
                pub struct SubtaskNodeRaw {
                    pub public: SubtaskNodePublicRaw,
                    pub private: SubtaskNodePrivateRaw,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for SubtaskNodeRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "public" => _serde::__private::Ok(__Field::__field0),
                                        "private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"public" => _serde::__private::Ok(__Field::__field0),
                                        b"private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<SubtaskNodeRaw>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = SubtaskNodeRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct SubtaskNodeRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        SubtaskNodePublicRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct SubtaskNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        SubtaskNodePrivateRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct SubtaskNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        SubtaskNodePublicRaw,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        SubtaskNodePrivateRaw,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        SubtaskNodePublicRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        SubtaskNodePrivateRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(SubtaskNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "SubtaskNodeRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<SubtaskNodeRaw>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for SubtaskNodeRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "SubtaskNodeRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for SubtaskNodeRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "SubtaskNodeRaw",
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for SubtaskNodeRaw {
                    #[inline]
                    fn clone(&self) -> SubtaskNodeRaw {
                        SubtaskNodeRaw {
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl NodeRaw<SubtaskNode, Model, ActiveModel> for SubtaskNodeRaw {
                    fn get_node_type(&self) -> &str {
                        "testcase_subtask"
                    }
                    fn get_node_id_column(
                        &self,
                    ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                impl From<SubtaskNodeRaw> for ActiveModel {
                    fn from(value: SubtaskNodeRaw) -> Self {
                        use sea_orm::ActiveValue::{NotSet, Set};
                        Self {
                            node_id: NotSet,
                            subtask_id: Set(value.public.subtask_id),
                            time_limit: Set(value.public.time_limit),
                            memory_limit: Set(value.public.memory_limit),
                            subtask_calc_method: Set(
                                value.public.subtask_calc_method.into(),
                            ),
                            subtask_calc_function: Set(
                                value.private.subtask_calc_function,
                            ),
                        }
                    }
                }
                impl From<Model> for SubtaskNode {
                    fn from(model: Model) -> Self {
                        Self {
                            node_id: model.node_id,
                            public: SubtaskNodePublic {
                                subtask_id: model.subtask_id,
                                time_limit: model.time_limit,
                                memory_limit: model.memory_limit,
                                subtask_calc_method: model.subtask_calc_method.into(),
                            },
                            private: SubtaskNodePrivate {
                                subtask_calc_function: model.subtask_calc_function,
                            },
                        }
                    }
                }
                use crate::db;
                use crate::graph::node::Node;
                use crate::graph::node::NodeRaw;
                use chrono::NaiveDateTime;
                use db::entity::node::testcase_subtask::{
                    ActiveModel, Column, Entity, Model,
                };
                use enum_const::EnumConst;
                use macro_node_iden::{Node, NodeRaw};
                use sea_orm::EntityTrait;
                use serde::{Deserialize, Serialize};
                use strum_macros::EnumIter;
            }
            pub mod testcase {
                pub struct FileIOMethod {
                    pub in_file: String,
                    pub out_file: String,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for FileIOMethod {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "in_file" => _serde::__private::Ok(__Field::__field0),
                                        "out_file" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"in_file" => _serde::__private::Ok(__Field::__field0),
                                        b"out_file" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<FileIOMethod>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = FileIOMethod;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct FileIOMethod",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct FileIOMethod with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct FileIOMethod with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(FileIOMethod {
                                        in_file: __field0,
                                        out_file: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "in_file",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "out_file",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("in_file")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("out_file")?
                                        }
                                    };
                                    _serde::__private::Ok(FileIOMethod {
                                        in_file: __field0,
                                        out_file: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "in_file",
                                "out_file",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "FileIOMethod",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<FileIOMethod>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for FileIOMethod {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "FileIOMethod",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "in_file",
                                &self.in_file,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "out_file",
                                &self.out_file,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for FileIOMethod {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "FileIOMethod",
                            "in_file",
                            &self.in_file,
                            "out_file",
                            &&self.out_file,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for FileIOMethod {
                    #[inline]
                    fn clone(&self) -> FileIOMethod {
                        FileIOMethod {
                            in_file: ::core::clone::Clone::clone(&self.in_file),
                            out_file: ::core::clone::Clone::clone(&self.out_file),
                        }
                    }
                }
                pub enum JudgeIOMethod {
                    Std,
                    FileIO(FileIOMethod),
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for JudgeIOMethod {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "variant identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => {
                                            _serde::__private::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"variant index 0 <= i < 2",
                                                ),
                                            )
                                        }
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "Std" => _serde::__private::Ok(__Field::__field0),
                                        "FileIO" => _serde::__private::Ok(__Field::__field1),
                                        _ => {
                                            _serde::__private::Err(
                                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                                            )
                                        }
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"Std" => _serde::__private::Ok(__Field::__field0),
                                        b"FileIO" => _serde::__private::Ok(__Field::__field1),
                                        _ => {
                                            let __value = &_serde::__private::from_utf8_lossy(__value);
                                            _serde::__private::Err(
                                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                                            )
                                        }
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<JudgeIOMethod>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = JudgeIOMethod;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "enum JudgeIOMethod",
                                    )
                                }
                                fn visit_enum<__A>(
                                    self,
                                    __data: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::EnumAccess<'de>,
                                {
                                    match _serde::de::EnumAccess::variant(__data)? {
                                        (__Field::__field0, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(JudgeIOMethod::Std)
                                        }
                                        (__Field::__field1, __variant) => {
                                            _serde::__private::Result::map(
                                                _serde::de::VariantAccess::newtype_variant::<
                                                    FileIOMethod,
                                                >(__variant),
                                                JudgeIOMethod::FileIO,
                                            )
                                        }
                                    }
                                }
                            }
                            #[doc(hidden)]
                            const VARIANTS: &'static [&'static str] = &["Std", "FileIO"];
                            _serde::Deserializer::deserialize_enum(
                                __deserializer,
                                "JudgeIOMethod",
                                VARIANTS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<JudgeIOMethod>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for JudgeIOMethod {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            match *self {
                                JudgeIOMethod::Std => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "JudgeIOMethod",
                                        0u32,
                                        "Std",
                                    )
                                }
                                JudgeIOMethod::FileIO(ref __field0) => {
                                    _serde::Serializer::serialize_newtype_variant(
                                        __serializer,
                                        "JudgeIOMethod",
                                        1u32,
                                        "FileIO",
                                        __field0,
                                    )
                                }
                            }
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for JudgeIOMethod {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match self {
                            JudgeIOMethod::Std => {
                                ::core::fmt::Formatter::write_str(f, "Std")
                            }
                            JudgeIOMethod::FileIO(__self_0) => {
                                ::core::fmt::Formatter::debug_tuple_field1_finish(
                                    f,
                                    "FileIO",
                                    &__self_0,
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for JudgeIOMethod {
                    #[inline]
                    fn clone(&self) -> JudgeIOMethod {
                        match self {
                            JudgeIOMethod::Std => JudgeIOMethod::Std,
                            JudgeIOMethod::FileIO(__self_0) => {
                                JudgeIOMethod::FileIO(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl From<JudgeIOMethod> for String {
                    fn from(method: JudgeIOMethod) -> Self {
                        match method {
                            JudgeIOMethod::Std => "std".to_string(),
                            JudgeIOMethod::FileIO(file_io) => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!(
                                            "file_io:in={0},out={1}",
                                            file_io.in_file,
                                            file_io.out_file,
                                        ),
                                    )
                                })
                            }
                        }
                    }
                }
                impl From<String> for JudgeIOMethod {
                    fn from(s: String) -> Self {
                        if s.starts_with("file_io:") {
                            let parts: Vec<&str> = s[8..].split(',').collect();
                            if parts.len() == 2 {
                                let in_file = parts[0]
                                    .split('=')
                                    .nth(1)
                                    .unwrap_or("")
                                    .to_string();
                                let out_file = parts[1]
                                    .split('=')
                                    .nth(1)
                                    .unwrap_or("")
                                    .to_string();
                                return JudgeIOMethod::FileIO(FileIOMethod {
                                    in_file,
                                    out_file,
                                });
                            }
                        }
                        JudgeIOMethod::Std
                    }
                }
                pub enum JudgeDiffMethod {
                    IgnoreSpace,
                    Strict,
                    YesNo,
                    SPJ(String),
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for JudgeDiffMethod {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "variant identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => {
                                            _serde::__private::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"variant index 0 <= i < 4",
                                                ),
                                            )
                                        }
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "IgnoreSpace" => _serde::__private::Ok(__Field::__field0),
                                        "Strict" => _serde::__private::Ok(__Field::__field1),
                                        "YesNo" => _serde::__private::Ok(__Field::__field2),
                                        "SPJ" => _serde::__private::Ok(__Field::__field3),
                                        _ => {
                                            _serde::__private::Err(
                                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                                            )
                                        }
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"IgnoreSpace" => _serde::__private::Ok(__Field::__field0),
                                        b"Strict" => _serde::__private::Ok(__Field::__field1),
                                        b"YesNo" => _serde::__private::Ok(__Field::__field2),
                                        b"SPJ" => _serde::__private::Ok(__Field::__field3),
                                        _ => {
                                            let __value = &_serde::__private::from_utf8_lossy(__value);
                                            _serde::__private::Err(
                                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                                            )
                                        }
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<JudgeDiffMethod>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = JudgeDiffMethod;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "enum JudgeDiffMethod",
                                    )
                                }
                                fn visit_enum<__A>(
                                    self,
                                    __data: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::EnumAccess<'de>,
                                {
                                    match _serde::de::EnumAccess::variant(__data)? {
                                        (__Field::__field0, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(JudgeDiffMethod::IgnoreSpace)
                                        }
                                        (__Field::__field1, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(JudgeDiffMethod::Strict)
                                        }
                                        (__Field::__field2, __variant) => {
                                            _serde::de::VariantAccess::unit_variant(__variant)?;
                                            _serde::__private::Ok(JudgeDiffMethod::YesNo)
                                        }
                                        (__Field::__field3, __variant) => {
                                            _serde::__private::Result::map(
                                                _serde::de::VariantAccess::newtype_variant::<
                                                    String,
                                                >(__variant),
                                                JudgeDiffMethod::SPJ,
                                            )
                                        }
                                    }
                                }
                            }
                            #[doc(hidden)]
                            const VARIANTS: &'static [&'static str] = &[
                                "IgnoreSpace",
                                "Strict",
                                "YesNo",
                                "SPJ",
                            ];
                            _serde::Deserializer::deserialize_enum(
                                __deserializer,
                                "JudgeDiffMethod",
                                VARIANTS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<JudgeDiffMethod>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for JudgeDiffMethod {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            match *self {
                                JudgeDiffMethod::IgnoreSpace => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "JudgeDiffMethod",
                                        0u32,
                                        "IgnoreSpace",
                                    )
                                }
                                JudgeDiffMethod::Strict => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "JudgeDiffMethod",
                                        1u32,
                                        "Strict",
                                    )
                                }
                                JudgeDiffMethod::YesNo => {
                                    _serde::Serializer::serialize_unit_variant(
                                        __serializer,
                                        "JudgeDiffMethod",
                                        2u32,
                                        "YesNo",
                                    )
                                }
                                JudgeDiffMethod::SPJ(ref __field0) => {
                                    _serde::Serializer::serialize_newtype_variant(
                                        __serializer,
                                        "JudgeDiffMethod",
                                        3u32,
                                        "SPJ",
                                        __field0,
                                    )
                                }
                            }
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for JudgeDiffMethod {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match self {
                            JudgeDiffMethod::IgnoreSpace => {
                                ::core::fmt::Formatter::write_str(f, "IgnoreSpace")
                            }
                            JudgeDiffMethod::Strict => {
                                ::core::fmt::Formatter::write_str(f, "Strict")
                            }
                            JudgeDiffMethod::YesNo => {
                                ::core::fmt::Formatter::write_str(f, "YesNo")
                            }
                            JudgeDiffMethod::SPJ(__self_0) => {
                                ::core::fmt::Formatter::debug_tuple_field1_finish(
                                    f,
                                    "SPJ",
                                    &__self_0,
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for JudgeDiffMethod {
                    #[inline]
                    fn clone(&self) -> JudgeDiffMethod {
                        match self {
                            JudgeDiffMethod::IgnoreSpace => JudgeDiffMethod::IgnoreSpace,
                            JudgeDiffMethod::Strict => JudgeDiffMethod::Strict,
                            JudgeDiffMethod::YesNo => JudgeDiffMethod::YesNo,
                            JudgeDiffMethod::SPJ(__self_0) => {
                                JudgeDiffMethod::SPJ(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                impl From<JudgeDiffMethod> for String {
                    fn from(method: JudgeDiffMethod) -> Self {
                        match method {
                            JudgeDiffMethod::IgnoreSpace => "ignore_space".to_string(),
                            JudgeDiffMethod::Strict => "strict".to_string(),
                            JudgeDiffMethod::YesNo => "yes_no".to_string(),
                            JudgeDiffMethod::SPJ(spj) => {
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(format_args!("spj:{0}", spj))
                                })
                            }
                        }
                    }
                }
                impl From<String> for JudgeDiffMethod {
                    fn from(s: String) -> Self {
                        if s.starts_with("spj:") {
                            return JudgeDiffMethod::SPJ(s[4..].to_string());
                        }
                        match s.as_str() {
                            "ignore_space" => JudgeDiffMethod::IgnoreSpace,
                            "strict" => JudgeDiffMethod::Strict,
                            "yes_no" => JudgeDiffMethod::YesNo,
                            _ => JudgeDiffMethod::IgnoreSpace,
                        }
                    }
                }
                pub struct TestcaseNodePublic {
                    pub time_limit: i64,
                    pub memory_limit: i64,
                    pub in_file: i64,
                    pub out_file: i64,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for TestcaseNodePublic {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "time_limit" => _serde::__private::Ok(__Field::__field0),
                                        "memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        "in_file" => _serde::__private::Ok(__Field::__field2),
                                        "out_file" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"time_limit" => _serde::__private::Ok(__Field::__field0),
                                        b"memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        b"in_file" => _serde::__private::Ok(__Field::__field2),
                                        b"out_file" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<TestcaseNodePublic>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = TestcaseNodePublic;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct TestcaseNodePublic",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct TestcaseNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct TestcaseNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct TestcaseNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct TestcaseNodePublic with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePublic {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                        in_file: __field2,
                                        out_file: __field3,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "time_limit",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "memory_limit",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "in_file",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "out_file",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("time_limit")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("memory_limit")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("in_file")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("out_file")?
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePublic {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                        in_file: __field2,
                                        out_file: __field3,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "time_limit",
                                "memory_limit",
                                "in_file",
                                "out_file",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "TestcaseNodePublic",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        TestcaseNodePublic,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for TestcaseNodePublic {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "TestcaseNodePublic",
                                false as usize + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "time_limit",
                                &self.time_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "memory_limit",
                                &self.memory_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "in_file",
                                &self.in_file,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "out_file",
                                &self.out_file,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for TestcaseNodePublic {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "TestcaseNodePublic",
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &self.memory_limit,
                            "in_file",
                            &self.in_file,
                            "out_file",
                            &&self.out_file,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TestcaseNodePublic {
                    #[inline]
                    fn clone(&self) -> TestcaseNodePublic {
                        TestcaseNodePublic {
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            in_file: ::core::clone::Clone::clone(&self.in_file),
                            out_file: ::core::clone::Clone::clone(&self.out_file),
                        }
                    }
                }
                pub struct TestcaseNodePrivate {
                    pub io_method: JudgeIOMethod,
                    pub diff_method: JudgeDiffMethod,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for TestcaseNodePrivate {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "io_method" => _serde::__private::Ok(__Field::__field0),
                                        "diff_method" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"io_method" => _serde::__private::Ok(__Field::__field0),
                                        b"diff_method" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<TestcaseNodePrivate>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = TestcaseNodePrivate;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct TestcaseNodePrivate",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        JudgeIOMethod,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct TestcaseNodePrivate with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        JudgeDiffMethod,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct TestcaseNodePrivate with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePrivate {
                                        io_method: __field0,
                                        diff_method: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        JudgeIOMethod,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        JudgeDiffMethod,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "io_method",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        JudgeIOMethod,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "diff_method",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        JudgeDiffMethod,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("io_method")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("diff_method")?
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePrivate {
                                        io_method: __field0,
                                        diff_method: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "io_method",
                                "diff_method",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "TestcaseNodePrivate",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        TestcaseNodePrivate,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for TestcaseNodePrivate {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "TestcaseNodePrivate",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "io_method",
                                &self.io_method,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "diff_method",
                                &self.diff_method,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for TestcaseNodePrivate {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "TestcaseNodePrivate",
                            "io_method",
                            &self.io_method,
                            "diff_method",
                            &&self.diff_method,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TestcaseNodePrivate {
                    #[inline]
                    fn clone(&self) -> TestcaseNodePrivate {
                        TestcaseNodePrivate {
                            io_method: ::core::clone::Clone::clone(&self.io_method),
                            diff_method: ::core::clone::Clone::clone(&self.diff_method),
                        }
                    }
                }
                pub struct TestcaseNodePublicRaw {
                    pub time_limit: i64,
                    pub memory_limit: i64,
                    pub in_file: i64,
                    pub out_file: i64,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for TestcaseNodePublicRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        3u64 => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "time_limit" => _serde::__private::Ok(__Field::__field0),
                                        "memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        "in_file" => _serde::__private::Ok(__Field::__field2),
                                        "out_file" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"time_limit" => _serde::__private::Ok(__Field::__field0),
                                        b"memory_limit" => _serde::__private::Ok(__Field::__field1),
                                        b"in_file" => _serde::__private::Ok(__Field::__field2),
                                        b"out_file" => _serde::__private::Ok(__Field::__field3),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    TestcaseNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = TestcaseNodePublicRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct TestcaseNodePublicRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct TestcaseNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct TestcaseNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct TestcaseNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field3 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    3usize,
                                                    &"struct TestcaseNodePublicRaw with 4 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePublicRaw {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                        in_file: __field2,
                                        out_file: __field3,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "time_limit",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "memory_limit",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "in_file",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field3 => {
                                                if _serde::__private::Option::is_some(&__field3) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "out_file",
                                                        ),
                                                    );
                                                }
                                                __field3 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("time_limit")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("memory_limit")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("in_file")?
                                        }
                                    };
                                    let __field3 = match __field3 {
                                        _serde::__private::Some(__field3) => __field3,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("out_file")?
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePublicRaw {
                                        time_limit: __field0,
                                        memory_limit: __field1,
                                        in_file: __field2,
                                        out_file: __field3,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "time_limit",
                                "memory_limit",
                                "in_file",
                                "out_file",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "TestcaseNodePublicRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        TestcaseNodePublicRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for TestcaseNodePublicRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "TestcaseNodePublicRaw",
                                false as usize + 1 + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "time_limit",
                                &self.time_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "memory_limit",
                                &self.memory_limit,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "in_file",
                                &self.in_file,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "out_file",
                                &self.out_file,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for TestcaseNodePublicRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field4_finish(
                            f,
                            "TestcaseNodePublicRaw",
                            "time_limit",
                            &self.time_limit,
                            "memory_limit",
                            &self.memory_limit,
                            "in_file",
                            &self.in_file,
                            "out_file",
                            &&self.out_file,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TestcaseNodePublicRaw {
                    #[inline]
                    fn clone(&self) -> TestcaseNodePublicRaw {
                        TestcaseNodePublicRaw {
                            time_limit: ::core::clone::Clone::clone(&self.time_limit),
                            memory_limit: ::core::clone::Clone::clone(
                                &self.memory_limit,
                            ),
                            in_file: ::core::clone::Clone::clone(&self.in_file),
                            out_file: ::core::clone::Clone::clone(&self.out_file),
                        }
                    }
                }
                pub struct TestcaseNodePrivateRaw {
                    pub io_method: JudgeIOMethod,
                    pub diff_method: JudgeDiffMethod,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for TestcaseNodePrivateRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "io_method" => _serde::__private::Ok(__Field::__field0),
                                        "diff_method" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"io_method" => _serde::__private::Ok(__Field::__field0),
                                        b"diff_method" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<
                                    TestcaseNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = TestcaseNodePrivateRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct TestcaseNodePrivateRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        JudgeIOMethod,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct TestcaseNodePrivateRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        JudgeDiffMethod,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct TestcaseNodePrivateRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePrivateRaw {
                                        io_method: __field0,
                                        diff_method: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        JudgeIOMethod,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        JudgeDiffMethod,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "io_method",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        JudgeIOMethod,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "diff_method",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        JudgeDiffMethod,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("io_method")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("diff_method")?
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodePrivateRaw {
                                        io_method: __field0,
                                        diff_method: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "io_method",
                                "diff_method",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "TestcaseNodePrivateRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<
                                        TestcaseNodePrivateRaw,
                                    >,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for TestcaseNodePrivateRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "TestcaseNodePrivateRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "io_method",
                                &self.io_method,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "diff_method",
                                &self.diff_method,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for TestcaseNodePrivateRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "TestcaseNodePrivateRaw",
                            "io_method",
                            &self.io_method,
                            "diff_method",
                            &&self.diff_method,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TestcaseNodePrivateRaw {
                    #[inline]
                    fn clone(&self) -> TestcaseNodePrivateRaw {
                        TestcaseNodePrivateRaw {
                            io_method: ::core::clone::Clone::clone(&self.io_method),
                            diff_method: ::core::clone::Clone::clone(&self.diff_method),
                        }
                    }
                }
                pub struct TestcaseNode {
                    pub node_id: i64,
                    pub public: TestcaseNodePublic,
                    pub private: TestcaseNodePrivate,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for TestcaseNode {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "node_id" => _serde::__private::Ok(__Field::__field0),
                                        "public" => _serde::__private::Ok(__Field::__field1),
                                        "private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"node_id" => _serde::__private::Ok(__Field::__field0),
                                        b"public" => _serde::__private::Ok(__Field::__field1),
                                        b"private" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<TestcaseNode>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = TestcaseNode;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct TestcaseNode",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        i64,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct TestcaseNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        TestcaseNodePublic,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct TestcaseNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field2 = match _serde::de::SeqAccess::next_element::<
                                        TestcaseNodePrivate,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct TestcaseNode with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        TestcaseNodePublic,
                                    > = _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<
                                        TestcaseNodePrivate,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "node_id",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        TestcaseNodePublic,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field2 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        TestcaseNodePrivate,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("node_id")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNode {
                                        node_id: __field0,
                                        public: __field1,
                                        private: __field2,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "node_id",
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "TestcaseNode",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<TestcaseNode>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for TestcaseNode {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "TestcaseNode",
                                false as usize + 1 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "node_id",
                                &self.node_id,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for TestcaseNode {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "TestcaseNode",
                            "node_id",
                            &self.node_id,
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TestcaseNode {
                    #[inline]
                    fn clone(&self) -> TestcaseNode {
                        TestcaseNode {
                            node_id: ::core::clone::Clone::clone(&self.node_id),
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl Node<ActiveModel, Model, Entity> for TestcaseNode {
                    fn get_node_id(&self) -> i64 {
                        self.node_id
                    }
                    fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                #[node_raw(node_type = "testcase")]
                pub struct TestcaseNodeRaw {
                    pub public: TestcaseNodePublicRaw,
                    pub private: TestcaseNodePrivateRaw,
                }
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for TestcaseNodeRaw {
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "public" => _serde::__private::Ok(__Field::__field0),
                                        "private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"public" => _serde::__private::Ok(__Field::__field0),
                                        b"private" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<TestcaseNodeRaw>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = TestcaseNodeRaw;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct TestcaseNodeRaw",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        TestcaseNodePublicRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct TestcaseNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        TestcaseNodePrivateRaw,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct TestcaseNodeRaw with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<
                                        TestcaseNodePublicRaw,
                                    > = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<
                                        TestcaseNodePrivateRaw,
                                    > = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        TestcaseNodePublicRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "private",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<
                                                        TestcaseNodePrivateRaw,
                                                    >(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("public")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("private")?
                                        }
                                    };
                                    _serde::__private::Ok(TestcaseNodeRaw {
                                        public: __field0,
                                        private: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "public",
                                "private",
                            ];
                            _serde::Deserializer::deserialize_struct(
                                __deserializer,
                                "TestcaseNodeRaw",
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<TestcaseNodeRaw>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                };
                #[doc(hidden)]
                #[allow(
                    non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications,
                    clippy::absolute_paths,
                )]
                const _: () = {
                    #[allow(unused_extern_crates, clippy::useless_attribute)]
                    extern crate serde as _serde;
                    #[automatically_derived]
                    impl _serde::Serialize for TestcaseNodeRaw {
                        fn serialize<__S>(
                            &self,
                            __serializer: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            let mut __serde_state = _serde::Serializer::serialize_struct(
                                __serializer,
                                "TestcaseNodeRaw",
                                false as usize + 1 + 1,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "public",
                                &self.public,
                            )?;
                            _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "private",
                                &self.private,
                            )?;
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
                #[automatically_derived]
                impl ::core::fmt::Debug for TestcaseNodeRaw {
                    #[inline]
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "TestcaseNodeRaw",
                            "public",
                            &self.public,
                            "private",
                            &&self.private,
                        )
                    }
                }
                #[automatically_derived]
                impl ::core::clone::Clone for TestcaseNodeRaw {
                    #[inline]
                    fn clone(&self) -> TestcaseNodeRaw {
                        TestcaseNodeRaw {
                            public: ::core::clone::Clone::clone(&self.public),
                            private: ::core::clone::Clone::clone(&self.private),
                        }
                    }
                }
                impl NodeRaw<TestcaseNode, Model, ActiveModel> for TestcaseNodeRaw {
                    fn get_node_type(&self) -> &str {
                        "testcase"
                    }
                    fn get_node_id_column(
                        &self,
                    ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                        Column::NodeId
                    }
                }
                impl From<TestcaseNodeRaw> for ActiveModel {
                    fn from(value: TestcaseNodeRaw) -> Self {
                        use sea_orm::ActiveValue::{NotSet, Set};
                        Self {
                            node_id: NotSet,
                            time_limit: Set(value.public.time_limit),
                            memory_limit: Set(value.public.memory_limit),
                            in_file: Set(value.public.in_file),
                            out_file: Set(value.public.out_file),
                            io_method: Set(value.private.io_method.into()),
                            diff_method: Set(value.private.diff_method.into()),
                        }
                    }
                }
                impl From<Model> for TestcaseNode {
                    fn from(model: Model) -> Self {
                        Self {
                            node_id: model.node_id,
                            public: TestcaseNodePublic {
                                time_limit: model.time_limit,
                                memory_limit: model.memory_limit,
                                in_file: model.in_file,
                                out_file: model.out_file,
                            },
                            private: TestcaseNodePrivate {
                                io_method: model.io_method.into(),
                                diff_method: model.diff_method.into(),
                            },
                        }
                    }
                }
                use crate::db;
                use crate::graph::node::Node;
                use crate::graph::node::NodeRaw;
                use chrono::NaiveDateTime;
                use db::entity::node::testcase::{ActiveModel, Column, Entity, Model};
                use enum_const::EnumConst;
                use macro_node_iden::{Node, NodeRaw};
                use sea_orm::EntityTrait;
                use serde::{Deserialize, Serialize};
                use strum_macros::EnumIter;
            }
            impl From<i64> for RecordStatus {
                fn from(value: i64) -> Self {
                    match value {
                        100 => RecordStatus::Accepted,
                        101 => RecordStatus::PartialAccepted,
                        200 => RecordStatus::WrongAnswer,
                        301 => RecordStatus::TimeLimitExceeded,
                        302 => RecordStatus::MemoryLimitExceeded,
                        303 => RecordStatus::OutputLimitExceeded,
                        400 => RecordStatus::RuntimeError,
                        500 => RecordStatus::CompileError,
                        501 => RecordStatus::DangerousCode,
                        600 => RecordStatus::RemoteServiceUnknownError,
                        601 => RecordStatus::SandboxError,
                        700 => RecordStatus::RemotePlatformRefused,
                        701 => RecordStatus::RemotePlatformConnectionFailed,
                        702 => RecordStatus::RemotePlatformUnknownError,
                        800 => RecordStatus::Waiting,
                        900 => RecordStatus::UnknownError,
                        901 => RecordStatus::Unverified,
                        _ => RecordStatus::UnknownError,
                    }
                }
            }
            impl From<RecordStatus> for i64 {
                fn from(status: RecordStatus) -> Self {
                    status.get_const_isize().unwrap_or(900) as i64
                }
            }
            impl ToString for RecordStatus {
                fn to_string(&self) -> String {
                    match self {
                        RecordStatus::Accepted => "Accepted".to_string(),
                        RecordStatus::PartialAccepted => "Partial Accepted".to_string(),
                        RecordStatus::WrongAnswer => "Wrong Answer".to_string(),
                        RecordStatus::TimeLimitExceeded => {
                            "Time Limit Exceeded".to_string()
                        }
                        RecordStatus::MemoryLimitExceeded => {
                            "Memory Limit Exceeded".to_string()
                        }
                        RecordStatus::OutputLimitExceeded => {
                            "Output Limit Exceeded".to_string()
                        }
                        RecordStatus::RuntimeError => "Runtime Error".to_string(),
                        RecordStatus::CompileError => "Compile Error".to_string(),
                        RecordStatus::DangerousCode => "Dangerous Code".to_string(),
                        RecordStatus::RemoteServiceUnknownError => {
                            "Remote Service Unknown Error".to_string()
                        }
                        RecordStatus::SandboxError => "Sandbox Error".to_string(),
                        RecordStatus::RemotePlatformRefused => {
                            "Remote Platform Refused".to_string()
                        }
                        RecordStatus::RemotePlatformConnectionFailed => {
                            "Remote Platform Connection Failed".to_string()
                        }
                        RecordStatus::RemotePlatformUnknownError => {
                            "Remote Platform Unknown Error".to_string()
                        }
                        RecordStatus::Waiting => "Waiting".to_string(),
                        RecordStatus::UnknownError => "Unknown Error".to_string(),
                        RecordStatus::Unverified => "Unverified".to_string(),
                    }
                }
            }
            impl From<String> for RecordStatus {
                fn from(s: String) -> Self {
                    match s.as_str() {
                        "Accepted" => RecordStatus::Accepted,
                        "Partial Accepted" => RecordStatus::PartialAccepted,
                        "Wrong Answer" => RecordStatus::WrongAnswer,
                        "Time Limit Exceeded" => RecordStatus::TimeLimitExceeded,
                        "Memory Limit Exceeded" => RecordStatus::MemoryLimitExceeded,
                        "Output Limit Exceeded" => RecordStatus::OutputLimitExceeded,
                        "Runtime Error" => RecordStatus::RuntimeError,
                        "Compile Error" => RecordStatus::CompileError,
                        "Dangerous Code" => RecordStatus::DangerousCode,
                        "Remote Service Unknown Error" => {
                            RecordStatus::RemoteServiceUnknownError
                        }
                        "Sandbox Error" => RecordStatus::SandboxError,
                        "Remote Platform Refused" => RecordStatus::RemotePlatformRefused,
                        "Remote Platform Connection Failed" => {
                            RecordStatus::RemotePlatformConnectionFailed
                        }
                        "Remote Platform Unknown Error" => {
                            RecordStatus::RemotePlatformUnknownError
                        }
                        "Waiting" => RecordStatus::Waiting,
                        "Unknown Error" => RecordStatus::UnknownError,
                        "Unverified" => RecordStatus::Unverified,
                        _ => RecordStatus::UnknownError,
                    }
                }
            }
        }
        pub mod token {
            pub struct TokenNodePublic {
                pub token_type: String,
                pub token_expiration: NaiveDateTime,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TokenNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "token_type" => _serde::__private::Ok(__Field::__field0),
                                    "token_expiration" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"token_type" => _serde::__private::Ok(__Field::__field0),
                                    b"token_expiration" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TokenNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TokenNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TokenNodePublic with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TokenNodePublic with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TokenNodePublic {
                                    token_type: __field0,
                                    token_expiration: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "token_type",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "token_expiration",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("token_type")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("token_expiration")?
                                    }
                                };
                                _serde::__private::Ok(TokenNodePublic {
                                    token_type: __field0,
                                    token_expiration: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "token_type",
                            "token_expiration",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TokenNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TokenNodePublic>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TokenNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenNodePublic",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_type",
                            &self.token_type,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_expiration",
                            &self.token_expiration,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TokenNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "TokenNodePublic",
                        "token_type",
                        &self.token_type,
                        "token_expiration",
                        &&self.token_expiration,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TokenNodePublic {
                #[inline]
                fn clone(&self) -> TokenNodePublic {
                    TokenNodePublic {
                        token_type: ::core::clone::Clone::clone(&self.token_type),
                        token_expiration: ::core::clone::Clone::clone(
                            &self.token_expiration,
                        ),
                    }
                }
            }
            pub struct TokenNodePrivate {
                pub token: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TokenNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "token" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"token" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TokenNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TokenNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TokenNodePrivate with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TokenNodePrivate {
                                    token: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("token")?
                                    }
                                };
                                _serde::__private::Ok(TokenNodePrivate {
                                    token: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["token"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TokenNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TokenNodePrivate>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TokenNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenNodePrivate",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token",
                            &self.token,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TokenNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "TokenNodePrivate",
                        "token",
                        &&self.token,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TokenNodePrivate {
                #[inline]
                fn clone(&self) -> TokenNodePrivate {
                    TokenNodePrivate {
                        token: ::core::clone::Clone::clone(&self.token),
                    }
                }
            }
            pub struct TokenNodePublicRaw {
                pub token_type: String,
                pub token_expiration: Option<NaiveDateTime>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TokenNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "token_type" => _serde::__private::Ok(__Field::__field0),
                                    "token_expiration" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"token_type" => _serde::__private::Ok(__Field::__field0),
                                    b"token_expiration" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TokenNodePublicRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TokenNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TokenNodePublicRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<NaiveDateTime>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TokenNodePublicRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TokenNodePublicRaw {
                                    token_type: __field0,
                                    token_expiration: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<NaiveDateTime>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "token_type",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "token_expiration",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<NaiveDateTime>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("token_type")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("token_expiration")?
                                    }
                                };
                                _serde::__private::Ok(TokenNodePublicRaw {
                                    token_type: __field0,
                                    token_expiration: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "token_type",
                            "token_expiration",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TokenNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TokenNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TokenNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenNodePublicRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_type",
                            &self.token_type,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token_expiration",
                            &self.token_expiration,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TokenNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "TokenNodePublicRaw",
                        "token_type",
                        &self.token_type,
                        "token_expiration",
                        &&self.token_expiration,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TokenNodePublicRaw {
                #[inline]
                fn clone(&self) -> TokenNodePublicRaw {
                    TokenNodePublicRaw {
                        token_type: ::core::clone::Clone::clone(&self.token_type),
                        token_expiration: ::core::clone::Clone::clone(
                            &self.token_expiration,
                        ),
                    }
                }
            }
            pub struct TokenNodePrivateRaw {
                pub token: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TokenNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "token" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"token" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TokenNodePrivateRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TokenNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TokenNodePrivateRaw with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TokenNodePrivateRaw {
                                    token: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("token"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("token")?
                                    }
                                };
                                _serde::__private::Ok(TokenNodePrivateRaw {
                                    token: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["token"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TokenNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TokenNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TokenNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenNodePrivateRaw",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "token",
                            &self.token,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TokenNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "TokenNodePrivateRaw",
                        "token",
                        &&self.token,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TokenNodePrivateRaw {
                #[inline]
                fn clone(&self) -> TokenNodePrivateRaw {
                    TokenNodePrivateRaw {
                        token: ::core::clone::Clone::clone(&self.token),
                    }
                }
            }
            pub struct TokenNode {
                pub node_id: i64,
                pub public: TokenNodePublic,
                pub private: TokenNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TokenNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TokenNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TokenNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TokenNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    TokenNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TokenNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    TokenNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct TokenNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TokenNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    TokenNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    TokenNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TokenNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TokenNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(TokenNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TokenNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TokenNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TokenNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TokenNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "TokenNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TokenNode {
                #[inline]
                fn clone(&self) -> TokenNode {
                    TokenNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl Node<ActiveModel, Model, Entity> for TokenNode {
                fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::NodeId
                }
            }
            #[node_raw(node_type = "token")]
            pub struct TokenNodeRaw {
                pub iden: String,
                pub service: String,
                pub public: TokenNodePublicRaw,
                pub private: TokenNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TokenNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "iden" => _serde::__private::Ok(__Field::__field0),
                                    "service" => _serde::__private::Ok(__Field::__field1),
                                    "public" => _serde::__private::Ok(__Field::__field2),
                                    "private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"iden" => _serde::__private::Ok(__Field::__field0),
                                    b"service" => _serde::__private::Ok(__Field::__field1),
                                    b"public" => _serde::__private::Ok(__Field::__field2),
                                    b"private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TokenNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TokenNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TokenNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TokenNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    TokenNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct TokenNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    TokenNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct TokenNodeRaw with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TokenNodeRaw {
                                    iden: __field0,
                                    service: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    TokenNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    TokenNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "service",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TokenNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TokenNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("service")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(TokenNodeRaw {
                                    iden: __field0,
                                    service: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "iden",
                            "service",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TokenNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TokenNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TokenNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenNodeRaw",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "service",
                            &self.service,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TokenNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "TokenNodeRaw",
                        "iden",
                        &self.iden,
                        "service",
                        &self.service,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TokenNodeRaw {
                #[inline]
                fn clone(&self) -> TokenNodeRaw {
                    TokenNodeRaw {
                        iden: ::core::clone::Clone::clone(&self.iden),
                        service: ::core::clone::Clone::clone(&self.service),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl NodeRaw<TokenNode, Model, ActiveModel> for TokenNodeRaw {
                fn get_node_type(&self) -> &str {
                    "token"
                }
                fn get_node_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::NodeId
                }
            }
            impl From<TokenNodeRaw> for ActiveModel {
                fn from(value: TokenNodeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    Self {
                        node_id: NotSet,
                        token: Set(value.private.token),
                        token_type: Set(value.public.token_type),
                        token_expiration: match value.public.token_expiration {
                            Some(exp) => Set(exp),
                            None => NotSet,
                        },
                        service: Set(value.service),
                        token_iden: Set(value.iden),
                    }
                }
            }
            impl From<Model> for TokenNode {
                fn from(model: Model) -> Self {
                    Self {
                        node_id: model.node_id,
                        public: TokenNodePublic {
                            token_type: model.token_type,
                            token_expiration: model.token_expiration,
                        },
                        private: TokenNodePrivate {
                            token: model.token,
                        },
                    }
                }
            }
            use crate::db;
            use crate::graph::node::Node;
            use crate::graph::node::NodeRaw;
            use chrono::NaiveDateTime;
            use db::entity::node::token::{ActiveModel, Column, Entity, Model};
            use macro_node_iden::{Node, NodeRaw};
            use sea_orm::EntityTrait;
            use serde::{Deserialize, Serialize};
        }
        pub mod user {
            pub struct UserNodePublic {
                pub name: String,
                pub email: String,
                pub iden: String,
                pub creation_time: NaiveDateTime,
                pub creation_order: i64,
                pub last_login_time: NaiveDateTime,
                pub avatar: String,
                pub description: String,
                pub bio: String,
                pub profile_show: Vec<String>,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UserNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "email" => _serde::__private::Ok(__Field::__field1),
                                    "iden" => _serde::__private::Ok(__Field::__field2),
                                    "creation_time" => _serde::__private::Ok(__Field::__field3),
                                    "creation_order" => _serde::__private::Ok(__Field::__field4),
                                    "last_login_time" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    "avatar" => _serde::__private::Ok(__Field::__field6),
                                    "description" => _serde::__private::Ok(__Field::__field7),
                                    "bio" => _serde::__private::Ok(__Field::__field8),
                                    "profile_show" => _serde::__private::Ok(__Field::__field9),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"email" => _serde::__private::Ok(__Field::__field1),
                                    b"iden" => _serde::__private::Ok(__Field::__field2),
                                    b"creation_time" => _serde::__private::Ok(__Field::__field3),
                                    b"creation_order" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"last_login_time" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    b"avatar" => _serde::__private::Ok(__Field::__field6),
                                    b"description" => _serde::__private::Ok(__Field::__field7),
                                    b"bio" => _serde::__private::Ok(__Field::__field8),
                                    b"profile_show" => _serde::__private::Ok(__Field::__field9),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UserNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UserNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UserNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                6usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                7usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field8 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                8usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field9 = match _serde::de::SeqAccess::next_element::<
                                    Vec<String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                9usize,
                                                &"struct UserNodePublic with 10 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UserNodePublic {
                                    name: __field0,
                                    email: __field1,
                                    iden: __field2,
                                    creation_time: __field3,
                                    creation_order: __field4,
                                    last_login_time: __field5,
                                    avatar: __field6,
                                    description: __field7,
                                    bio: __field8,
                                    profile_show: __field9,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field8: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field9: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("email"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_time",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_order",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "last_login_time",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field6 => {
                                            if _serde::__private::Option::is_some(&__field6) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("avatar"),
                                                );
                                            }
                                            __field6 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field7 => {
                                            if _serde::__private::Option::is_some(&__field7) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "description",
                                                    ),
                                                );
                                            }
                                            __field7 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field8 => {
                                            if _serde::__private::Option::is_some(&__field8) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("bio"),
                                                );
                                            }
                                            __field8 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field9 => {
                                            if _serde::__private::Option::is_some(&__field9) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "profile_show",
                                                    ),
                                                );
                                            }
                                            __field9 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("email")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_time")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_order")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("last_login_time")?
                                    }
                                };
                                let __field6 = match __field6 {
                                    _serde::__private::Some(__field6) => __field6,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("avatar")?
                                    }
                                };
                                let __field7 = match __field7 {
                                    _serde::__private::Some(__field7) => __field7,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("description")?
                                    }
                                };
                                let __field8 = match __field8 {
                                    _serde::__private::Some(__field8) => __field8,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("bio")?
                                    }
                                };
                                let __field9 = match __field9 {
                                    _serde::__private::Some(__field9) => __field9,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("profile_show")?
                                    }
                                };
                                _serde::__private::Ok(UserNodePublic {
                                    name: __field0,
                                    email: __field1,
                                    iden: __field2,
                                    creation_time: __field3,
                                    creation_order: __field4,
                                    last_login_time: __field5,
                                    avatar: __field6,
                                    description: __field7,
                                    bio: __field8,
                                    profile_show: __field9,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "email",
                            "iden",
                            "creation_time",
                            "creation_order",
                            "last_login_time",
                            "avatar",
                            "description",
                            "bio",
                            "profile_show",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UserNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<UserNodePublic>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UserNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UserNodePublic",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "email",
                            &self.email,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_time",
                            &self.creation_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_order",
                            &self.creation_order,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "last_login_time",
                            &self.last_login_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "avatar",
                            &self.avatar,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "description",
                            &self.description,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "bio",
                            &self.bio,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "profile_show",
                            &self.profile_show,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for UserNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "name",
                        "email",
                        "iden",
                        "creation_time",
                        "creation_order",
                        "last_login_time",
                        "avatar",
                        "description",
                        "bio",
                        "profile_show",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.name,
                        &self.email,
                        &self.iden,
                        &self.creation_time,
                        &self.creation_order,
                        &self.last_login_time,
                        &self.avatar,
                        &self.description,
                        &self.bio,
                        &&self.profile_show,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "UserNodePublic",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserNodePublic {
                #[inline]
                fn clone(&self) -> UserNodePublic {
                    UserNodePublic {
                        name: ::core::clone::Clone::clone(&self.name),
                        email: ::core::clone::Clone::clone(&self.email),
                        iden: ::core::clone::Clone::clone(&self.iden),
                        creation_time: ::core::clone::Clone::clone(&self.creation_time),
                        creation_order: ::core::clone::Clone::clone(
                            &self.creation_order,
                        ),
                        last_login_time: ::core::clone::Clone::clone(
                            &self.last_login_time,
                        ),
                        avatar: ::core::clone::Clone::clone(&self.avatar),
                        description: ::core::clone::Clone::clone(&self.description),
                        bio: ::core::clone::Clone::clone(&self.bio),
                        profile_show: ::core::clone::Clone::clone(&self.profile_show),
                    }
                }
            }
            pub struct UserNodePrivate {
                pub password: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UserNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "password" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"password" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UserNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UserNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UserNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UserNodePrivate with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UserNodePrivate {
                                    password: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "password",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("password")?
                                    }
                                };
                                _serde::__private::Ok(UserNodePrivate {
                                    password: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["password"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UserNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<UserNodePrivate>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UserNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UserNodePrivate",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "password",
                            &self.password,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for UserNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UserNodePrivate",
                        "password",
                        &&self.password,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserNodePrivate {
                #[inline]
                fn clone(&self) -> UserNodePrivate {
                    UserNodePrivate {
                        password: ::core::clone::Clone::clone(&self.password),
                    }
                }
            }
            pub struct UserNodePublicRaw {
                pub name: String,
                pub email: String,
                pub iden: String,
                pub creation_time: NaiveDateTime,
                pub last_login_time: NaiveDateTime,
                pub avatar: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UserNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "email" => _serde::__private::Ok(__Field::__field1),
                                    "iden" => _serde::__private::Ok(__Field::__field2),
                                    "creation_time" => _serde::__private::Ok(__Field::__field3),
                                    "last_login_time" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "avatar" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"email" => _serde::__private::Ok(__Field::__field1),
                                    b"iden" => _serde::__private::Ok(__Field::__field2),
                                    b"creation_time" => _serde::__private::Ok(__Field::__field3),
                                    b"last_login_time" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"avatar" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UserNodePublicRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UserNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UserNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UserNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UserNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UserNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct UserNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct UserNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct UserNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UserNodePublicRaw {
                                    name: __field0,
                                    email: __field1,
                                    iden: __field2,
                                    creation_time: __field3,
                                    last_login_time: __field4,
                                    avatar: __field5,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("email"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "creation_time",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "last_login_time",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("avatar"),
                                                );
                                            }
                                            __field5 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("email")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("creation_time")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("last_login_time")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("avatar")?
                                    }
                                };
                                _serde::__private::Ok(UserNodePublicRaw {
                                    name: __field0,
                                    email: __field1,
                                    iden: __field2,
                                    creation_time: __field3,
                                    last_login_time: __field4,
                                    avatar: __field5,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "email",
                            "iden",
                            "creation_time",
                            "last_login_time",
                            "avatar",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UserNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<UserNodePublicRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UserNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UserNodePublicRaw",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "email",
                            &self.email,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "creation_time",
                            &self.creation_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "last_login_time",
                            &self.last_login_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "avatar",
                            &self.avatar,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for UserNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "name",
                        "email",
                        "iden",
                        "creation_time",
                        "last_login_time",
                        "avatar",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.name,
                        &self.email,
                        &self.iden,
                        &self.creation_time,
                        &self.last_login_time,
                        &&self.avatar,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "UserNodePublicRaw",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserNodePublicRaw {
                #[inline]
                fn clone(&self) -> UserNodePublicRaw {
                    UserNodePublicRaw {
                        name: ::core::clone::Clone::clone(&self.name),
                        email: ::core::clone::Clone::clone(&self.email),
                        iden: ::core::clone::Clone::clone(&self.iden),
                        creation_time: ::core::clone::Clone::clone(&self.creation_time),
                        last_login_time: ::core::clone::Clone::clone(
                            &self.last_login_time,
                        ),
                        avatar: ::core::clone::Clone::clone(&self.avatar),
                    }
                }
            }
            pub struct UserNodePrivateRaw {
                pub password: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UserNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "password" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"password" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UserNodePrivateRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UserNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UserNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UserNodePrivateRaw with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UserNodePrivateRaw {
                                    password: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "password",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("password")?
                                    }
                                };
                                _serde::__private::Ok(UserNodePrivateRaw {
                                    password: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["password"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UserNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UserNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UserNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UserNodePrivateRaw",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "password",
                            &self.password,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for UserNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "UserNodePrivateRaw",
                        "password",
                        &&self.password,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserNodePrivateRaw {
                #[inline]
                fn clone(&self) -> UserNodePrivateRaw {
                    UserNodePrivateRaw {
                        password: ::core::clone::Clone::clone(&self.password),
                    }
                }
            }
            pub struct UserNode {
                pub node_id: i64,
                pub node_iden: String,
                pub public: UserNodePublic,
                pub private: UserNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UserNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "node_iden" => _serde::__private::Ok(__Field::__field1),
                                    "public" => _serde::__private::Ok(__Field::__field2),
                                    "private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"node_iden" => _serde::__private::Ok(__Field::__field1),
                                    b"public" => _serde::__private::Ok(__Field::__field2),
                                    b"private" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UserNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UserNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UserNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UserNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UserNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    UserNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UserNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    UserNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct UserNode with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UserNode {
                                    node_id: __field0,
                                    node_iden: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    UserNodePublic,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    UserNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_iden",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    UserNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    UserNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_iden")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(UserNode {
                                    node_id: __field0,
                                    node_iden: __field1,
                                    public: __field2,
                                    private: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "node_iden",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UserNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<UserNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UserNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UserNode",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_iden",
                            &self.node_iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for UserNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "UserNode",
                        "node_id",
                        &self.node_id,
                        "node_iden",
                        &self.node_iden,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserNode {
                #[inline]
                fn clone(&self) -> UserNode {
                    UserNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        node_iden: ::core::clone::Clone::clone(&self.node_iden),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl Node<ActiveModel, Model, Entity> for UserNode {
                fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::NodeId
                }
            }
            #[node_raw(node_type = "user")]
            pub struct UserNodeRaw {
                pub public: UserNodePublicRaw,
                pub private: UserNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UserNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "public" => _serde::__private::Ok(__Field::__field0),
                                    "private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"public" => _serde::__private::Ok(__Field::__field0),
                                    b"private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UserNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UserNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UserNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    UserNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UserNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    UserNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UserNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UserNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    UserNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    UserNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    UserNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    UserNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(UserNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["public", "private"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UserNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<UserNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UserNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UserNodeRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for UserNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "UserNodeRaw",
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserNodeRaw {
                #[inline]
                fn clone(&self) -> UserNodeRaw {
                    UserNodeRaw {
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl NodeRaw<UserNode, Model, ActiveModel> for UserNodeRaw {
                fn get_node_type(&self) -> &str {
                    "user"
                }
                fn get_node_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::NodeId
                }
            }
            impl From<UserNodeRaw> for ActiveModel {
                fn from(value: UserNodeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    Self {
                        node_id: NotSet,
                        user_name: Set(value.public.name),
                        user_email: Set(value.public.email),
                        user_password: Set(value.private.password),
                        user_avatar: Set(value.public.avatar),
                        user_creation_time: Set(chrono::Utc::now().naive_utc()),
                        user_creation_order: NotSet,
                        user_last_login_time: Set(value.public.last_login_time),
                        user_description: NotSet,
                        user_iden: Set(value.public.iden),
                        user_bio: NotSet,
                        user_profile_show: NotSet,
                    }
                }
            }
            impl From<Model> for UserNode {
                fn from(model: Model) -> Self {
                    UserNode {
                        node_id: model.node_id,
                        node_iden: model.user_iden.clone(),
                        public: UserNodePublic {
                            name: model.user_name,
                            iden: model.user_iden,
                            email: model.user_email,
                            creation_time: model
                                .user_creation_time
                                .and_utc()
                                .naive_utc(),
                            creation_order: model.user_creation_order,
                            last_login_time: model
                                .user_last_login_time
                                .and_utc()
                                .naive_utc(),
                            avatar: model.user_avatar,
                            description: model.user_description.unwrap_or_default(),
                            bio: model.user_bio.unwrap_or_default(),
                            profile_show: model
                                .user_profile_show
                                .unwrap_or_default()
                                .split(",")
                                .map(|s| s.to_string())
                                .collect(),
                        },
                        private: UserNodePrivate {
                            password: model.user_password,
                        },
                    }
                }
            }
            use crate::db::entity::node::user::{ActiveModel, Column, Entity, Model};
            use crate::graph::node::{Node, NodeRaw};
            use chrono::NaiveDateTime;
            use macro_node_iden::{Node, NodeRaw};
            use sea_orm::EntityTrait;
            use serde::{Deserialize, Serialize};
        }
        pub mod training {
            pub struct TrainingNodePublic {
                pub name: String,
                pub iden: String,
                pub description: String,
                pub start_time: NaiveDateTime,
                pub end_time: NaiveDateTime,
                pub training_type: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TrainingNodePublic {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "iden" => _serde::__private::Ok(__Field::__field1),
                                    "description" => _serde::__private::Ok(__Field::__field2),
                                    "start_time" => _serde::__private::Ok(__Field::__field3),
                                    "end_time" => _serde::__private::Ok(__Field::__field4),
                                    "training_type" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"iden" => _serde::__private::Ok(__Field::__field1),
                                    b"description" => _serde::__private::Ok(__Field::__field2),
                                    b"start_time" => _serde::__private::Ok(__Field::__field3),
                                    b"end_time" => _serde::__private::Ok(__Field::__field4),
                                    b"training_type" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TrainingNodePublic>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TrainingNodePublic;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TrainingNodePublic",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TrainingNodePublic with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TrainingNodePublic with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct TrainingNodePublic with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct TrainingNodePublic with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct TrainingNodePublic with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct TrainingNodePublic with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePublic {
                                    name: __field0,
                                    iden: __field1,
                                    description: __field2,
                                    start_time: __field3,
                                    end_time: __field4,
                                    training_type: __field5,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "description",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "start_time",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "end_time",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "training_type",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("description")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("start_time")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("end_time")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("training_type")?
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePublic {
                                    name: __field0,
                                    iden: __field1,
                                    description: __field2,
                                    start_time: __field3,
                                    end_time: __field4,
                                    training_type: __field5,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "iden",
                            "description",
                            "start_time",
                            "end_time",
                            "training_type",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TrainingNodePublic",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TrainingNodePublic,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TrainingNodePublic {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TrainingNodePublic",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "description",
                            &self.description,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "start_time",
                            &self.start_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "end_time",
                            &self.end_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "training_type",
                            &self.training_type,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TrainingNodePublic {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "name",
                        "iden",
                        "description",
                        "start_time",
                        "end_time",
                        "training_type",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.name,
                        &self.iden,
                        &self.description,
                        &self.start_time,
                        &self.end_time,
                        &&self.training_type,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "TrainingNodePublic",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TrainingNodePublic {
                #[inline]
                fn clone(&self) -> TrainingNodePublic {
                    TrainingNodePublic {
                        name: ::core::clone::Clone::clone(&self.name),
                        iden: ::core::clone::Clone::clone(&self.iden),
                        description: ::core::clone::Clone::clone(&self.description),
                        start_time: ::core::clone::Clone::clone(&self.start_time),
                        end_time: ::core::clone::Clone::clone(&self.end_time),
                        training_type: ::core::clone::Clone::clone(&self.training_type),
                    }
                }
            }
            pub struct TrainingNodePrivate {
                pub description: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TrainingNodePrivate {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "description" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"description" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TrainingNodePrivate>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TrainingNodePrivate;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TrainingNodePrivate",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TrainingNodePrivate with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePrivate {
                                    description: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "description",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("description")?
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePrivate {
                                    description: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["description"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TrainingNodePrivate",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TrainingNodePrivate,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TrainingNodePrivate {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TrainingNodePrivate",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "description",
                            &self.description,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TrainingNodePrivate {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "TrainingNodePrivate",
                        "description",
                        &&self.description,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TrainingNodePrivate {
                #[inline]
                fn clone(&self) -> TrainingNodePrivate {
                    TrainingNodePrivate {
                        description: ::core::clone::Clone::clone(&self.description),
                    }
                }
            }
            pub struct TrainingNodePublicRaw {
                pub name: String,
                pub iden: String,
                pub description: String,
                pub start_time: NaiveDateTime,
                pub end_time: NaiveDateTime,
                pub training_type: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TrainingNodePublicRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "iden" => _serde::__private::Ok(__Field::__field1),
                                    "description" => _serde::__private::Ok(__Field::__field2),
                                    "start_time" => _serde::__private::Ok(__Field::__field3),
                                    "end_time" => _serde::__private::Ok(__Field::__field4),
                                    "training_type" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"iden" => _serde::__private::Ok(__Field::__field1),
                                    b"description" => _serde::__private::Ok(__Field::__field2),
                                    b"start_time" => _serde::__private::Ok(__Field::__field3),
                                    b"end_time" => _serde::__private::Ok(__Field::__field4),
                                    b"training_type" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                TrainingNodePublicRaw,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TrainingNodePublicRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TrainingNodePublicRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TrainingNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TrainingNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct TrainingNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct TrainingNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    NaiveDateTime,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct TrainingNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct TrainingNodePublicRaw with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePublicRaw {
                                    name: __field0,
                                    iden: __field1,
                                    description: __field2,
                                    start_time: __field3,
                                    end_time: __field4,
                                    training_type: __field5,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    NaiveDateTime,
                                > = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("iden"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "description",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "start_time",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "end_time",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NaiveDateTime,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "training_type",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("iden")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("description")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("start_time")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("end_time")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("training_type")?
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePublicRaw {
                                    name: __field0,
                                    iden: __field1,
                                    description: __field2,
                                    start_time: __field3,
                                    end_time: __field4,
                                    training_type: __field5,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "iden",
                            "description",
                            "start_time",
                            "end_time",
                            "training_type",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TrainingNodePublicRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TrainingNodePublicRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TrainingNodePublicRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TrainingNodePublicRaw",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "name",
                            &self.name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "iden",
                            &self.iden,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "description",
                            &self.description,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "start_time",
                            &self.start_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "end_time",
                            &self.end_time,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "training_type",
                            &self.training_type,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TrainingNodePublicRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "name",
                        "iden",
                        "description",
                        "start_time",
                        "end_time",
                        "training_type",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.name,
                        &self.iden,
                        &self.description,
                        &self.start_time,
                        &self.end_time,
                        &&self.training_type,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "TrainingNodePublicRaw",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TrainingNodePublicRaw {
                #[inline]
                fn clone(&self) -> TrainingNodePublicRaw {
                    TrainingNodePublicRaw {
                        name: ::core::clone::Clone::clone(&self.name),
                        iden: ::core::clone::Clone::clone(&self.iden),
                        description: ::core::clone::Clone::clone(&self.description),
                        start_time: ::core::clone::Clone::clone(&self.start_time),
                        end_time: ::core::clone::Clone::clone(&self.end_time),
                        training_type: ::core::clone::Clone::clone(&self.training_type),
                    }
                }
            }
            pub struct TrainingNodePrivateRaw {
                pub description: String,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TrainingNodePrivateRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "description" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"description" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                TrainingNodePrivateRaw,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TrainingNodePrivateRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TrainingNodePrivateRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TrainingNodePrivateRaw with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePrivateRaw {
                                    description: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "description",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("description")?
                                    }
                                };
                                _serde::__private::Ok(TrainingNodePrivateRaw {
                                    description: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["description"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TrainingNodePrivateRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TrainingNodePrivateRaw,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TrainingNodePrivateRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TrainingNodePrivateRaw",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "description",
                            &self.description,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TrainingNodePrivateRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "TrainingNodePrivateRaw",
                        "description",
                        &&self.description,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TrainingNodePrivateRaw {
                #[inline]
                fn clone(&self) -> TrainingNodePrivateRaw {
                    TrainingNodePrivateRaw {
                        description: ::core::clone::Clone::clone(&self.description),
                    }
                }
            }
            pub struct TrainingNode {
                pub node_id: i64,
                pub public: TrainingNodePublic,
                pub private: TrainingNodePrivate,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TrainingNode {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node_id" => _serde::__private::Ok(__Field::__field0),
                                    "public" => _serde::__private::Ok(__Field::__field1),
                                    "private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node_id" => _serde::__private::Ok(__Field::__field0),
                                    b"public" => _serde::__private::Ok(__Field::__field1),
                                    b"private" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TrainingNode>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TrainingNode;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TrainingNode",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    i64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TrainingNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    TrainingNodePublic,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TrainingNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    TrainingNodePrivate,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct TrainingNode with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TrainingNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    TrainingNodePublic,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    TrainingNodePrivate,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TrainingNodePublic,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TrainingNodePrivate,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(TrainingNode {
                                    node_id: __field0,
                                    public: __field1,
                                    private: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "node_id",
                            "public",
                            "private",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TrainingNode",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TrainingNode>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TrainingNode {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TrainingNode",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_id",
                            &self.node_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TrainingNode {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "TrainingNode",
                        "node_id",
                        &self.node_id,
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TrainingNode {
                #[inline]
                fn clone(&self) -> TrainingNode {
                    TrainingNode {
                        node_id: ::core::clone::Clone::clone(&self.node_id),
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl Node<ActiveModel, Model, Entity> for TrainingNode {
                fn get_node_id(&self) -> i64 {
                    self.node_id
                }
                fn get_node_id_column() -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as EntityTrait>::Column {
                    Column::NodeId
                }
            }
            #[node_raw(node_type = "training")]
            pub struct TrainingNodeRaw {
                pub public: TrainingNodePublicRaw,
                pub private: TrainingNodePrivateRaw,
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for TrainingNodeRaw {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "public" => _serde::__private::Ok(__Field::__field0),
                                    "private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"public" => _serde::__private::Ok(__Field::__field0),
                                    b"private" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<TrainingNodeRaw>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TrainingNodeRaw;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TrainingNodeRaw",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    TrainingNodePublicRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TrainingNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    TrainingNodePrivateRaw,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TrainingNodeRaw with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TrainingNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    TrainingNodePublicRaw,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    TrainingNodePrivateRaw,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("public"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TrainingNodePublicRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "private",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    TrainingNodePrivateRaw,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("public")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("private")?
                                    }
                                };
                                _serde::__private::Ok(TrainingNodeRaw {
                                    public: __field0,
                                    private: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["public", "private"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TrainingNodeRaw",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<TrainingNodeRaw>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for TrainingNodeRaw {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TrainingNodeRaw",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "public",
                            &self.public,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "private",
                            &self.private,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for TrainingNodeRaw {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "TrainingNodeRaw",
                        "public",
                        &self.public,
                        "private",
                        &&self.private,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for TrainingNodeRaw {
                #[inline]
                fn clone(&self) -> TrainingNodeRaw {
                    TrainingNodeRaw {
                        public: ::core::clone::Clone::clone(&self.public),
                        private: ::core::clone::Clone::clone(&self.private),
                    }
                }
            }
            impl NodeRaw<TrainingNode, Model, ActiveModel> for TrainingNodeRaw {
                fn get_node_type(&self) -> &str {
                    "training"
                }
                fn get_node_id_column(
                    &self,
                ) -> <<ActiveModel as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Column {
                    Column::NodeId
                }
            }
            impl From<Model> for TrainingNode {
                fn from(model: Model) -> Self {
                    TrainingNode {
                        node_id: model.node_id,
                        public: TrainingNodePublic {
                            name: model.name,
                            iden: model.iden,
                            description: model.description_public,
                            start_time: model.start_time,
                            end_time: model.end_time,
                            training_type: model.training_type,
                        },
                        private: TrainingNodePrivate {
                            description: model.description_private,
                        },
                    }
                }
            }
            impl From<TrainingNodeRaw> for ActiveModel {
                fn from(value: TrainingNodeRaw) -> Self {
                    use sea_orm::ActiveValue::{NotSet, Set};
                    Self {
                        node_id: NotSet,
                        name: Set(value.public.name),
                        iden: Set(value.public.iden),
                        description_public: Set("".to_string()),
                        description_private: Set("".to_string()),
                        start_time: NotSet,
                        end_time: NotSet,
                        training_type: Set(value.public.training_type),
                    }
                }
            }
            use crate::db::entity::node::training::{ActiveModel, Column, Entity, Model};
            use crate::graph::node::{Node, NodeRaw};
            use chrono::NaiveDateTime;
            use macro_node_iden::{Node, NodeRaw};
            use sea_orm::EntityTrait;
            use serde::{Deserialize, Serialize};
        }
        use crate::{
            Result, db::entity::node::{DbNodeActiveModel, DbNodeInfo, node::create_node},
            error::CoreError,
        };
        use sea_orm::sea_query::IntoCondition;
        use sea_orm::{
            ActiveModelBehavior, ActiveModelTrait, ColumnTrait, DatabaseConnection,
            EntityTrait, IntoActiveModel,
        };
        use std::fmt::Debug;
        use std::str::FromStr;
        pub enum NodeType {
            User,
            Token,
            Problem,
            Group,
            PermGroup,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NodeType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        NodeType::User => "User",
                        NodeType::Token => "Token",
                        NodeType::Problem => "Problem",
                        NodeType::Group => "Group",
                        NodeType::PermGroup => "PermGroup",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NodeType {
            #[inline]
            fn clone(&self) -> NodeType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for NodeType {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NodeType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NodeType {
            #[inline]
            fn eq(&self, other: &NodeType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for NodeType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl From<NodeType> for &str {
            fn from(node_type: NodeType) -> Self {
                match node_type {
                    NodeType::User => "user",
                    NodeType::Token => "token",
                    NodeType::Problem => "problem",
                    NodeType::Group => "group",
                    NodeType::PermGroup => "perm_group",
                }
            }
        }
        pub trait Node<DbNodeActive, DbModel, DbEntity>
        where
            DbNodeActive: DbNodeActiveModel<DbModel, Self> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbNodeInfo,
            DbModel: Into<Self>
                + From<
                    <<DbNodeActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            <DbNodeActive::Entity as EntityTrait>::Model: IntoActiveModel<DbNodeActive>,
            Self: Sized + Send + Sync + Clone,
            DbEntity: EntityTrait,
            <DbEntity as sea_orm::EntityTrait>::Model: Into<DbModel>,
        {
            fn get_node_id(&self) -> i64;
            fn get_node_id_column() -> <DbNodeActive::Entity as EntityTrait>::Column {
                <DbNodeActive::Entity as EntityTrait>::Column::from_str("node_id")
                    .ok()
                    .unwrap()
            }
            fn from_db(
                db: &DatabaseConnection,
                node_id: i64,
            ) -> impl std::future::Future<Output = Result<Self>>
            where
                Self: Sized,
            {
                async move {
                    use tap::Conv;
                    let node_id_column = Self::get_node_id_column();
                    use sea_orm::ColumnTrait;
                    use sea_orm::QueryFilter;
                    {
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Querying node with id {0}", node_id),
                                    lvl,
                                    &(
                                        "core::graph::node",
                                        "core::graph::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let model = DbEntity::find()
                        .filter(node_id_column.eq(node_id))
                        .one(db)
                        .await?
                        .ok_or_else(|| CoreError::NotFound(
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!("Node with id {0} not found", node_id),
                                )
                            }),
                        ))?;
                    Ok(model.conv::<DbModel>().into())
                }
            }
            fn from_db_filter<F: IntoCondition>(
                db: &DatabaseConnection,
                filter: F,
            ) -> impl std::future::Future<Output = Result<Vec<Self>>>
            where
                Self: Sized,
            {
                async move {
                    use sea_orm::QueryFilter;
                    use tap::Conv;
                    {
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Querying node with filter"),
                                    lvl,
                                    &(
                                        "core::graph::node",
                                        "core::graph::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let models = DbEntity::find().filter(filter).all(db).await?;
                    Ok(
                        models
                            .into_iter()
                            .map(|model| model.conv::<DbModel>().into())
                            .collect(),
                    )
                }
            }
            fn modify<T: Into<sea_orm::Value> + Debug>(
                &self,
                db: &DatabaseConnection,
                column: <DbNodeActive::Entity as EntityTrait>::Column,
                data: T,
            ) -> impl std::future::Future<Output = Result<Self>> {
                async move {
                    use tap::Conv;
                    let mut new_model = DbNodeActive::new();
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Modifying node {0}: setting {1} to {2:?}",
                                        self.get_node_id(),
                                        column.enum_type_name().unwrap_or("unknown"),
                                        data,
                                    ),
                                    lvl,
                                    &(
                                        "core::graph::node",
                                        "core::graph::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    new_model.set(column, data.into());
                    let data = new_model.update(db).await?.conv::<DbModel>();
                    Ok(data.into())
                }
            }
        }
        pub trait NodeRaw<Node, DbModel, DbNodeActive>
        where
            Self: Into<DbNodeActive> + Clone + Debug,
            DbModel: Into<Node>
                + From<
                    <<DbNodeActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            DbNodeActive: DbNodeActiveModel<DbModel, Node> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbNodeInfo,
            <DbNodeActive::Entity as EntityTrait>::Model: IntoActiveModel<DbNodeActive>,
        {
            fn get_node_type(&self) -> &str;
            fn get_node_id_column(
                &self,
            ) -> <DbNodeActive::Entity as EntityTrait>::Column;
            fn save(
                &self,
                db: &DatabaseConnection,
            ) -> impl std::future::Future<Output = Result<Node>> {
                async {
                    use tap::Conv;
                    let node_type = self.get_node_type();
                    let node_id = create_node(db, node_type).await?.node_id;
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "Saving NodeType({1}) with id {2} with data: {0:?}",
                                        *self,
                                        node_type,
                                        node_id,
                                    ),
                                    lvl,
                                    &(
                                        "core::graph::node",
                                        "core::graph::node",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let mut value = (*self).clone().conv::<DbNodeActive>();
                    value.set(self.get_node_id_column(), node_id.into());
                    Ok(value.save_into_db(db).await?.into())
                }
            }
        }
    }
}
pub mod model {
    pub mod perm {
        use crate::Result;
        use crate::db::entity::edge::{DbEdgeActiveModel, DbEdgeInfo};
        use crate::graph::action::has_path;
        use crate::graph::edge::{Edge, EdgeQuery, EdgeQueryPerm};
        use sea_orm::{
            ActiveModelBehavior, ActiveModelTrait, DatabaseConnection, EntityTrait,
            IntoActiveModel,
        };
        pub async fn check_perm<DbActive, DbModel, DbEntity, EdgeA, T, K: Into<i64>>(
            db: &DatabaseConnection,
            u: i64,
            v: i64,
            edge_type: T,
            perm: K,
        ) -> Result<i8>
        where
            DbActive: DbEdgeActiveModel<DbModel, EdgeA> + Sized + Send + Sync
                + ActiveModelTrait + ActiveModelBehavior + DbEdgeInfo,
            DbModel: Into<EdgeA>
                + From<
                    <<DbActive as sea_orm::ActiveModelTrait>::Entity as sea_orm::EntityTrait>::Model,
                >,
            <DbActive::Entity as EntityTrait>::Model: IntoActiveModel<DbActive>,
            <DbEntity as sea_orm::EntityTrait>::Model: Into<DbModel>,
            EdgeA: Edge<DbActive, DbModel, DbEntity>,
            DbEntity: EntityTrait,
            T: Sized + Send + Sync + Clone
                + EdgeQuery<DbActive, DbModel, DbEntity, EdgeA> + EdgeQueryPerm,
        {
            has_path(db, u, v, &edge_type, perm.into()).await
        }
    }
    pub mod problem {
        use crate::db::entity::edge::{problem_statement, problem_tag};
        use crate::db::entity::node::problem_statement::ContentType;
        use crate::error::CoreError;
        use crate::graph::action::get_node_type;
        use crate::graph::edge::iden::{IdenEdgeQuery, IdenEdgeRaw};
        use crate::graph::edge::problem_limit::{
            ProblemLimitEdgeQuery, ProblemLimitEdgeRaw,
        };
        use crate::graph::edge::problem_statement::{
            ProblemStatementEdgeQuery, ProblemStatementEdgeRaw,
        };
        use crate::graph::edge::problem_tag::ProblemTagEdgeRaw;
        use crate::graph::edge::{EdgeQuery, EdgeRaw};
        use crate::graph::node::iden::{
            IdenNode, IdenNodePrivateRaw, IdenNodePublicRaw, IdenNodeRaw,
        };
        use crate::graph::node::problem::limit::{
            ProblemLimitNode, ProblemLimitNodePrivateRaw, ProblemLimitNodePublicRaw,
            ProblemLimitNodeRaw,
        };
        use crate::graph::node::problem::statement::{
            ProblemStatementNode, ProblemStatementNodePrivateRaw,
            ProblemStatementNodePublicRaw, ProblemStatementNodeRaw,
        };
        use crate::graph::node::problem::tag::{
            ProblemTagNode, ProblemTagNodePrivateRaw, ProblemTagNodePublicRaw,
            ProblemTagNodeRaw,
        };
        use crate::graph::node::problem::{
            ProblemNode, ProblemNodePrivateRaw, ProblemNodePublicRaw, ProblemNodeRaw,
        };
        use crate::graph::node::problem_source::{
            ProblemSourceNode, ProblemSourceNodePrivateRaw, ProblemSourceNodePublicRaw,
            ProblemSourceNodeRaw,
        };
        use crate::graph::node::{Node, NodeRaw};
        use crate::{Result, db};
        use async_recursion::async_recursion;
        use chrono::Utc;
        use redis::Commands;
        use sea_orm::{ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter};
        use serde::{Deserialize, Serialize};
        type ProblemSourceString = String;
        type ProblemIdenString = String;
        pub async fn create_problem_schema(
            db: &DatabaseConnection,
            problem_statement: Vec<
                (
                    ProblemStatementNodeRaw,
                    ProblemLimitNodeRaw,
                    (Option<ProblemSourceString>, Option<ProblemIdenString>),
                ),
            >,
            tag_node_id: Vec<i64>,
            problem_name: String,
        ) -> Result<ProblemNode> {
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Start to create problem schema"),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let problem_node = ProblemNodeRaw {
                public: ProblemNodePublicRaw {
                    name: problem_name,
                    creation_time: chrono::Utc::now().naive_utc(),
                },
                private: ProblemNodePrivateRaw {},
            }
                .save(db)
                .await?;
            let problem_node_id = problem_node.node_id;
            for data in problem_statement {
                add_problem_statement_for_problem(db, problem_node_id, data).await?;
            }
            for tag_node in tag_node_id {
                ProblemTagEdgeRaw {
                    u: problem_node.node_id,
                    v: tag_node,
                }
                    .save(db)
                    .await?;
            }
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Problem schema have been created. problem_node_id: {0}",
                                problem_node.node_id,
                            ),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            Ok(problem_node)
        }
        pub async fn add_problem_statement_for_problem(
            db: &DatabaseConnection,
            problem_node_id: i64,
            problem_statement: (
                ProblemStatementNodeRaw,
                ProblemLimitNodeRaw,
                (Option<ProblemSourceString>, Option<ProblemIdenString>),
            ),
        ) -> Result<()> {
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Creating problem statement node and limit node",
                            ),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let (problem_statement_node_raw, problem_limit_node_raw, (source, iden)) = problem_statement;
            let problem_statement_node = problem_statement_node_raw.save(db).await?;
            let problem_limit_node = problem_limit_node_raw.save(db).await?;
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Creating problem statement edge"),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            ProblemStatementEdgeRaw {
                u: problem_node_id,
                v: problem_statement_node.node_id,
                copyright_risk: 0,
            }
                .save(db)
                .await?;
            if let Some(source) = source && let Some(iden) = iden {
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("create problem_statement iden connection"),
                                lvl,
                                &(
                                    "core::model::problem",
                                    "core::model::problem",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let problem_iden_node = create_problem_iden(
                        db,
                        source.as_str(),
                        iden.as_str(),
                        problem_statement_node.node_id,
                    )
                    .await?;
                {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Iden Node have been created. {0:?}",
                                    problem_iden_node,
                                ),
                                lvl,
                                &(
                                    "core::model::problem",
                                    "core::model::problem",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Add problem limit edge"),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            ProblemLimitEdgeRaw {
                u: problem_statement_node.node_id,
                v: problem_limit_node.node_id,
            }
                .save(db)
                .await?;
            Ok(())
        }
        pub async fn delete_problem_statement_for_problem(
            db: &DatabaseConnection,
            problem_node_id: i64,
            problem_statement_node_id: i64,
        ) -> Result<()> {
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Deleting problem statement node and limit node",
                            ),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            ProblemStatementEdgeQuery::destroy_edge(
                    db,
                    problem_node_id,
                    problem_statement_node_id,
                )
                .await?;
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Problem statement edge have been deleted"),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            Ok(())
        }
        pub struct ProblemStatementProp {
            pub statement_source: String,
            pub problem_source: Option<String>,
            pub problem_iden: Option<String>,
            pub problem_statements: Vec<ContentType>,
            pub time_limit: i64,
            pub memory_limit: i64,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ProblemStatementProp {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "statement_source" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "problem_source" => _serde::__private::Ok(__Field::__field1),
                                "problem_iden" => _serde::__private::Ok(__Field::__field2),
                                "problem_statements" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "time_limit" => _serde::__private::Ok(__Field::__field4),
                                "memory_limit" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"statement_source" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"problem_source" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"problem_iden" => _serde::__private::Ok(__Field::__field2),
                                b"problem_statements" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"time_limit" => _serde::__private::Ok(__Field::__field4),
                                b"memory_limit" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ProblemStatementProp>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ProblemStatementProp;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ProblemStatementProp",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ProblemStatementProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ProblemStatementProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ProblemStatementProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Vec<ContentType>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ProblemStatementProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                i64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct ProblemStatementProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                i64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct ProblemStatementProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ProblemStatementProp {
                                statement_source: __field0,
                                problem_source: __field1,
                                problem_iden: __field2,
                                problem_statements: __field3,
                                time_limit: __field4,
                                memory_limit: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Vec<ContentType>,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<i64> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "statement_source",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_source",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_iden",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_statements",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<ContentType>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "time_limit",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "memory_limit",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("statement_source")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_source")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_iden")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_statements")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("time_limit")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("memory_limit")?
                                }
                            };
                            _serde::__private::Ok(ProblemStatementProp {
                                statement_source: __field0,
                                problem_source: __field1,
                                problem_iden: __field2,
                                problem_statements: __field3,
                                time_limit: __field4,
                                memory_limit: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "statement_source",
                        "problem_source",
                        "problem_iden",
                        "problem_statements",
                        "time_limit",
                        "memory_limit",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ProblemStatementProp",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ProblemStatementProp,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ProblemStatementProp {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ProblemStatementProp",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "statement_source",
                        &self.statement_source,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_source",
                        &self.problem_source,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_iden",
                        &self.problem_iden,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_statements",
                        &self.problem_statements,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "time_limit",
                        &self.time_limit,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "memory_limit",
                        &self.memory_limit,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ProblemStatementProp {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "statement_source",
                    "problem_source",
                    "problem_iden",
                    "problem_statements",
                    "time_limit",
                    "memory_limit",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.statement_source,
                    &self.problem_source,
                    &self.problem_iden,
                    &self.problem_statements,
                    &self.time_limit,
                    &&self.memory_limit,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ProblemStatementProp",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ProblemStatementProp {
            #[inline]
            fn clone(&self) -> ProblemStatementProp {
                ProblemStatementProp {
                    statement_source: ::core::clone::Clone::clone(
                        &self.statement_source,
                    ),
                    problem_source: ::core::clone::Clone::clone(&self.problem_source),
                    problem_iden: ::core::clone::Clone::clone(&self.problem_iden),
                    problem_statements: ::core::clone::Clone::clone(
                        &self.problem_statements,
                    ),
                    time_limit: ::core::clone::Clone::clone(&self.time_limit),
                    memory_limit: ::core::clone::Clone::clone(&self.memory_limit),
                }
            }
        }
        pub struct CreateProblemProps {
            pub problem_source: String,
            pub problem_iden: String,
            pub problem_name: String,
            pub problem_statement: Vec<ProblemStatementProp>,
            pub creation_time: Option<chrono::NaiveDateTime>,
            pub tags: Vec<String>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CreateProblemProps {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "problem_source" => _serde::__private::Ok(__Field::__field0),
                                "problem_iden" => _serde::__private::Ok(__Field::__field1),
                                "problem_name" => _serde::__private::Ok(__Field::__field2),
                                "problem_statement" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "creation_time" => _serde::__private::Ok(__Field::__field4),
                                "tags" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"problem_source" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"problem_iden" => _serde::__private::Ok(__Field::__field1),
                                b"problem_name" => _serde::__private::Ok(__Field::__field2),
                                b"problem_statement" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"creation_time" => _serde::__private::Ok(__Field::__field4),
                                b"tags" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<CreateProblemProps>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CreateProblemProps;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct CreateProblemProps",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct CreateProblemProps with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct CreateProblemProps with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct CreateProblemProps with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Vec<ProblemStatementProp>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct CreateProblemProps with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Option<chrono::NaiveDateTime>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct CreateProblemProps with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct CreateProblemProps with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(CreateProblemProps {
                                problem_source: __field0,
                                problem_iden: __field1,
                                problem_name: __field2,
                                problem_statement: __field3,
                                creation_time: __field4,
                                tags: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Vec<ProblemStatementProp>,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Option<chrono::NaiveDateTime>,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_source",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_iden",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_name",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_statement",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<ProblemStatementProp>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "creation_time",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<chrono::NaiveDateTime>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_source")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_iden")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_name")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_statement")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("creation_time")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tags")?
                                }
                            };
                            _serde::__private::Ok(CreateProblemProps {
                                problem_source: __field0,
                                problem_iden: __field1,
                                problem_name: __field2,
                                problem_statement: __field3,
                                creation_time: __field4,
                                tags: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "problem_source",
                        "problem_iden",
                        "problem_name",
                        "problem_statement",
                        "creation_time",
                        "tags",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CreateProblemProps",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<CreateProblemProps>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CreateProblemProps {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "CreateProblemProps",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_source",
                        &self.problem_source,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_iden",
                        &self.problem_iden,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_name",
                        &self.problem_name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_statement",
                        &self.problem_statement,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "creation_time",
                        &self.creation_time,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tags",
                        &self.tags,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for CreateProblemProps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "problem_source",
                    "problem_iden",
                    "problem_name",
                    "problem_statement",
                    "creation_time",
                    "tags",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.problem_source,
                    &self.problem_iden,
                    &self.problem_name,
                    &self.problem_statement,
                    &self.creation_time,
                    &&self.tags,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "CreateProblemProps",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CreateProblemProps {
            #[inline]
            fn clone(&self) -> CreateProblemProps {
                CreateProblemProps {
                    problem_source: ::core::clone::Clone::clone(&self.problem_source),
                    problem_iden: ::core::clone::Clone::clone(&self.problem_iden),
                    problem_name: ::core::clone::Clone::clone(&self.problem_name),
                    problem_statement: ::core::clone::Clone::clone(
                        &self.problem_statement,
                    ),
                    creation_time: ::core::clone::Clone::clone(&self.creation_time),
                    tags: ::core::clone::Clone::clone(&self.tags),
                }
            }
        }
        pub async fn create_problem(
            db: &DatabaseConnection,
            problem: CreateProblemProps,
        ) -> Result<ProblemNode> {
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Creating new problem, name:{0}.",
                                &problem.problem_name,
                            ),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let problem_node_raw = ProblemNodeRaw {
                public: ProblemNodePublicRaw {
                    name: problem.problem_name.clone(),
                    creation_time: problem
                        .creation_time
                        .unwrap_or(Utc::now().naive_utc()),
                },
                private: ProblemNodePrivateRaw {},
            };
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Problem Node Raw: {0:?}", problem_node_raw),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let mut problem_statement_node_raw = ::alloc::vec::Vec::new();
            for statement in problem.problem_statement {
                problem_statement_node_raw
                    .push((
                        ProblemStatementNodeRaw {
                            public: ProblemStatementNodePublicRaw {
                                statements: statement.problem_statements,
                                source: statement.statement_source,
                                creation_time: problem
                                    .creation_time
                                    .unwrap_or(Utc::now().naive_utc()),
                                iden: problem.problem_iden.clone(),
                            },
                            private: ProblemStatementNodePrivateRaw {},
                        }
                            .clone(),
                        ProblemLimitNodeRaw {
                            public: ProblemLimitNodePublicRaw {
                                time_limit: statement.time_limit,
                                memory_limit: statement.memory_limit,
                            },
                            private: ProblemLimitNodePrivateRaw {},
                        }
                            .clone(),
                        (statement.problem_source, statement.problem_iden),
                    ));
            }
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Problem Statements Raw: {0:?}",
                                problem_statement_node_raw,
                            ),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let mut tag_ids = ::alloc::vec::Vec::new();
            for i in problem.tags {
                use db::entity::node::problem_tag::Column as ProblemTagColumn;
                {
                    {
                        let lvl = ::log::Level::Trace;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Finding tag {0} in database", i),
                                lvl,
                                &(
                                    "core::model::problem",
                                    "core::model::problem",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let id = ProblemTagNode::from_db_filter(
                        db,
                        ProblemTagColumn::TagName.eq(&i),
                    )
                    .await?;
                tag_ids
                    .push(
                        if id.len() == 0 {
                            {
                                {
                                    let lvl = ::log::Level::Debug;
                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                        && lvl <= ::log::max_level()
                                    {
                                        ::log::__private_api::log(
                                            { ::log::__private_api::GlobalLogger },
                                            format_args!("Cannot find tag {0}, creating new.", i),
                                            lvl,
                                            &(
                                                "core::model::problem",
                                                "core::model::problem",
                                                ::log::__private_api::loc(),
                                            ),
                                            (),
                                        );
                                    }
                                }
                            };
                            ProblemTagNodeRaw {
                                public: ProblemTagNodePublicRaw {
                                    tag_name: i,
                                    tag_description: "".to_string(),
                                },
                                private: ProblemTagNodePrivateRaw {},
                            }
                                .save(db)
                                .await?
                                .node_id
                        } else {
                            id[0].node_id
                        },
                    );
            }
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "Final Problem Tags ids: {0:?}",
                                problem_statement_node_raw,
                            ),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Data collected"),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let result = create_problem_schema(
                    db,
                    problem_statement_node_raw,
                    tag_ids,
                    problem.problem_name.clone(),
                )
                .await?;
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Start to create problem_source for problem"),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            create_problem_iden(
                    db,
                    &problem.problem_source,
                    &problem.problem_iden,
                    result.node_id,
                )
                .await?;
            {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "The problem {0} have been created.",
                                &problem.problem_name,
                            ),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            Ok(result)
        }
        pub struct ProblemModel {
            pub problem_node: ProblemNode,
            pub problem_statement_node: Vec<(ProblemStatementNode, ProblemLimitNode)>,
            pub tag: Vec<ProblemTagNode>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ProblemModel {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "problem_node" => _serde::__private::Ok(__Field::__field0),
                                "problem_statement_node" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "tag" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"problem_node" => _serde::__private::Ok(__Field::__field0),
                                b"problem_statement_node" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"tag" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ProblemModel>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ProblemModel;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ProblemModel",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ProblemNode,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ProblemModel with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<(ProblemStatementNode, ProblemLimitNode)>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ProblemModel with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<ProblemTagNode>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ProblemModel with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ProblemModel {
                                problem_node: __field0,
                                problem_statement_node: __field1,
                                tag: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<ProblemNode> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Vec<(ProblemStatementNode, ProblemLimitNode)>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Vec<ProblemTagNode>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_node",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ProblemNode,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "problem_statement_node",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<(ProblemStatementNode, ProblemLimitNode)>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tag"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<ProblemTagNode>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("problem_node")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "problem_statement_node",
                                    )?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tag")?
                                }
                            };
                            _serde::__private::Ok(ProblemModel {
                                problem_node: __field0,
                                problem_statement_node: __field1,
                                tag: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "problem_node",
                        "problem_statement_node",
                        "tag",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ProblemModel",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ProblemModel>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ProblemModel {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ProblemModel",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_node",
                        &self.problem_node,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "problem_statement_node",
                        &self.problem_statement_node,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tag",
                        &self.tag,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ProblemModel {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ProblemModel",
                    "problem_node",
                    &self.problem_node,
                    "problem_statement_node",
                    &self.problem_statement_node,
                    "tag",
                    &&self.tag,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ProblemModel {
            #[inline]
            fn clone(&self) -> ProblemModel {
                ProblemModel {
                    problem_node: ::core::clone::Clone::clone(&self.problem_node),
                    problem_statement_node: ::core::clone::Clone::clone(
                        &self.problem_statement_node,
                    ),
                    tag: ::core::clone::Clone::clone(&self.tag),
                }
            }
        }
        pub async fn create_problem_source(
            db: &DatabaseConnection,
            name: &str,
            iden: &str,
        ) -> Result<ProblemSourceNode> {
            ProblemSourceNodeRaw {
                public: ProblemSourceNodePublicRaw {
                    name: name.to_string(),
                    iden: iden.to_string(),
                },
                private: ProblemSourceNodePrivateRaw {},
            }
                .save(db)
                .await
        }
        pub async fn create_problem_iden(
            db: &DatabaseConnection,
            problem_source: &str,
            iden: &str,
            problem_node_or_statement_id: i64,
        ) -> Result<IdenNode> {
            use db::entity::node::problem_source::Column as ProblemSourceColumn;
            let iden_node = IdenNodeRaw {
                public: IdenNodePublicRaw {
                    iden: iden.to_string(),
                },
                private: IdenNodePrivateRaw {},
            }
                .save(db)
                .await?;
            let problem_source_node = ProblemSourceNode::from_db_filter(
                    db,
                    ProblemSourceColumn::Iden.eq(problem_source),
                )
                .await?;
            IdenEdgeRaw {
                u: problem_source_node[0].node_id,
                v: iden_node.node_id,
                iden: iden.to_string(),
            }
                .save(db)
                .await?;
            IdenEdgeRaw {
                u: iden_node.node_id,
                v: problem_node_or_statement_id,
                iden: "DONE_FOUND_FROM_DATABASE".to_string(),
            }
                .save(db)
                .await?;
            Ok(iden_node)
        }
        #[must_use]
        pub fn get_end_iden<'life0, 'life1, 'async_recursion>(
            db: &'life0 DatabaseConnection,
            iden: &'life1 str,
            id: i64,
        ) -> ::core::pin::Pin<
            Box<dyn ::core::future::Future<Output = Result<i64>> + 'async_recursion>,
        >
        where
            'life0: 'async_recursion,
            'life1: 'async_recursion,
        {
            Box::pin(async move {
                use db::entity::edge::iden::Column as IdenColumn;
                if iden == "" {
                    {
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Found iden, node_id:{0}", id),
                                    lvl,
                                    &(
                                        "core::model::problem",
                                        "core::model::problem",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    return Ok(
                        IdenEdgeQuery::get_v_filter(
                                id,
                                IdenColumn::Iden.eq("DONE_FOUND_FROM_DATABASE"),
                                db,
                            )
                            .await?[0],
                    );
                }
                {
                    {
                        let lvl = ::log::Level::Trace;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Find end iden for id: {0}, iden: {1}",
                                    id,
                                    iden,
                                ),
                                lvl,
                                &(
                                    "core::model::problem",
                                    "core::model::problem",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let mut now_iden = "".to_string();
                for i in 0..iden.len() {
                    now_iden.push(iden.chars().nth(i).unwrap());
                    let result = IdenEdgeQuery::get_v_filter(
                            id,
                            IdenColumn::Iden.eq(now_iden.as_str()),
                            db,
                        )
                        .await?;
                    if !result.is_empty() {
                        let next_iden = iden[i + 1..].to_string();
                        let result = get_end_iden(db, &next_iden, result[0]).await?;
                        if result != 0 {
                            return Ok(result);
                        }
                    }
                }
                Ok(0)
            })
        }
        /**
Result<(ProblemModel, i64)>: (problem_id

*/
        pub async fn get_problem(
            db: &DatabaseConnection,
            redis: &mut redis::Connection,
            iden: &str,
        ) -> Result<(ProblemModel, i64)> {
            use db::entity::node::problem_source::Column as ProblemSourceColumn;
            let mut saved = false;
            let node_id = 'scope: {
                if let Ok(value) = redis
                    .get::<
                        _,
                        String,
                    >(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("pi_{0}", iden))
                        }),
                    )
                {
                    {
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("load from redis: pi_{0}", iden),
                                    lvl,
                                    &(
                                        "core::model::problem",
                                        "core::model::problem",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    if let Ok(problem_model) = value.as_str().parse::<i64>() {
                        saved = true;
                        break 'scope problem_model;
                    }
                }
                let mut now_iden = "".to_string();
                for i in 0..iden.len() {
                    now_iden.push(iden.chars().nth(i).unwrap());
                    let result = ProblemSourceNode::from_db_filter(
                            db,
                            ProblemSourceColumn::Iden.eq(now_iden.as_str()),
                        )
                        .await?;
                    if !result.is_empty() {
                        let problem_source_node = result[0].clone();
                        {
                            {
                                let lvl = ::log::Level::Trace;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!(
                                            "Problem source node id: {0}",
                                            problem_source_node.node_id,
                                        ),
                                        lvl,
                                        &(
                                            "core::model::problem",
                                            "core::model::problem",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        let next_iden = iden[i + 1..].to_string();
                        let result = get_end_iden(
                                db,
                                &next_iden,
                                problem_source_node.node_id,
                            )
                            .await?;
                        if result != 0 {
                            break 'scope result;
                        }
                    }
                }
                -1
            };
            {
                {
                    let lvl = ::log::Level::Trace;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!("Problem node id: {0}", node_id),
                            lvl,
                            &(
                                "core::model::problem",
                                "core::model::problem",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            if node_id == -1 {
                return Err(CoreError::NotFound("Problem not found".to_string()));
            }
            if !saved {
                redis
                    .set::<
                        _,
                        _,
                        (),
                    >(
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(format_args!("pi_{0}", iden))
                        }),
                        node_id.to_string(),
                    )?;
            }
            let node_type = get_node_type(db, node_id).await?;
            let problem_node = if node_type == "problem_statement" {
                ProblemStatementEdgeQuery::get_u_one(node_id, db).await?
            } else {
                node_id
            };
            Ok((view_problem(db, redis, problem_node).await?, node_id))
        }
        pub async fn view_problem(
            db: &DatabaseConnection,
            redis: &mut redis::Connection,
            problem_node_id: i64,
        ) -> Result<ProblemModel> {
            if let Ok(value) = redis
                .get::<
                    _,
                    String,
                >(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("p_{0}", problem_node_id))
                    }),
                )
            {
                if let Ok(problem_model) = serde_json::from_str::<
                    ProblemModel,
                >(value.as_str()) {
                    return Ok(problem_model);
                }
            }
            let problem_node = ProblemNode::from_db(db, problem_node_id).await?;
            let problem_statement_node_id: Vec<i64> = problem_statement::Entity::find()
                .filter(problem_statement::Column::UNodeId.eq(problem_node.node_id))
                .all(db)
                .await?
                .into_iter()
                .map(|edge| edge.v_node_id)
                .collect();
            let mut problem_statement_node = ::alloc::vec::Vec::new();
            for node_id in problem_statement_node_id {
                let statement_node = ProblemStatementNode::from_db(db, node_id).await?;
                let problem_limit_node = ProblemLimitEdgeQuery::get_v(
                        statement_node.node_id,
                        db,
                    )
                    .await?[0];
                let problem_limit_node = ProblemLimitNode::from_db(
                        db,
                        problem_limit_node,
                    )
                    .await?;
                problem_statement_node.push((statement_node, problem_limit_node));
            }
            let tag_nodes: Vec<i64> = problem_tag::Entity::find()
                .filter(problem_tag::Column::UNodeId.eq(problem_node.node_id))
                .all(db)
                .await?
                .into_iter()
                .map(|edge| edge.v_node_id)
                .collect();
            let mut tag = ::alloc::vec::Vec::new();
            for tag_node_id in tag_nodes {
                let tag_node = ProblemTagNode::from_db(db, tag_node_id).await?;
                tag.push(tag_node);
            }
            let problem_model = ProblemModel {
                problem_node,
                problem_statement_node,
                tag,
            };
            let serialized = serde_json::to_string(&problem_model)?;
            redis
                .set::<
                    _,
                    _,
                    (),
                >(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("p_{0}", problem_node_id))
                    }),
                    serialized,
                )?;
            redis
                .expire::<
                    _,
                    (),
                >(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("p_{0}", problem_node_id))
                    }),
                    3600,
                )?;
            Ok(problem_model)
        }
        pub async fn refresh_problem_node_cache(
            redis: &mut redis::Connection,
            node_id: i64,
        ) -> Result<()> {
            redis
                .del::<
                    _,
                    (),
                >(
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(format_args!("p_{0}", node_id))
                    }),
                )?;
            Ok(())
        }
        pub async fn modify_problem_statement(
            db: &DatabaseConnection,
            redis: &mut redis::Connection,
            node_id: i64,
            new_content: Vec<ContentType>,
        ) -> Result<ProblemStatementNode> {
            use db::entity::node::problem_statement::Column::Content;
            let result = ProblemStatementNode::from_db(db, node_id)
                .await?
                .modify(db, Content, new_content)
                .await?;
            let problem_node_id = ProblemStatementEdgeQuery::get_u_one(node_id, db)
                .await;
            if let Ok(problem_node_id) = problem_node_id {
                refresh_problem_node_cache(redis, problem_node_id).await?;
            }
            Ok(result)
        }
        pub async fn modify_problem_statement_source(
            db: &DatabaseConnection,
            redis: &mut redis::Connection,
            node_id: i64,
            new_source: String,
        ) -> Result<ProblemStatementNode> {
            use db::entity::node::problem_statement::Column::Source;
            let result = ProblemStatementNode::from_db(db, node_id)
                .await?
                .modify(db, Source, new_source)
                .await?;
            let problem_node_id = ProblemStatementEdgeQuery::get_u_one(node_id, db)
                .await;
            if let Ok(problem_node_id) = problem_node_id {
                refresh_problem_node_cache(redis, problem_node_id).await?;
            }
            Ok(result)
        }
    }
    mod record {
        use crate::Result;
        use crate::graph::node::NodeRaw;
        use crate::graph::node::record::{
            RecordNode, RecordNodePrivateRaw, RecordNodePublicRaw, RecordNodeRaw,
            RecordStatus,
        };
        use sea_orm::DatabaseConnection;
        use serde::{Deserialize, Serialize};
        pub struct RecordNewProp<'a> {
            pub platform: &'a str,
            pub code: &'a str,
            pub code_language: &'a str,
            pub url: &'a str,
            pub statement_node_id: i64,
            pub public_status: bool,
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for RecordNewProp<'a> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "platform",
                    "code",
                    "code_language",
                    "url",
                    "statement_node_id",
                    "public_status",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.platform,
                    &self.code,
                    &self.code_language,
                    &self.url,
                    &self.statement_node_id,
                    &&self.public_status,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "RecordNewProp",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for RecordNewProp<'a> {
            #[inline]
            fn clone(&self) -> RecordNewProp<'a> {
                RecordNewProp {
                    platform: ::core::clone::Clone::clone(&self.platform),
                    code: ::core::clone::Clone::clone(&self.code),
                    code_language: ::core::clone::Clone::clone(&self.code_language),
                    url: ::core::clone::Clone::clone(&self.url),
                    statement_node_id: ::core::clone::Clone::clone(
                        &self.statement_node_id,
                    ),
                    public_status: ::core::clone::Clone::clone(&self.public_status),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for RecordNewProp<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for RecordNewProp<'a> {
            #[inline]
            fn eq(&self, other: &RecordNewProp<'a>) -> bool {
                self.statement_node_id == other.statement_node_id
                    && self.public_status == other.public_status
                    && self.platform == other.platform && self.code == other.code
                    && self.code_language == other.code_language && self.url == other.url
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'a> _serde::Serialize for RecordNewProp<'a> {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "RecordNewProp",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "platform",
                        &self.platform,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "code",
                        &self.code,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "code_language",
                        &self.code_language,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "url",
                        &self.url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "statement_node_id",
                        &self.statement_node_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "public_status",
                        &self.public_status,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de: 'a, 'a> _serde::Deserialize<'de> for RecordNewProp<'a> {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "platform" => _serde::__private::Ok(__Field::__field0),
                                "code" => _serde::__private::Ok(__Field::__field1),
                                "code_language" => _serde::__private::Ok(__Field::__field2),
                                "url" => _serde::__private::Ok(__Field::__field3),
                                "statement_node_id" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "public_status" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"platform" => _serde::__private::Ok(__Field::__field0),
                                b"code" => _serde::__private::Ok(__Field::__field1),
                                b"code_language" => _serde::__private::Ok(__Field::__field2),
                                b"url" => _serde::__private::Ok(__Field::__field3),
                                b"statement_node_id" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"public_status" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de: 'a, 'a> {
                        marker: _serde::__private::PhantomData<RecordNewProp<'a>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                        type Value = RecordNewProp<'a>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct RecordNewProp",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                &'a str,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct RecordNewProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                &'a str,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct RecordNewProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                &'a str,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct RecordNewProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                &'a str,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct RecordNewProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                i64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct RecordNewProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct RecordNewProp with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(RecordNewProp {
                                platform: __field0,
                                code: __field1,
                                code_language: __field2,
                                url: __field3,
                                statement_node_id: __field4,
                                public_status: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<&'a str> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<&'a str> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<&'a str> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<&'a str> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "platform",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<&'a str>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("code"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<&'a str>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "code_language",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<&'a str>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<&'a str>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "statement_node_id",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "public_status",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("platform")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("code")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("code_language")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("url")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("statement_node_id")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("public_status")?
                                }
                            };
                            _serde::__private::Ok(RecordNewProp {
                                platform: __field0,
                                code: __field1,
                                code_language: __field2,
                                url: __field3,
                                statement_node_id: __field4,
                                public_status: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "platform",
                        "code",
                        "code_language",
                        "url",
                        "statement_node_id",
                        "public_status",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "RecordNewProp",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<RecordNewProp<'a>>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub async fn create_record<'a>(
            db: &DatabaseConnection,
            record: RecordNewProp<'a>,
            track_service_id: i64,
        ) -> Result<RecordNode> {
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "creating record schema with properties: {0:?}",
                                record,
                            ),
                            lvl,
                            &(
                                "core::model::record",
                                "core::model::record",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            let record_node = RecordNodeRaw {
                public: RecordNodePublicRaw {
                    record_message: None,
                    record_platform: record.platform.to_string(),
                    record_url: Some(record.url.to_string()),
                    record_time: chrono::Utc::now().naive_utc(),
                    public_status: record.public_status,
                    record_score: 0,
                    record_status: RecordStatus::Waiting,
                    statement_id: record.statement_node_id,
                },
                private: RecordNodePrivateRaw {
                    code: record.code.to_string(),
                    code_language: record.code_language.to_string(),
                },
            }
                .save(db)
                .await?;
            {
                {
                    let lvl = ::log::Level::Debug;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            { ::log::__private_api::GlobalLogger },
                            format_args!(
                                "add judge task for record:{0}, bind_track_service {1}",
                                record_node.node_id,
                                track_service_id,
                            ),
                            lvl,
                            &(
                                "core::model::record",
                                "core::model::record",
                                ::log::__private_api::loc(),
                            ),
                            (),
                        );
                    }
                }
            };
            Ok(record_node)
        }
    }
    pub mod user {
        use crate::graph::edge::perm_view::ViewPermRaw;
        use crate::{
            db::{
                self, entity::{self, node::user::{get_user_by_email, get_user_by_iden}},
            },
            env, error::{CoreError, QueryExists},
            graph::{
                edge::{
                    EdgeRaw, perm_manage::{ManagePermRaw, PermManageEdgeRaw},
                    perm_view::PermViewEdgeRaw,
                },
                node::{
                    Node, NodeRaw,
                    token::{
                        TokenNode, TokenNodePrivateRaw, TokenNodePublicRaw, TokenNodeRaw,
                    },
                    user::{UserNode, UserNodePrivateRaw, UserNodePublicRaw, UserNodeRaw},
                },
            },
            utils::encrypt::encode_password,
        };
        use sea_orm::DatabaseConnection;
        use tap::Conv;
        pub async fn create_default_user(
            db: &DatabaseConnection,
            iden: &str,
            name: &str,
            email: &str,
            avatar: &str,
            password: &str,
        ) -> Result<UserNode, CoreError> {
            if entity::node::user::check_iden_exists(db, iden).await? {
                return Err(CoreError::QueryExists(QueryExists::RegisterIDENExist));
            }
            if entity::node::user::check_email_exists(db, email).await? {
                return Err(CoreError::QueryExists(QueryExists::RegisterEmailExist));
            }
            let user = UserNodeRaw {
                public: UserNodePublicRaw {
                    name: name.to_string(),
                    email: email.to_string(),
                    iden: iden.to_string(),
                    creation_time: chrono::Utc::now().naive_utc(),
                    last_login_time: chrono::Utc::now().naive_utc(),
                    avatar: avatar.to_string(),
                },
                private: UserNodePrivateRaw {
                    password: encode_password(&password.to_string()),
                },
            };
            let result = user.save(db).await?;
            let default_node_id = env::DEFAULT_NODES
                .lock()
                .unwrap()
                .default_strategy_node;
            if default_node_id != -1 {
                PermViewEdgeRaw {
                    u: result.node_id,
                    v: default_node_id,
                    perms: ViewPermRaw::All,
                }
                    .save(db)
                    .await?;
            } else {
                {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "Default strategy node not set, user will not have default permissions.",
                                ),
                                lvl,
                                &(
                                    "core::model::user",
                                    "core::model::user",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
            }
            Ok(result)
        }
        pub async fn check_iden_exists(
            db: &DatabaseConnection,
            iden: &str,
        ) -> Result<bool, CoreError> {
            let exists = entity::node::user::check_iden_exists(db, iden).await?;
            Ok(exists)
        }
        pub async fn user_login(
            db: &DatabaseConnection,
            iden: &str,
            password: &str,
            token_iden: &str,
            long_token: bool,
        ) -> Result<(UserNode, TokenNode), CoreError> {
            use db::entity::node::token::gen_token;
            let user = get_user_by_iden(db, iden).await;
            let user = if let Ok(user) = user {
                user
            } else {
                get_user_by_email(db, iden).await?
            }
                .conv::<UserNode>();
            if user.private.password != encode_password(&password.to_string()) {
                (
                    match user.private.password {
                        tmp => {
                            {
                                ::std::io::_eprint(
                                    format_args!(
                                        "[{0}:{1}:{2}] {3} = {4:#?}\n",
                                        "packages/core/src/model/user.rs",
                                        94u32,
                                        9u32,
                                        "user.private.password",
                                        &&tmp as &dyn ::std::fmt::Debug,
                                    ),
                                );
                            };
                            tmp
                        }
                    },
                    match encode_password(&password.to_string()) {
                        tmp => {
                            {
                                ::std::io::_eprint(
                                    format_args!(
                                        "[{0}:{1}:{2}] {3} = {4:#?}\n",
                                        "packages/core/src/model/user.rs",
                                        94u32,
                                        9u32,
                                        "encode_password(&password.to_string())",
                                        &&tmp as &dyn ::std::fmt::Debug,
                                    ),
                                );
                            };
                            tmp
                        }
                    },
                );
                return Err(CoreError::UserNotFound);
            }
            let token_expiration = if long_token {
                Some((chrono::Utc::now() + chrono::Duration::days(30)).naive_utc())
            } else {
                None
            };
            let token = TokenNodeRaw {
                iden: token_iden.to_string(),
                service: "auth".to_string(),
                public: TokenNodePublicRaw {
                    token_expiration,
                    token_type: "auth".to_string(),
                },
                private: TokenNodePrivateRaw {
                    token: gen_token(),
                },
            }
                .save(db)
                .await?;
            PermViewEdgeRaw {
                u: token.node_id,
                v: user.node_id,
                perms: ViewPermRaw::All,
            }
                .save(db)
                .await?;
            PermManageEdgeRaw {
                u: token.node_id,
                v: user.node_id,
                perms: ManagePermRaw::All,
            }
                .save(db)
                .await?;
            Ok((user, token))
        }
        pub async fn change_user_config(
            db: &DatabaseConnection,
            node_id: i64,
            name: Option<String>,
            email: Option<String>,
            avater: Option<String>,
            description: Option<String>,
            bio: Option<String>,
        ) -> Result<UserNode, CoreError> {
            use db::entity::node::user::Column::{
                UserName, UserEmail, UserAvatar, UserDescription, UserBio,
            };
            let user = UserNode::from_db(db, node_id).await?;
            if let Some(name) = name {
                user.modify(db, UserName, name).await?;
            }
            if let Some(email) = email {
                user.modify(db, UserEmail, email).await?;
            }
            if let Some(avater) = avater {
                user.modify(db, UserAvatar, avater).await?;
            }
            if let Some(description) = description {
                user.modify(db, UserDescription, description).await?;
            }
            if let Some(bio) = bio {
                user.modify(db, UserBio, bio).await?;
            }
            Ok(user)
        }
        pub async fn change_user_password(
            db: &DatabaseConnection,
            node_id: i64,
            password: String,
        ) -> Result<UserNode, CoreError> {
            use db::entity::node::user::Column::UserPassword;
            let user = UserNode::from_db(db, node_id).await?;
            user.modify(db, UserPassword, encode_password(&password)).await?;
            Ok(user)
        }
    }
}
pub mod service {
    use sea_orm::DatabaseConnection;
    use crate::error::CoreError;
    pub mod judge {
        pub mod calc {
            use crate::Result;
            use crate::error::CoreError;
            use crate::graph::node::record::RecordStatus;
            use crate::graph::node::record::subtask::SubtaskCalcMethod;
            use deno_core::RuntimeOptions;
            use deno_core::v8;
            use deno_core::{JsRuntime, serde_v8};
            use serde::{Deserialize, Serialize};
            use serde_json::json;
            type TaskScore = f64;
            type TaskTime = i64;
            type TaskMemory = i64;
            type TaskDetail = (TaskScore, TaskTime, TaskMemory, RecordStatus);
            pub fn handle_score(
                method: SubtaskCalcMethod,
                calc_function: Option<String>,
                task_detail: Vec<TaskDetail>,
            ) -> Result<TaskDetail> {
                use crate::graph::node::record::RecordStatus::*;
                use SubtaskCalcMethod::*;
                match method {
                    Max => {
                        let (mut score, mut time, mut memory, mut status) = (
                            0f64,
                            0,
                            0,
                            Accepted,
                        );
                        for (s, t, m, r) in task_detail {
                            if s > score {
                                score = s;
                            }
                            if t > time {
                                time = t;
                            }
                            if m > memory {
                                memory = m;
                            }
                            if r != Accepted && status == Accepted {
                                status = r;
                            }
                        }
                        Ok((score, time, memory, status))
                    }
                    Min => {
                        let (mut score, mut time, mut memory, mut status) = (
                            -1f64,
                            -1,
                            -1,
                            Accepted,
                        );
                        for (s, t, m, r) in task_detail {
                            if s < score || score as i32 == -1 {
                                score = s;
                            }
                            if t < time || time == -1 {
                                time = t;
                            }
                            if m < memory || time == -1 {
                                memory = m;
                            }
                            if r != Accepted && status == Accepted {
                                status = r;
                            }
                        }
                        Ok((
                            if score as i32 == -1 { 0f64 } else { score as f64 },
                            if time == -1 { 0 } else { time },
                            if memory == -1 { 0 } else { memory },
                            if time == -1 { UnknownError } else { status },
                        ))
                    }
                    Sum => {
                        let (mut score, mut time, mut memory, mut status) = (
                            0f64,
                            0,
                            0,
                            Accepted,
                        );
                        for (s, t, m, r) in task_detail {
                            score += s;
                            time += t;
                            memory += m;
                            if r != Accepted && status == Accepted {
                                status = r;
                            }
                        }
                        Ok((score, time, memory, status))
                    }
                    Function => {
                        {
                            {
                                let lvl = ::log::Level::Trace;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Using custom function for score calculation"),
                                        lvl,
                                        &(
                                            "core::service::judge::calc",
                                            "core::service::judge::calc",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        struct TaskDetailObject {
                            score: TaskScore,
                            time: TaskTime,
                            memory: TaskMemory,
                            status: String,
                        }
                        #[doc(hidden)]
                        #[allow(
                            non_upper_case_globals,
                            unused_attributes,
                            unused_qualifications,
                            clippy::absolute_paths,
                        )]
                        const _: () = {
                            #[allow(unused_extern_crates, clippy::useless_attribute)]
                            extern crate serde as _serde;
                            #[automatically_derived]
                            impl _serde::Serialize for TaskDetailObject {
                                fn serialize<__S>(
                                    &self,
                                    __serializer: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    let mut __serde_state = _serde::Serializer::serialize_struct(
                                        __serializer,
                                        "TaskDetailObject",
                                        false as usize + 1 + 1 + 1 + 1,
                                    )?;
                                    _serde::ser::SerializeStruct::serialize_field(
                                        &mut __serde_state,
                                        "score",
                                        &self.score,
                                    )?;
                                    _serde::ser::SerializeStruct::serialize_field(
                                        &mut __serde_state,
                                        "time",
                                        &self.time,
                                    )?;
                                    _serde::ser::SerializeStruct::serialize_field(
                                        &mut __serde_state,
                                        "memory",
                                        &self.memory,
                                    )?;
                                    _serde::ser::SerializeStruct::serialize_field(
                                        &mut __serde_state,
                                        "status",
                                        &self.status,
                                    )?;
                                    _serde::ser::SerializeStruct::end(__serde_state)
                                }
                            }
                        };
                        #[doc(hidden)]
                        #[allow(
                            non_upper_case_globals,
                            unused_attributes,
                            unused_qualifications,
                            clippy::absolute_paths,
                        )]
                        const _: () = {
                            #[allow(unused_extern_crates, clippy::useless_attribute)]
                            extern crate serde as _serde;
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for TaskDetailObject {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __field1,
                                        __field2,
                                        __field3,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                1u64 => _serde::__private::Ok(__Field::__field1),
                                                2u64 => _serde::__private::Ok(__Field::__field2),
                                                3u64 => _serde::__private::Ok(__Field::__field3),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "score" => _serde::__private::Ok(__Field::__field0),
                                                "time" => _serde::__private::Ok(__Field::__field1),
                                                "memory" => _serde::__private::Ok(__Field::__field2),
                                                "status" => _serde::__private::Ok(__Field::__field3),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"score" => _serde::__private::Ok(__Field::__field0),
                                                b"time" => _serde::__private::Ok(__Field::__field1),
                                                b"memory" => _serde::__private::Ok(__Field::__field2),
                                                b"status" => _serde::__private::Ok(__Field::__field3),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<TaskDetailObject>,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = TaskDetailObject;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct TaskDetailObject",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                TaskScore,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct TaskDetailObject with 4 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                                TaskTime,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            1usize,
                                                            &"struct TaskDetailObject with 4 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                                TaskMemory,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            2usize,
                                                            &"struct TaskDetailObject with 4 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                                String,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            3usize,
                                                            &"struct TaskDetailObject with 4 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(TaskDetailObject {
                                                score: __field0,
                                                time: __field1,
                                                memory: __field2,
                                                status: __field3,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<TaskScore> = _serde::__private::None;
                                            let mut __field1: _serde::__private::Option<TaskTime> = _serde::__private::None;
                                            let mut __field2: _serde::__private::Option<TaskMemory> = _serde::__private::None;
                                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<TaskScore>(&mut __map)?,
                                                        );
                                                    }
                                                    __Field::__field1 => {
                                                        if _serde::__private::Option::is_some(&__field1) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("time"),
                                                            );
                                                        }
                                                        __field1 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<TaskTime>(&mut __map)?,
                                                        );
                                                    }
                                                    __Field::__field2 => {
                                                        if _serde::__private::Option::is_some(&__field2) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("memory"),
                                                            );
                                                        }
                                                        __field2 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<TaskMemory>(&mut __map)?,
                                                        );
                                                    }
                                                    __Field::__field3 => {
                                                        if _serde::__private::Option::is_some(&__field3) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                                            );
                                                        }
                                                        __field3 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("score")?
                                                }
                                            };
                                            let __field1 = match __field1 {
                                                _serde::__private::Some(__field1) => __field1,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("time")?
                                                }
                                            };
                                            let __field2 = match __field2 {
                                                _serde::__private::Some(__field2) => __field2,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("memory")?
                                                }
                                            };
                                            let __field3 = match __field3 {
                                                _serde::__private::Some(__field3) => __field3,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("status")?
                                                }
                                            };
                                            _serde::__private::Ok(TaskDetailObject {
                                                score: __field0,
                                                time: __field1,
                                                memory: __field2,
                                                status: __field3,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &[
                                        "score",
                                        "time",
                                        "memory",
                                        "status",
                                    ];
                                    _serde::Deserializer::deserialize_struct(
                                        __deserializer,
                                        "TaskDetailObject",
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<TaskDetailObject>,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                            }
                        };
                        #[automatically_derived]
                        impl ::core::fmt::Debug for TaskDetailObject {
                            #[inline]
                            fn fmt(
                                &self,
                                f: &mut ::core::fmt::Formatter,
                            ) -> ::core::fmt::Result {
                                ::core::fmt::Formatter::debug_struct_field4_finish(
                                    f,
                                    "TaskDetailObject",
                                    "score",
                                    &self.score,
                                    "time",
                                    &self.time,
                                    "memory",
                                    &self.memory,
                                    "status",
                                    &&self.status,
                                )
                            }
                        }
                        #[automatically_derived]
                        impl ::core::clone::Clone for TaskDetailObject {
                            #[inline]
                            fn clone(&self) -> TaskDetailObject {
                                TaskDetailObject {
                                    score: ::core::clone::Clone::clone(&self.score),
                                    time: ::core::clone::Clone::clone(&self.time),
                                    memory: ::core::clone::Clone::clone(&self.memory),
                                    status: ::core::clone::Clone::clone(&self.status),
                                }
                            }
                        }
                        let mut runtime = JsRuntime::new(RuntimeOptions::default());
                        let default_code = r#"
                function calculateScore(detail) {
                    let score = 0;
                    let time = 0;
                    let memory = 0;
                    let status = "Accepted";
                    for (let i = 0; i < detail.length; i++) {
                        const item = detail[i];
                        score += item.score;
                        time += item.time;
                        memory += item.memory;
                        if (item.status !== "Accepted" && status === "Accepted") {
                            status = item.status;
                        }
                    }
                    return {
                        score,
                        time,
                        memory,
                        status
                    };
            } calculateScore(detail);"#;
                        let result = eval(
                            &mut runtime,
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "\n                let detail = {0};\n                let now_time = {1};\n                {2}\n            ",
                                        ::serde_json::to_value(
                                                &task_detail
                                                    .iter()
                                                    .map(|(s, t, m, r)| {
                                                        TaskDetailObject {
                                                            score: *s,
                                                            time: *t,
                                                            memory: *m,
                                                            status: r.to_string(),
                                                        }
                                                    })
                                                    .collect::<Vec<_>>(),
                                            )
                                            .unwrap(),
                                        chrono::offset::Utc::now()
                                            .naive_utc()
                                            .and_utc()
                                            .timestamp(),
                                        calc_function.unwrap_or(default_code.to_string()),
                                    ),
                                )
                            }),
                        )?;
                        match &result {
                            tmp => {
                                {
                                    ::std::io::_eprint(
                                        format_args!(
                                            "[{0}:{1}:{2}] {3} = {4:#?}\n",
                                            "packages/core/src/service/judge/calc.rs",
                                            134u32,
                                            13u32,
                                            "&result",
                                            &&tmp as &dyn ::std::fmt::Debug,
                                        ),
                                    );
                                };
                                tmp
                            }
                        };
                        if let Some(result) = result.as_object()
                            && let Some(score) = result.get("score")
                            && let Some(score) = score.as_f64()
                            && let Some(time) = result.get("time")
                            && let Some(time) = time.as_i64()
                            && let Some(memory) = result.get("memory")
                            && let Some(memory) = memory.as_i64()
                            && let Some(status) = result.get("status")
                            && let Some(status) = status.as_str()
                        {
                            Ok((score, time, memory, status.to_string().into()))
                        } else {
                            Err(
                                CoreError::InvalidFunction(
                                    "Invalid result from custom function".to_string(),
                                ),
                            )
                        }
                    }
                }
            }
            fn eval(context: &mut JsRuntime, code: String) -> Result<serde_json::Value> {
                let res = context.execute_script("<anon>", code);
                match res {
                    Ok(global) => {
                        let scope = &mut context.handle_scope();
                        let local = v8::Local::new(scope, global);
                        let deserialized_value = serde_v8::from_v8::<
                            serde_json::Value,
                        >(scope, local);
                        match deserialized_value {
                            Ok(value) => Ok(value),
                            Err(err) => {
                                Err(
                                    CoreError::InvalidFunction(
                                        "Failed to deserialize v8 value".to_string(),
                                    ),
                                )
                            }
                        }
                    }
                    Err(err) => {
                        Err(
                            CoreError::InvalidFunction(
                                ::alloc::__export::must_use({
                                    ::alloc::fmt::format(
                                        format_args!("Failed to execute script: {0}", err),
                                    )
                                }),
                            ),
                        )
                    }
                }
            }
        }
        pub mod service {
            use std::fmt::Debug;
            use serde::Serialize;
            use socketioxide::extract::{SocketRef, Data};
            use socketioxide::SocketIo;
            use serde_json::Value;
            use totp_rs::{Algorithm, Secret, TOTP};
            use macro_socket_auth::auth_socket_connect;
            use crate::{env, Result};
            async fn auth(socket: SocketRef, Data(key): Data<String>) {
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("{0} auth message: {1:?}", socket.id, key),
                                lvl,
                                &(
                                    "core::service::judge::service",
                                    "core::service::judge::service",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                let totp = TOTP::new(
                    Algorithm::SHA1,
                    12,
                    1,
                    30,
                    Secret::Encoded(env::EDGE_AUTH.lock().unwrap().clone())
                        .to_bytes()
                        .unwrap(),
                );
                if let Err(err) = totp {
                    return;
                }
                let totp = totp.unwrap();
                if let Ok(x) = totp.check_current(&key) && x {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("{0} auth success: {1:?}", socket.id, x),
                                    lvl,
                                    &(
                                        "core::service::judge::service",
                                        "core::service::judge::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                } else {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Invalid TOTP key: {0}", key),
                                    lvl,
                                    &(
                                        "core::service::judge::service",
                                        "core::service::judge::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    return;
                }
                env::EDGE_AUTH_MAP
                    .lock()
                    .unwrap()
                    .entry(socket.id.to_string())
                    .or_insert(1);
                env::EDGE_SOCKETS
                    .lock()
                    .unwrap()
                    .entry(socket.id.to_string())
                    .or_insert(socket.clone());
                env::EDGE_VEC.lock().unwrap().push(socket.id.to_string());
                socket.emit("auth_response", "Authentication successful");
            }
            fn check_auth(socket: &SocketRef) -> bool {
                if let Some(auth_count) = env::EDGE_AUTH_MAP
                    .lock()
                    .unwrap()
                    .get(&socket.id.to_string())
                {
                    {
                        {
                            let lvl = ::log::Level::Trace;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "{0} auth success: {1:?}",
                                        socket.id,
                                        auth_count,
                                    ),
                                    lvl,
                                    &(
                                        "core::service::judge::service",
                                        "core::service::judge::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    if *auth_count > 0 {
                        return true;
                    }
                }
                {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Socket {0} is not authenticated", socket.id),
                                lvl,
                                &(
                                    "core::service::judge::service",
                                    "core::service::judge::service",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                false
            }
            async fn update_status(___socket: &SocketRef, Data(key): Data<String>) {
                let has_permission = check_auth(___socket);
                if !has_permission {
                    return;
                }
                {}
            }
            fn erase_socket(socket: &SocketRef) {
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("Erasing socket: {0}", socket.id),
                                lvl,
                                &(
                                    "core::service::judge::service",
                                    "core::service::judge::service",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                env::EDGE_SOCKETS.lock().unwrap().remove(&socket.id.to_string());
                env::EDGE_VEC.lock().unwrap().retain(|id| id != &socket.id.to_string());
            }
            pub async fn add_task<T: ?Sized + Serialize + Debug>(task: &T) -> bool {
                let now_id = *env::EDGE_NUM.lock().unwrap();
                if env::EDGE_SOCKETS.lock().unwrap().len() == 0 {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("No edge sockets available to add task."),
                                    lvl,
                                    &(
                                        "core::service::judge::service",
                                        "core::service::judge::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    return false;
                }
                let use_id = (now_id + 1)
                    % (env::EDGE_SOCKETS.lock().unwrap().len() as i32);
                *env::EDGE_NUM.lock().unwrap() = use_id;
                let use_id = env::EDGE_VEC
                    .lock()
                    .unwrap()
                    .get(use_id as usize)
                    .unwrap()
                    .clone();
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!("add task to socket: {0}", use_id),
                                lvl,
                                &(
                                    "core::service::judge::service",
                                    "core::service::judge::service",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                if let Some(socket) = env::EDGE_SOCKETS.lock().unwrap().get(&use_id) {
                    if let Err(err) = socket.emit("task", task) {
                        {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api::log(
                                        { ::log::__private_api::GlobalLogger },
                                        format_args!("Failed to emit task: {0}", err),
                                        lvl,
                                        &(
                                            "core::service::judge::service",
                                            "core::service::judge::service",
                                            ::log::__private_api::loc(),
                                        ),
                                        (),
                                    );
                                }
                            }
                        };
                        erase_socket(&socket);
                        return false;
                    }
                } else {
                    {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!("Socket not found for id: {0}", use_id),
                                    lvl,
                                    &(
                                        "core::service::judge::service",
                                        "core::service::judge::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    return false;
                }
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "successfully added task {0:?} to socket: {1}",
                                    task,
                                    use_id,
                                ),
                                lvl,
                                &(
                                    "core::service::judge::service",
                                    "core::service::judge::service",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                true
            }
            async fn on_connect(socket: SocketRef, Data(data): Data<Value>) {
                {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                { ::log::__private_api::GlobalLogger },
                                format_args!(
                                    "socket io connected: {0:?} {1:?}",
                                    socket.ns(),
                                    socket.id,
                                ),
                                lvl,
                                &(
                                    "core::service::judge::service",
                                    "core::service::judge::service",
                                    ::log::__private_api::loc(),
                                ),
                                (),
                            );
                        }
                    }
                };
                socket.on("auth", auth);
                socket.on("update_status", update_status);
            }
            pub fn service_start(port: i8) -> Result<()> {
                let body = async {
                    {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    { ::log::__private_api::GlobalLogger },
                                    format_args!(
                                        "VJudge Task server will be started at ::{0}",
                                        port,
                                    ),
                                    lvl,
                                    &(
                                        "core::service::judge::service",
                                        "core::service::judge::service",
                                        ::log::__private_api::loc(),
                                    ),
                                    (),
                                );
                            }
                        }
                    };
                    let (layer, io) = SocketIo::new_layer();
                    io.ns("/", on_connect);
                    Ok(())
                };
                #[allow(
                    clippy::expect_used,
                    clippy::diverging_sub_expression,
                    clippy::needless_return
                )]
                {
                    return tokio::runtime::Builder::new_multi_thread()
                        .enable_all()
                        .build()
                        .expect("Failed building the Runtime")
                        .block_on(body);
                }
            }
        }
    }
    pub mod track {
        pub async fn add_track_task() {}
        pub async fn start_service() {}
    }
    pub async fn service_start(db: &DatabaseConnection) -> Result<(), CoreError> {
        {
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        { ::log::__private_api::GlobalLogger },
                        format_args!("init the default nodes"),
                        lvl,
                        &("core::service", "core::service", ::log::__private_api::loc()),
                        (),
                    );
                }
            }
        };
        let default_nodes = crate::graph::action::get_default_node(db).await?;
        {
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        { ::log::__private_api::GlobalLogger },
                        format_args!("Default nodes: {0:?}", default_nodes),
                        lvl,
                        &("core::service", "core::service", ::log::__private_api::loc()),
                        (),
                    );
                }
            }
        };
        let mut default_nodes_env = crate::env::DEFAULT_NODES.lock().unwrap();
        *default_nodes_env = default_nodes;
        Ok(())
    }
}
pub mod utils {
    pub mod encrypt {
        use sha2::{Digest, Sha512};
        pub fn encode_password(data: &String) -> String {
            base16ct::lower::encode_string(&Sha512::digest(data.as_bytes()))
        }
    }
    pub mod perm {
        pub trait Perm {
            fn add_perm<T>(self, perm: T) -> Self
            where
                T: Into<Self>,
                Self: Sized + Into<i64> + From<i64>,
            {
                use tap::Conv;
                (self.conv::<i64>() | perm.into().conv::<i64>()).into()
            }
            fn remove_perm<T>(self, perm: T) -> Self
            where
                T: Into<Self>,
                Self: Sized + Into<i64> + From<i64>,
            {
                use tap::Conv;
                (self.conv::<i64>() & (-1i64 ^ perm.into().conv::<i64>())).into()
            }
        }
    }
}
